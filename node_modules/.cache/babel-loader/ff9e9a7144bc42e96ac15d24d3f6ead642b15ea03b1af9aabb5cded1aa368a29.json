{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Mesh, PerspectiveCamera, Color, Plane, Vector3, Matrix4, Vector4, WebGLRenderTarget, HalfFloatType, ShaderMaterial, UniformsUtils, NoToneMapping } from \"three\";\nimport { version } from \"../_polyfill/constants.js\";\nconst Reflector = /* @__PURE__ */(() => {\n  const _Reflector = class extends Mesh {\n    constructor(geometry, options = {}) {\n      super(geometry);\n      this.isReflector = true;\n      this.type = \"Reflector\";\n      this.camera = new PerspectiveCamera();\n      const scope = this;\n      const color = options.color !== void 0 ? new Color(options.color) : new Color(8355711);\n      const textureWidth = options.textureWidth || 512;\n      const textureHeight = options.textureHeight || 512;\n      const clipBias = options.clipBias || 0;\n      const shader = options.shader || _Reflector.ReflectorShader;\n      const multisample = options.multisample !== void 0 ? options.multisample : 4;\n      const reflectorPlane = new Plane();\n      const normal = new Vector3();\n      const reflectorWorldPosition = new Vector3();\n      const cameraWorldPosition = new Vector3();\n      const rotationMatrix = new Matrix4();\n      const lookAtPosition = new Vector3(0, 0, -1);\n      const clipPlane = new Vector4();\n      const view = new Vector3();\n      const target = new Vector3();\n      const q = new Vector4();\n      const textureMatrix = new Matrix4();\n      const virtualCamera = this.camera;\n      const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, {\n        samples: multisample,\n        type: HalfFloatType\n      });\n      const material = new ShaderMaterial({\n        uniforms: UniformsUtils.clone(shader.uniforms),\n        fragmentShader: shader.fragmentShader,\n        vertexShader: shader.vertexShader\n      });\n      material.uniforms[\"tDiffuse\"].value = renderTarget.texture;\n      material.uniforms[\"color\"].value = color;\n      material.uniforms[\"textureMatrix\"].value = textureMatrix;\n      this.material = material;\n      this.onBeforeRender = function (renderer, scene, camera) {\n        reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n        cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n        rotationMatrix.extractRotation(scope.matrixWorld);\n        normal.set(0, 0, 1);\n        normal.applyMatrix4(rotationMatrix);\n        view.subVectors(reflectorWorldPosition, cameraWorldPosition);\n        if (view.dot(normal) > 0) return;\n        view.reflect(normal).negate();\n        view.add(reflectorWorldPosition);\n        rotationMatrix.extractRotation(camera.matrixWorld);\n        lookAtPosition.set(0, 0, -1);\n        lookAtPosition.applyMatrix4(rotationMatrix);\n        lookAtPosition.add(cameraWorldPosition);\n        target.subVectors(reflectorWorldPosition, lookAtPosition);\n        target.reflect(normal).negate();\n        target.add(reflectorWorldPosition);\n        virtualCamera.position.copy(view);\n        virtualCamera.up.set(0, 1, 0);\n        virtualCamera.up.applyMatrix4(rotationMatrix);\n        virtualCamera.up.reflect(normal);\n        virtualCamera.lookAt(target);\n        virtualCamera.far = camera.far;\n        virtualCamera.updateMatrixWorld();\n        virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n        textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);\n        textureMatrix.multiply(virtualCamera.projectionMatrix);\n        textureMatrix.multiply(virtualCamera.matrixWorldInverse);\n        textureMatrix.multiply(scope.matrixWorld);\n        reflectorPlane.setFromNormalAndCoplanarPoint(normal, reflectorWorldPosition);\n        reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n        clipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant);\n        const projectionMatrix = virtualCamera.projectionMatrix;\n        q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n        q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n        q.z = -1;\n        q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];\n        clipPlane.multiplyScalar(2 / clipPlane.dot(q));\n        projectionMatrix.elements[2] = clipPlane.x;\n        projectionMatrix.elements[6] = clipPlane.y;\n        projectionMatrix.elements[10] = clipPlane.z + 1 - clipBias;\n        projectionMatrix.elements[14] = clipPlane.w;\n        scope.visible = false;\n        const currentRenderTarget = renderer.getRenderTarget();\n        const currentXrEnabled = renderer.xr.enabled;\n        const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n        const currentToneMapping = renderer.toneMapping;\n        let isSRGB = false;\n        if (\"outputColorSpace\" in renderer) isSRGB = renderer.outputColorSpace === \"srgb\";else isSRGB = renderer.outputEncoding === 3001;\n        renderer.xr.enabled = false;\n        renderer.shadowMap.autoUpdate = false;\n        if (\"outputColorSpace\" in renderer) renderer.outputColorSpace = \"srgb-linear\";else renderer.outputEncoding = 3e3;\n        renderer.toneMapping = NoToneMapping;\n        renderer.setRenderTarget(renderTarget);\n        renderer.state.buffers.depth.setMask(true);\n        if (renderer.autoClear === false) renderer.clear();\n        renderer.render(scene, virtualCamera);\n        renderer.xr.enabled = currentXrEnabled;\n        renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n        renderer.toneMapping = currentToneMapping;\n        if (\"outputColorSpace\" in renderer) renderer.outputColorSpace = isSRGB ? \"srgb\" : \"srgb-linear\";else renderer.outputEncoding = isSRGB ? 3001 : 3e3;\n        renderer.setRenderTarget(currentRenderTarget);\n        const viewport = camera.viewport;\n        if (viewport !== void 0) {\n          renderer.state.viewport(viewport);\n        }\n        scope.visible = true;\n      };\n      this.getRenderTarget = function () {\n        return renderTarget;\n      };\n      this.dispose = function () {\n        renderTarget.dispose();\n        scope.material.dispose();\n      };\n    }\n  };\n  let Reflector2 = _Reflector;\n  __publicField(Reflector2, \"ReflectorShader\", {\n    uniforms: {\n      color: {\n        value: null\n      },\n      tDiffuse: {\n        value: null\n      },\n      textureMatrix: {\n        value: null\n      }\n    },\n    vertexShader: (/* glsl */\n    `\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\t#include <common>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t#include <logdepthbuf_vertex>\n\n\t\t}`),\n    fragmentShader: (/* glsl */\n    `\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tvarying vec4 vUv;\n\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <${version >= 154 ? \"colorspace_fragment\" : \"encodings_fragment\"}>\n\n\t\t}`)\n  });\n  return Reflector2;\n})();\nexport { Reflector };","map":{"version":3,"names":["__defProp","Object","defineProperty","__defNormalProp","obj","key","value","enumerable","configurable","writable","__publicField","Mesh","PerspectiveCamera","Color","Plane","Vector3","Matrix4","Vector4","WebGLRenderTarget","HalfFloatType","ShaderMaterial","UniformsUtils","NoToneMapping","version","Reflector","_Reflector","constructor","geometry","options","isReflector","type","camera","scope","color","textureWidth","textureHeight","clipBias","shader","ReflectorShader","multisample","reflectorPlane","normal","reflectorWorldPosition","cameraWorldPosition","rotationMatrix","lookAtPosition","clipPlane","view","target","q","textureMatrix","virtualCamera","renderTarget","samples","material","uniforms","clone","fragmentShader","vertexShader","texture","onBeforeRender","renderer","scene","setFromMatrixPosition","matrixWorld","extractRotation","set","applyMatrix4","subVectors","dot","reflect","negate","add","position","copy","up","lookAt","far","updateMatrixWorld","projectionMatrix","multiply","matrixWorldInverse","setFromNormalAndCoplanarPoint","x","y","z","constant","Math","sign","elements","w","multiplyScalar","visible","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","currentToneMapping","toneMapping","isSRGB","outputColorSpace","outputEncoding","setRenderTarget","state","buffers","depth","setMask","autoClear","clear","render","viewport","dispose","Reflector2","tDiffuse"],"sources":["C:/Users/srk/Downloads/arq_phantom_clone/node_modules/three-stdlib/objects/Reflector.js"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Mesh, PerspectiveCamera, Color, Plane, Vector3, Matrix4, Vector4, WebGLRenderTarget, HalfFloatType, ShaderMaterial, UniformsUtils, NoToneMapping } from \"three\";\nimport { version } from \"../_polyfill/constants.js\";\nconst Reflector = /* @__PURE__ */ (() => {\n  const _Reflector = class extends Mesh {\n    constructor(geometry, options = {}) {\n      super(geometry);\n      this.isReflector = true;\n      this.type = \"Reflector\";\n      this.camera = new PerspectiveCamera();\n      const scope = this;\n      const color = options.color !== void 0 ? new Color(options.color) : new Color(8355711);\n      const textureWidth = options.textureWidth || 512;\n      const textureHeight = options.textureHeight || 512;\n      const clipBias = options.clipBias || 0;\n      const shader = options.shader || _Reflector.ReflectorShader;\n      const multisample = options.multisample !== void 0 ? options.multisample : 4;\n      const reflectorPlane = new Plane();\n      const normal = new Vector3();\n      const reflectorWorldPosition = new Vector3();\n      const cameraWorldPosition = new Vector3();\n      const rotationMatrix = new Matrix4();\n      const lookAtPosition = new Vector3(0, 0, -1);\n      const clipPlane = new Vector4();\n      const view = new Vector3();\n      const target = new Vector3();\n      const q = new Vector4();\n      const textureMatrix = new Matrix4();\n      const virtualCamera = this.camera;\n      const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, {\n        samples: multisample,\n        type: HalfFloatType\n      });\n      const material = new ShaderMaterial({\n        uniforms: UniformsUtils.clone(shader.uniforms),\n        fragmentShader: shader.fragmentShader,\n        vertexShader: shader.vertexShader\n      });\n      material.uniforms[\"tDiffuse\"].value = renderTarget.texture;\n      material.uniforms[\"color\"].value = color;\n      material.uniforms[\"textureMatrix\"].value = textureMatrix;\n      this.material = material;\n      this.onBeforeRender = function(renderer, scene, camera) {\n        reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n        cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n        rotationMatrix.extractRotation(scope.matrixWorld);\n        normal.set(0, 0, 1);\n        normal.applyMatrix4(rotationMatrix);\n        view.subVectors(reflectorWorldPosition, cameraWorldPosition);\n        if (view.dot(normal) > 0)\n          return;\n        view.reflect(normal).negate();\n        view.add(reflectorWorldPosition);\n        rotationMatrix.extractRotation(camera.matrixWorld);\n        lookAtPosition.set(0, 0, -1);\n        lookAtPosition.applyMatrix4(rotationMatrix);\n        lookAtPosition.add(cameraWorldPosition);\n        target.subVectors(reflectorWorldPosition, lookAtPosition);\n        target.reflect(normal).negate();\n        target.add(reflectorWorldPosition);\n        virtualCamera.position.copy(view);\n        virtualCamera.up.set(0, 1, 0);\n        virtualCamera.up.applyMatrix4(rotationMatrix);\n        virtualCamera.up.reflect(normal);\n        virtualCamera.lookAt(target);\n        virtualCamera.far = camera.far;\n        virtualCamera.updateMatrixWorld();\n        virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n        textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);\n        textureMatrix.multiply(virtualCamera.projectionMatrix);\n        textureMatrix.multiply(virtualCamera.matrixWorldInverse);\n        textureMatrix.multiply(scope.matrixWorld);\n        reflectorPlane.setFromNormalAndCoplanarPoint(normal, reflectorWorldPosition);\n        reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n        clipPlane.set(\n          reflectorPlane.normal.x,\n          reflectorPlane.normal.y,\n          reflectorPlane.normal.z,\n          reflectorPlane.constant\n        );\n        const projectionMatrix = virtualCamera.projectionMatrix;\n        q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n        q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n        q.z = -1;\n        q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];\n        clipPlane.multiplyScalar(2 / clipPlane.dot(q));\n        projectionMatrix.elements[2] = clipPlane.x;\n        projectionMatrix.elements[6] = clipPlane.y;\n        projectionMatrix.elements[10] = clipPlane.z + 1 - clipBias;\n        projectionMatrix.elements[14] = clipPlane.w;\n        scope.visible = false;\n        const currentRenderTarget = renderer.getRenderTarget();\n        const currentXrEnabled = renderer.xr.enabled;\n        const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n        const currentToneMapping = renderer.toneMapping;\n        let isSRGB = false;\n        if (\"outputColorSpace\" in renderer)\n          isSRGB = renderer.outputColorSpace === \"srgb\";\n        else\n          isSRGB = renderer.outputEncoding === 3001;\n        renderer.xr.enabled = false;\n        renderer.shadowMap.autoUpdate = false;\n        if (\"outputColorSpace\" in renderer)\n          renderer.outputColorSpace = \"srgb-linear\";\n        else\n          renderer.outputEncoding = 3e3;\n        renderer.toneMapping = NoToneMapping;\n        renderer.setRenderTarget(renderTarget);\n        renderer.state.buffers.depth.setMask(true);\n        if (renderer.autoClear === false)\n          renderer.clear();\n        renderer.render(scene, virtualCamera);\n        renderer.xr.enabled = currentXrEnabled;\n        renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n        renderer.toneMapping = currentToneMapping;\n        if (\"outputColorSpace\" in renderer)\n          renderer.outputColorSpace = isSRGB ? \"srgb\" : \"srgb-linear\";\n        else\n          renderer.outputEncoding = isSRGB ? 3001 : 3e3;\n        renderer.setRenderTarget(currentRenderTarget);\n        const viewport = camera.viewport;\n        if (viewport !== void 0) {\n          renderer.state.viewport(viewport);\n        }\n        scope.visible = true;\n      };\n      this.getRenderTarget = function() {\n        return renderTarget;\n      };\n      this.dispose = function() {\n        renderTarget.dispose();\n        scope.material.dispose();\n      };\n    }\n  };\n  let Reflector2 = _Reflector;\n  __publicField(Reflector2, \"ReflectorShader\", {\n    uniforms: {\n      color: {\n        value: null\n      },\n      tDiffuse: {\n        value: null\n      },\n      textureMatrix: {\n        value: null\n      }\n    },\n    vertexShader: (\n      /* glsl */\n      `\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\t#include <common>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t#include <logdepthbuf_vertex>\n\n\t\t}`\n    ),\n    fragmentShader: (\n      /* glsl */\n      `\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tvarying vec4 vUv;\n\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <${version >= 154 ? \"colorspace_fragment\" : \"encodings_fragment\"}>\n\n\t\t}`\n    )\n  });\n  return Reflector2;\n})();\nexport {\n  Reflector\n};\n//# sourceMappingURL=Reflector.js.map\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}