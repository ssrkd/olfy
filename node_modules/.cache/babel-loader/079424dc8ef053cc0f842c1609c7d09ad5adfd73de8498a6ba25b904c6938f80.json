{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { PropertyBinding, InterpolateLinear, Color, Vector3, CompressedTexture, Texture, MathUtils, RGBAFormat, DoubleSide, BufferAttribute, InterpolateDiscrete, Matrix4, Scene, PlaneGeometry, ShaderMaterial, Uniform, Mesh, PerspectiveCamera, WebGLRenderer, NearestFilter, NearestMipmapNearestFilter, NearestMipmapLinearFilter, LinearFilter, LinearMipmapNearestFilter, LinearMipmapLinearFilter, ClampToEdgeWrapping, RepeatWrapping, MirroredRepeatWrapping } from \"three\";\nimport { version } from \"../_polyfill/constants.js\";\nasync function readAsDataURL(blob) {\n  const buffer = await blob.arrayBuffer();\n  const data = btoa(String.fromCharCode(...new Uint8Array(buffer)));\n  return `data:${blob.type || \"\"};base64,${data}`;\n}\nlet _renderer;\nlet fullscreenQuadGeometry;\nlet fullscreenQuadMaterial;\nlet fullscreenQuad;\nfunction decompress(texture, maxTextureSize = Infinity, renderer = null) {\n  if (!fullscreenQuadGeometry) fullscreenQuadGeometry = new PlaneGeometry(2, 2, 1, 1);\n  if (!fullscreenQuadMaterial) fullscreenQuadMaterial = new ShaderMaterial({\n    uniforms: {\n      blitTexture: new Uniform(texture)\n    },\n    vertexShader: (/* glsl */\n    `\n        varying vec2 vUv;\n        void main(){\n            vUv = uv;\n            gl_Position = vec4(position.xy * 1.0,0.,.999999);\n        }\n      `),\n    fragmentShader: (/* glsl */\n    `\n          uniform sampler2D blitTexture; \n          varying vec2 vUv;\n\n          void main(){ \n              gl_FragColor = vec4(vUv.xy, 0, 1);\n              \n              #ifdef IS_SRGB\n              gl_FragColor = LinearTosRGB( texture2D( blitTexture, vUv) );\n              #else\n              gl_FragColor = texture2D( blitTexture, vUv);\n              #endif\n          }\n      `)\n  });\n  fullscreenQuadMaterial.uniforms.blitTexture.value = texture;\n  fullscreenQuadMaterial.defines.IS_SRGB = \"colorSpace\" in texture ? texture.colorSpace === \"srgb\" : texture.encoding === 3001;\n  fullscreenQuadMaterial.needsUpdate = true;\n  if (!fullscreenQuad) {\n    fullscreenQuad = new Mesh(fullscreenQuadGeometry, fullscreenQuadMaterial);\n    fullscreenQuad.frustrumCulled = false;\n  }\n  const _camera = new PerspectiveCamera();\n  const _scene = new Scene();\n  _scene.add(fullscreenQuad);\n  if (!renderer) {\n    renderer = _renderer = new WebGLRenderer({\n      antialias: false\n    });\n  }\n  renderer.setSize(Math.min(texture.image.width, maxTextureSize), Math.min(texture.image.height, maxTextureSize));\n  renderer.clear();\n  renderer.render(_scene, _camera);\n  const readableTexture = new Texture(renderer.domElement);\n  readableTexture.minFilter = texture.minFilter;\n  readableTexture.magFilter = texture.magFilter;\n  readableTexture.wrapS = texture.wrapS;\n  readableTexture.wrapT = texture.wrapT;\n  readableTexture.name = texture.name;\n  if (_renderer) {\n    _renderer.dispose();\n    _renderer = null;\n  }\n  return readableTexture;\n}\nconst KHR_mesh_quantization_ExtraAttrTypes = {\n  POSITION: [\"byte\", \"byte normalized\", \"unsigned byte\", \"unsigned byte normalized\", \"short\", \"short normalized\", \"unsigned short\", \"unsigned short normalized\"],\n  NORMAL: [\"byte normalized\", \"short normalized\"],\n  TANGENT: [\"byte normalized\", \"short normalized\"],\n  TEXCOORD: [\"byte\", \"byte normalized\", \"unsigned byte\", \"short\", \"short normalized\", \"unsigned short\"]\n};\nconst GLTFExporter = /* @__PURE__ */(() => {\n  class GLTFExporter2 {\n    constructor() {\n      this.pluginCallbacks = [];\n      this.register(function (writer) {\n        return new GLTFLightExtension(writer);\n      });\n      this.register(function (writer) {\n        return new GLTFMaterialsUnlitExtension(writer);\n      });\n      this.register(function (writer) {\n        return new GLTFMaterialsTransmissionExtension(writer);\n      });\n      this.register(function (writer) {\n        return new GLTFMaterialsVolumeExtension(writer);\n      });\n      this.register(function (writer) {\n        return new GLTFMaterialsIorExtension(writer);\n      });\n      this.register(function (writer) {\n        return new GLTFMaterialsSpecularExtension(writer);\n      });\n      this.register(function (writer) {\n        return new GLTFMaterialsClearcoatExtension(writer);\n      });\n      this.register(function (writer) {\n        return new GLTFMaterialsIridescenceExtension(writer);\n      });\n      this.register(function (writer) {\n        return new GLTFMaterialsSheenExtension(writer);\n      });\n      this.register(function (writer) {\n        return new GLTFMaterialsAnisotropyExtension(writer);\n      });\n      this.register(function (writer) {\n        return new GLTFMaterialsEmissiveStrengthExtension(writer);\n      });\n    }\n    register(callback) {\n      if (this.pluginCallbacks.indexOf(callback) === -1) {\n        this.pluginCallbacks.push(callback);\n      }\n      return this;\n    }\n    unregister(callback) {\n      if (this.pluginCallbacks.indexOf(callback) !== -1) {\n        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\n      }\n      return this;\n    }\n    /**\n     * Parse scenes and generate GLTF output\n     * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n     * @param  {Function} onDone  Callback on completed\n     * @param  {Function} onError  Callback on errors\n     * @param  {Object} options options\n     */\n    parse(input, onDone, onError, options) {\n      const writer = new GLTFWriter();\n      const plugins = [];\n      for (let i = 0, il = this.pluginCallbacks.length; i < il; i++) {\n        plugins.push(this.pluginCallbacks[i](writer));\n      }\n      writer.setPlugins(plugins);\n      writer.write(input, onDone, options).catch(onError);\n    }\n    parseAsync(input, options) {\n      const scope = this;\n      return new Promise(function (resolve, reject) {\n        scope.parse(input, resolve, reject, options);\n      });\n    }\n  }\n  /**\n   * Static utility functions\n   */\n  __publicField(GLTFExporter2, \"Utils\", {\n    insertKeyframe: function (track, time) {\n      const tolerance = 1e-3;\n      const valueSize = track.getValueSize();\n      const times = new track.TimeBufferType(track.times.length + 1);\n      const values = new track.ValueBufferType(track.values.length + valueSize);\n      const interpolant = track.createInterpolant(new track.ValueBufferType(valueSize));\n      let index;\n      if (track.times.length === 0) {\n        times[0] = time;\n        for (let i = 0; i < valueSize; i++) {\n          values[i] = 0;\n        }\n        index = 0;\n      } else if (time < track.times[0]) {\n        if (Math.abs(track.times[0] - time) < tolerance) return 0;\n        times[0] = time;\n        times.set(track.times, 1);\n        values.set(interpolant.evaluate(time), 0);\n        values.set(track.values, valueSize);\n        index = 0;\n      } else if (time > track.times[track.times.length - 1]) {\n        if (Math.abs(track.times[track.times.length - 1] - time) < tolerance) {\n          return track.times.length - 1;\n        }\n        times[times.length - 1] = time;\n        times.set(track.times, 0);\n        values.set(track.values, 0);\n        values.set(interpolant.evaluate(time), track.values.length);\n        index = times.length - 1;\n      } else {\n        for (let i = 0; i < track.times.length; i++) {\n          if (Math.abs(track.times[i] - time) < tolerance) return i;\n          if (track.times[i] < time && track.times[i + 1] > time) {\n            times.set(track.times.slice(0, i + 1), 0);\n            times[i + 1] = time;\n            times.set(track.times.slice(i + 1), i + 2);\n            values.set(track.values.slice(0, (i + 1) * valueSize), 0);\n            values.set(interpolant.evaluate(time), (i + 1) * valueSize);\n            values.set(track.values.slice((i + 1) * valueSize), (i + 2) * valueSize);\n            index = i + 1;\n            break;\n          }\n        }\n      }\n      track.times = times;\n      track.values = values;\n      return index;\n    },\n    mergeMorphTargetTracks: function (clip, root) {\n      const tracks = [];\n      const mergedTracks = {};\n      const sourceTracks = clip.tracks;\n      for (let i = 0; i < sourceTracks.length; ++i) {\n        let sourceTrack = sourceTracks[i];\n        const sourceTrackBinding = PropertyBinding.parseTrackName(sourceTrack.name);\n        const sourceTrackNode = PropertyBinding.findNode(root, sourceTrackBinding.nodeName);\n        if (sourceTrackBinding.propertyName !== \"morphTargetInfluences\" || sourceTrackBinding.propertyIndex === void 0) {\n          tracks.push(sourceTrack);\n          continue;\n        }\n        if (sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete && sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear) {\n          if (sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n            throw new Error(\"THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.\");\n          }\n          console.warn(\"THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.\");\n          sourceTrack = sourceTrack.clone();\n          sourceTrack.setInterpolation(InterpolateLinear);\n        }\n        const targetCount = sourceTrackNode.morphTargetInfluences.length;\n        const targetIndex = sourceTrackNode.morphTargetDictionary[sourceTrackBinding.propertyIndex];\n        if (targetIndex === void 0) {\n          throw new Error(\"THREE.GLTFExporter: Morph target name not found: \" + sourceTrackBinding.propertyIndex);\n        }\n        let mergedTrack;\n        if (mergedTracks[sourceTrackNode.uuid] === void 0) {\n          mergedTrack = sourceTrack.clone();\n          const values = new mergedTrack.ValueBufferType(targetCount * mergedTrack.times.length);\n          for (let j = 0; j < mergedTrack.times.length; j++) {\n            values[j * targetCount + targetIndex] = mergedTrack.values[j];\n          }\n          mergedTrack.name = (sourceTrackBinding.nodeName || \"\") + \".morphTargetInfluences\";\n          mergedTrack.values = values;\n          mergedTracks[sourceTrackNode.uuid] = mergedTrack;\n          tracks.push(mergedTrack);\n          continue;\n        }\n        const sourceInterpolant = sourceTrack.createInterpolant(new sourceTrack.ValueBufferType(1));\n        mergedTrack = mergedTracks[sourceTrackNode.uuid];\n        for (let j = 0; j < mergedTrack.times.length; j++) {\n          mergedTrack.values[j * targetCount + targetIndex] = sourceInterpolant.evaluate(mergedTrack.times[j]);\n        }\n        for (let j = 0; j < sourceTrack.times.length; j++) {\n          const keyframeIndex = this.insertKeyframe(mergedTrack, sourceTrack.times[j]);\n          mergedTrack.values[keyframeIndex * targetCount + targetIndex] = sourceTrack.values[j];\n        }\n      }\n      clip.tracks = tracks;\n      return clip;\n    }\n  });\n  return GLTFExporter2;\n})();\nconst WEBGL_CONSTANTS = {\n  POINTS: 0,\n  LINES: 1,\n  LINE_LOOP: 2,\n  LINE_STRIP: 3,\n  TRIANGLES: 4,\n  TRIANGLE_STRIP: 5,\n  TRIANGLE_FAN: 6,\n  BYTE: 5120,\n  UNSIGNED_BYTE: 5121,\n  SHORT: 5122,\n  UNSIGNED_SHORT: 5123,\n  INT: 5124,\n  UNSIGNED_INT: 5125,\n  FLOAT: 5126,\n  ARRAY_BUFFER: 34962,\n  ELEMENT_ARRAY_BUFFER: 34963,\n  NEAREST: 9728,\n  LINEAR: 9729,\n  NEAREST_MIPMAP_NEAREST: 9984,\n  LINEAR_MIPMAP_NEAREST: 9985,\n  NEAREST_MIPMAP_LINEAR: 9986,\n  LINEAR_MIPMAP_LINEAR: 9987,\n  CLAMP_TO_EDGE: 33071,\n  MIRRORED_REPEAT: 33648,\n  REPEAT: 10497\n};\nconst KHR_MESH_QUANTIZATION = \"KHR_mesh_quantization\";\nconst THREE_TO_WEBGL = {};\nTHREE_TO_WEBGL[NearestFilter] = WEBGL_CONSTANTS.NEAREST;\nTHREE_TO_WEBGL[NearestMipmapNearestFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[NearestMipmapLinearFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[LinearFilter] = WEBGL_CONSTANTS.LINEAR;\nTHREE_TO_WEBGL[LinearMipmapNearestFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[LinearMipmapLinearFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[ClampToEdgeWrapping] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;\nTHREE_TO_WEBGL[RepeatWrapping] = WEBGL_CONSTANTS.REPEAT;\nTHREE_TO_WEBGL[MirroredRepeatWrapping] = WEBGL_CONSTANTS.MIRRORED_REPEAT;\nconst PATH_PROPERTIES = {\n  scale: \"scale\",\n  position: \"translation\",\n  quaternion: \"rotation\",\n  morphTargetInfluences: \"weights\"\n};\nconst DEFAULT_SPECULAR_COLOR = /* @__PURE__ */new Color();\nconst GLB_HEADER_BYTES = 12;\nconst GLB_HEADER_MAGIC = 1179937895;\nconst GLB_VERSION = 2;\nconst GLB_CHUNK_PREFIX_BYTES = 8;\nconst GLB_CHUNK_TYPE_JSON = 1313821514;\nconst GLB_CHUNK_TYPE_BIN = 5130562;\nfunction equalArray(array1, array2) {\n  return array1.length === array2.length && array1.every(function (element, index) {\n    return element === array2[index];\n  });\n}\nfunction stringToArrayBuffer(text) {\n  return new TextEncoder().encode(text).buffer;\n}\nfunction isIdentityMatrix(matrix) {\n  return equalArray(matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n}\nfunction getMinMax(attribute, start, count) {\n  const output = {\n    min: new Array(attribute.itemSize).fill(Number.POSITIVE_INFINITY),\n    max: new Array(attribute.itemSize).fill(Number.NEGATIVE_INFINITY)\n  };\n  for (let i = start; i < start + count; i++) {\n    for (let a = 0; a < attribute.itemSize; a++) {\n      let value;\n      if (attribute.itemSize > 4) {\n        value = attribute.array[i * attribute.itemSize + a];\n      } else {\n        if (a === 0) value = attribute.getX(i);else if (a === 1) value = attribute.getY(i);else if (a === 2) value = attribute.getZ(i);else if (a === 3) value = attribute.getW(i);\n        if (attribute.normalized === true) {\n          value = MathUtils.normalize(value, attribute.array);\n        }\n      }\n      output.min[a] = Math.min(output.min[a], value);\n      output.max[a] = Math.max(output.max[a], value);\n    }\n  }\n  return output;\n}\nfunction getPaddedBufferSize(bufferSize) {\n  return Math.ceil(bufferSize / 4) * 4;\n}\nfunction getPaddedArrayBuffer(arrayBuffer, paddingByte = 0) {\n  const paddedLength = getPaddedBufferSize(arrayBuffer.byteLength);\n  if (paddedLength !== arrayBuffer.byteLength) {\n    const array = new Uint8Array(paddedLength);\n    array.set(new Uint8Array(arrayBuffer));\n    if (paddingByte !== 0) {\n      for (let i = arrayBuffer.byteLength; i < paddedLength; i++) {\n        array[i] = paddingByte;\n      }\n    }\n    return array.buffer;\n  }\n  return arrayBuffer;\n}\nfunction getCanvas() {\n  if (typeof document === \"undefined\" && typeof OffscreenCanvas !== \"undefined\") {\n    return new OffscreenCanvas(1, 1);\n  }\n  return document.createElement(\"canvas\");\n}\nfunction getToBlobPromise(canvas, mimeType) {\n  if (canvas.toBlob !== void 0) {\n    return new Promise(resolve => canvas.toBlob(resolve, mimeType));\n  }\n  let quality;\n  if (mimeType === \"image/jpeg\") {\n    quality = 0.92;\n  } else if (mimeType === \"image/webp\") {\n    quality = 0.8;\n  }\n  return canvas.convertToBlob({\n    type: mimeType,\n    quality\n  });\n}\nclass GLTFWriter {\n  constructor() {\n    this.plugins = [];\n    this.options = {};\n    this.pending = [];\n    this.buffers = [];\n    this.byteOffset = 0;\n    this.buffers = [];\n    this.nodeMap = /* @__PURE__ */new Map();\n    this.skins = [];\n    this.extensionsUsed = {};\n    this.extensionsRequired = {};\n    this.uids = /* @__PURE__ */new Map();\n    this.uid = 0;\n    this.json = {\n      asset: {\n        version: \"2.0\",\n        generator: \"THREE.GLTFExporter\"\n      }\n    };\n    this.cache = {\n      meshes: /* @__PURE__ */new Map(),\n      attributes: /* @__PURE__ */new Map(),\n      attributesNormalized: /* @__PURE__ */new Map(),\n      materials: /* @__PURE__ */new Map(),\n      textures: /* @__PURE__ */new Map(),\n      images: /* @__PURE__ */new Map()\n    };\n  }\n  setPlugins(plugins) {\n    this.plugins = plugins;\n  }\n  /**\n   * Parse scenes and generate GLTF output\n   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n   * @param  {Function} onDone  Callback on completed\n   * @param  {Object} options options\n   */\n  async write(input, onDone, options = {}) {\n    this.options = Object.assign({\n      // default options\n      binary: false,\n      trs: false,\n      onlyVisible: true,\n      maxTextureSize: Infinity,\n      animations: [],\n      includeCustomExtensions: false\n    }, options);\n    if (this.options.animations.length > 0) {\n      this.options.trs = true;\n    }\n    this.processInput(input);\n    await Promise.all(this.pending);\n    const writer = this;\n    const buffers = writer.buffers;\n    const json = writer.json;\n    options = writer.options;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionsRequired = writer.extensionsRequired;\n    const blob = new Blob(buffers, {\n      type: \"application/octet-stream\"\n    });\n    const extensionsUsedList = Object.keys(extensionsUsed);\n    const extensionsRequiredList = Object.keys(extensionsRequired);\n    if (extensionsUsedList.length > 0) json.extensionsUsed = extensionsUsedList;\n    if (extensionsRequiredList.length > 0) json.extensionsRequired = extensionsRequiredList;\n    if (json.buffers && json.buffers.length > 0) json.buffers[0].byteLength = blob.size;\n    if (options.binary === true) {\n      blob.arrayBuffer().then(result => {\n        const binaryChunk = getPaddedArrayBuffer(result);\n        const binaryChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n        binaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true);\n        binaryChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_BIN, true);\n        const jsonChunk = getPaddedArrayBuffer(stringToArrayBuffer(JSON.stringify(json)), 32);\n        const jsonChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n        jsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true);\n        jsonChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_JSON, true);\n        const header = new ArrayBuffer(GLB_HEADER_BYTES);\n        const headerView = new DataView(header);\n        headerView.setUint32(0, GLB_HEADER_MAGIC, true);\n        headerView.setUint32(4, GLB_VERSION, true);\n        const totalByteLength = GLB_HEADER_BYTES + jsonChunkPrefix.byteLength + jsonChunk.byteLength + binaryChunkPrefix.byteLength + binaryChunk.byteLength;\n        headerView.setUint32(8, totalByteLength, true);\n        const glbBlob = new Blob([header, jsonChunkPrefix, jsonChunk, binaryChunkPrefix, binaryChunk], {\n          type: \"application/octet-stream\"\n        });\n        glbBlob.arrayBuffer().then(onDone);\n      });\n    } else {\n      if (json.buffers && json.buffers.length > 0) {\n        readAsDataURL(blob).then(uri => {\n          json.buffers[0].uri = uri;\n          onDone(json);\n        });\n      } else {\n        onDone(json);\n      }\n    }\n  }\n  /**\n   * Serializes a userData.\n   *\n   * @param {THREE.Object3D|THREE.Material} object\n   * @param {Object} objectDef\n   */\n  serializeUserData(object, objectDef) {\n    if (Object.keys(object.userData).length === 0) return;\n    const options = this.options;\n    const extensionsUsed = this.extensionsUsed;\n    try {\n      const json = JSON.parse(JSON.stringify(object.userData));\n      if (options.includeCustomExtensions && json.gltfExtensions) {\n        if (objectDef.extensions === void 0) objectDef.extensions = {};\n        for (const extensionName in json.gltfExtensions) {\n          objectDef.extensions[extensionName] = json.gltfExtensions[extensionName];\n          extensionsUsed[extensionName] = true;\n        }\n        delete json.gltfExtensions;\n      }\n      if (Object.keys(json).length > 0) objectDef.extras = json;\n    } catch (error) {\n      console.warn(\"THREE.GLTFExporter: userData of '\" + object.name + \"' won't be serialized because of JSON.stringify error - \" + error.message);\n    }\n  }\n  /**\n   * Returns ids for buffer attributes.\n   * @param  {Object} object\n   * @return {Integer}\n   */\n  getUID(attribute, isRelativeCopy = false) {\n    if (this.uids.has(attribute) === false) {\n      const uids2 = /* @__PURE__ */new Map();\n      uids2.set(true, this.uid++);\n      uids2.set(false, this.uid++);\n      this.uids.set(attribute, uids2);\n    }\n    const uids = this.uids.get(attribute);\n    return uids.get(isRelativeCopy);\n  }\n  /**\n   * Checks if normal attribute values are normalized.\n   *\n   * @param {BufferAttribute} normal\n   * @returns {Boolean}\n   */\n  isNormalizedNormalAttribute(normal) {\n    const cache = this.cache;\n    if (cache.attributesNormalized.has(normal)) return false;\n    const v = new Vector3();\n    for (let i = 0, il = normal.count; i < il; i++) {\n      if (Math.abs(v.fromBufferAttribute(normal, i).length() - 1) > 5e-4) return false;\n    }\n    return true;\n  }\n  /**\n   * Creates normalized normal buffer attribute.\n   *\n   * @param {BufferAttribute} normal\n   * @returns {BufferAttribute}\n   *\n   */\n  createNormalizedNormalAttribute(normal) {\n    const cache = this.cache;\n    if (cache.attributesNormalized.has(normal)) return cache.attributesNormalized.get(normal);\n    const attribute = normal.clone();\n    const v = new Vector3();\n    for (let i = 0, il = attribute.count; i < il; i++) {\n      v.fromBufferAttribute(attribute, i);\n      if (v.x === 0 && v.y === 0 && v.z === 0) {\n        v.setX(1);\n      } else {\n        v.normalize();\n      }\n      attribute.setXYZ(i, v.x, v.y, v.z);\n    }\n    cache.attributesNormalized.set(normal, attribute);\n    return attribute;\n  }\n  /**\n   * Applies a texture transform, if present, to the map definition. Requires\n   * the KHR_texture_transform extension.\n   *\n   * @param {Object} mapDef\n   * @param {THREE.Texture} texture\n   */\n  applyTextureTransform(mapDef, texture) {\n    let didTransform = false;\n    const transformDef = {};\n    if (texture.offset.x !== 0 || texture.offset.y !== 0) {\n      transformDef.offset = texture.offset.toArray();\n      didTransform = true;\n    }\n    if (texture.rotation !== 0) {\n      transformDef.rotation = texture.rotation;\n      didTransform = true;\n    }\n    if (texture.repeat.x !== 1 || texture.repeat.y !== 1) {\n      transformDef.scale = texture.repeat.toArray();\n      didTransform = true;\n    }\n    if (didTransform) {\n      mapDef.extensions = mapDef.extensions || {};\n      mapDef.extensions[\"KHR_texture_transform\"] = transformDef;\n      this.extensionsUsed[\"KHR_texture_transform\"] = true;\n    }\n  }\n  buildMetalRoughTexture(metalnessMap, roughnessMap) {\n    if (metalnessMap === roughnessMap) return metalnessMap;\n    function getEncodingConversion(map) {\n      if (\"colorSpace\" in map ? map.colorSpace === \"srgb\" : map.encoding === 3001) {\n        return function SRGBToLinear(c) {\n          return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);\n        };\n      }\n      return function LinearToLinear(c) {\n        return c;\n      };\n    }\n    console.warn(\"THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures.\");\n    if (metalnessMap instanceof CompressedTexture) {\n      metalnessMap = decompress(metalnessMap);\n    }\n    if (roughnessMap instanceof CompressedTexture) {\n      roughnessMap = decompress(roughnessMap);\n    }\n    const metalness = metalnessMap ? metalnessMap.image : null;\n    const roughness = roughnessMap ? roughnessMap.image : null;\n    const width = Math.max(metalness ? metalness.width : 0, roughness ? roughness.width : 0);\n    const height = Math.max(metalness ? metalness.height : 0, roughness ? roughness.height : 0);\n    const canvas = getCanvas();\n    canvas.width = width;\n    canvas.height = height;\n    const context = canvas.getContext(\"2d\");\n    context.fillStyle = \"#00ffff\";\n    context.fillRect(0, 0, width, height);\n    const composite = context.getImageData(0, 0, width, height);\n    if (metalness) {\n      context.drawImage(metalness, 0, 0, width, height);\n      const convert = getEncodingConversion(metalnessMap);\n      const data = context.getImageData(0, 0, width, height).data;\n      for (let i = 2; i < data.length; i += 4) {\n        composite.data[i] = convert(data[i] / 256) * 256;\n      }\n    }\n    if (roughness) {\n      context.drawImage(roughness, 0, 0, width, height);\n      const convert = getEncodingConversion(roughnessMap);\n      const data = context.getImageData(0, 0, width, height).data;\n      for (let i = 1; i < data.length; i += 4) {\n        composite.data[i] = convert(data[i] / 256) * 256;\n      }\n    }\n    context.putImageData(composite, 0, 0);\n    const reference = metalnessMap || roughnessMap;\n    const texture = reference.clone();\n    texture.source = new Texture(canvas).source;\n    if (\"colorSpace\" in texture) texture.colorSpace = \"\";else texture.encoding = 3e3;\n    texture.channel = (metalnessMap || roughnessMap).channel;\n    if (metalnessMap && roughnessMap && metalnessMap.channel !== roughnessMap.channel) {\n      console.warn(\"THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match.\");\n    }\n    return texture;\n  }\n  /**\n   * Process a buffer to append to the default one.\n   * @param  {ArrayBuffer} buffer\n   * @return {Integer}\n   */\n  processBuffer(buffer) {\n    const json = this.json;\n    const buffers = this.buffers;\n    if (!json.buffers) json.buffers = [{\n      byteLength: 0\n    }];\n    buffers.push(buffer);\n    return 0;\n  }\n  /**\n   * Process and generate a BufferView\n   * @param  {BufferAttribute} attribute\n   * @param  {number} componentType\n   * @param  {number} start\n   * @param  {number} count\n   * @param  {number} target (Optional) Target usage of the BufferView\n   * @return {Object}\n   */\n  processBufferView(attribute, componentType, start, count, target) {\n    const json = this.json;\n    if (!json.bufferViews) json.bufferViews = [];\n    let componentSize;\n    switch (componentType) {\n      case WEBGL_CONSTANTS.BYTE:\n      case WEBGL_CONSTANTS.UNSIGNED_BYTE:\n        componentSize = 1;\n        break;\n      case WEBGL_CONSTANTS.SHORT:\n      case WEBGL_CONSTANTS.UNSIGNED_SHORT:\n        componentSize = 2;\n        break;\n      default:\n        componentSize = 4;\n    }\n    let byteStride = attribute.itemSize * componentSize;\n    if (target === WEBGL_CONSTANTS.ARRAY_BUFFER) {\n      byteStride = Math.ceil(byteStride / 4) * 4;\n    }\n    const byteLength = getPaddedBufferSize(count * byteStride);\n    const dataView = new DataView(new ArrayBuffer(byteLength));\n    let offset = 0;\n    for (let i = start; i < start + count; i++) {\n      for (let a = 0; a < attribute.itemSize; a++) {\n        let value;\n        if (attribute.itemSize > 4) {\n          value = attribute.array[i * attribute.itemSize + a];\n        } else {\n          if (a === 0) value = attribute.getX(i);else if (a === 1) value = attribute.getY(i);else if (a === 2) value = attribute.getZ(i);else if (a === 3) value = attribute.getW(i);\n          if (attribute.normalized === true) {\n            value = MathUtils.normalize(value, attribute.array);\n          }\n        }\n        if (componentType === WEBGL_CONSTANTS.FLOAT) {\n          dataView.setFloat32(offset, value, true);\n        } else if (componentType === WEBGL_CONSTANTS.INT) {\n          dataView.setInt32(offset, value, true);\n        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_INT) {\n          dataView.setUint32(offset, value, true);\n        } else if (componentType === WEBGL_CONSTANTS.SHORT) {\n          dataView.setInt16(offset, value, true);\n        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\n          dataView.setUint16(offset, value, true);\n        } else if (componentType === WEBGL_CONSTANTS.BYTE) {\n          dataView.setInt8(offset, value);\n        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\n          dataView.setUint8(offset, value);\n        }\n        offset += componentSize;\n      }\n      if (offset % byteStride !== 0) {\n        offset += byteStride - offset % byteStride;\n      }\n    }\n    const bufferViewDef = {\n      buffer: this.processBuffer(dataView.buffer),\n      byteOffset: this.byteOffset,\n      byteLength\n    };\n    if (target !== void 0) bufferViewDef.target = target;\n    if (target === WEBGL_CONSTANTS.ARRAY_BUFFER) {\n      bufferViewDef.byteStride = byteStride;\n    }\n    this.byteOffset += byteLength;\n    json.bufferViews.push(bufferViewDef);\n    const output = {\n      id: json.bufferViews.length - 1,\n      byteLength: 0\n    };\n    return output;\n  }\n  /**\n   * Process and generate a BufferView from an image Blob.\n   * @param {Blob} blob\n   * @return {Promise<Integer>}\n   */\n  processBufferViewImage(blob) {\n    const writer = this;\n    const json = writer.json;\n    if (!json.bufferViews) json.bufferViews = [];\n    return blob.arrayBuffer().then(result => {\n      const buffer = getPaddedArrayBuffer(result);\n      const bufferViewDef = {\n        buffer: writer.processBuffer(buffer),\n        byteOffset: writer.byteOffset,\n        byteLength: buffer.byteLength\n      };\n      writer.byteOffset += buffer.byteLength;\n      return json.bufferViews.push(bufferViewDef) - 1;\n    });\n  }\n  /**\n   * Process attribute to generate an accessor\n   * @param  {BufferAttribute} attribute Attribute to process\n   * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range\n   * @param  {Integer} start (Optional)\n   * @param  {Integer} count (Optional)\n   * @return {Integer|null} Index of the processed accessor on the \"accessors\" array\n   */\n  processAccessor(attribute, geometry, start, count) {\n    const json = this.json;\n    const types = {\n      1: \"SCALAR\",\n      2: \"VEC2\",\n      3: \"VEC3\",\n      4: \"VEC4\",\n      9: \"MAT3\",\n      16: \"MAT4\"\n    };\n    let componentType;\n    if (attribute.array.constructor === Float32Array) {\n      componentType = WEBGL_CONSTANTS.FLOAT;\n    } else if (attribute.array.constructor === Int32Array) {\n      componentType = WEBGL_CONSTANTS.INT;\n    } else if (attribute.array.constructor === Uint32Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_INT;\n    } else if (attribute.array.constructor === Int16Array) {\n      componentType = WEBGL_CONSTANTS.SHORT;\n    } else if (attribute.array.constructor === Uint16Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;\n    } else if (attribute.array.constructor === Int8Array) {\n      componentType = WEBGL_CONSTANTS.BYTE;\n    } else if (attribute.array.constructor === Uint8Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;\n    } else {\n      throw new Error(\"THREE.GLTFExporter: Unsupported bufferAttribute component type: \" + attribute.array.constructor.name);\n    }\n    if (start === void 0) start = 0;\n    if (count === void 0) count = attribute.count;\n    if (count === 0) return null;\n    const minMax = getMinMax(attribute, start, count);\n    let bufferViewTarget;\n    if (geometry !== void 0) {\n      bufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;\n    }\n    const bufferView = this.processBufferView(attribute, componentType, start, count, bufferViewTarget);\n    const accessorDef = {\n      bufferView: bufferView.id,\n      byteOffset: bufferView.byteOffset,\n      componentType,\n      count,\n      max: minMax.max,\n      min: minMax.min,\n      type: types[attribute.itemSize]\n    };\n    if (attribute.normalized === true) accessorDef.normalized = true;\n    if (!json.accessors) json.accessors = [];\n    return json.accessors.push(accessorDef) - 1;\n  }\n  /**\n   * Process image\n   * @param  {Image} image to process\n   * @param  {Integer} format of the image (RGBAFormat)\n   * @param  {Boolean} flipY before writing out the image\n   * @param  {String} mimeType export format\n   * @return {Integer}     Index of the processed texture in the \"images\" array\n   */\n  processImage(image, format, flipY, mimeType = \"image/png\") {\n    if (image !== null) {\n      const writer = this;\n      const cache = writer.cache;\n      const json = writer.json;\n      const options = writer.options;\n      const pending = writer.pending;\n      if (!cache.images.has(image)) cache.images.set(image, {});\n      const cachedImages = cache.images.get(image);\n      const key = mimeType + \":flipY/\" + flipY.toString();\n      if (cachedImages[key] !== void 0) return cachedImages[key];\n      if (!json.images) json.images = [];\n      const imageDef = {\n        mimeType\n      };\n      const canvas = getCanvas();\n      canvas.width = Math.min(image.width, options.maxTextureSize);\n      canvas.height = Math.min(image.height, options.maxTextureSize);\n      const ctx = canvas.getContext(\"2d\");\n      if (flipY === true) {\n        ctx.translate(0, canvas.height);\n        ctx.scale(1, -1);\n      }\n      if (image.data !== void 0) {\n        if (format !== RGBAFormat) {\n          console.error(\"GLTFExporter: Only RGBAFormat is supported.\", format);\n        }\n        if (image.width > options.maxTextureSize || image.height > options.maxTextureSize) {\n          console.warn(\"GLTFExporter: Image size is bigger than maxTextureSize\", image);\n        }\n        const data = new Uint8ClampedArray(image.height * image.width * 4);\n        for (let i = 0; i < data.length; i += 4) {\n          data[i + 0] = image.data[i + 0];\n          data[i + 1] = image.data[i + 1];\n          data[i + 2] = image.data[i + 2];\n          data[i + 3] = image.data[i + 3];\n        }\n        ctx.putImageData(new ImageData(data, image.width, image.height), 0, 0);\n      } else {\n        ctx.drawImage(image, 0, 0, canvas.width, canvas.height);\n      }\n      if (options.binary === true) {\n        pending.push(getToBlobPromise(canvas, mimeType).then(blob => writer.processBufferViewImage(blob)).then(bufferViewIndex => {\n          imageDef.bufferView = bufferViewIndex;\n        }));\n      } else {\n        if (canvas.toDataURL !== void 0) {\n          imageDef.uri = canvas.toDataURL(mimeType);\n        } else {\n          pending.push(getToBlobPromise(canvas, mimeType).then(readAsDataURL).then(uri => {\n            imageDef.uri = uri;\n          }));\n        }\n      }\n      const index = json.images.push(imageDef) - 1;\n      cachedImages[key] = index;\n      return index;\n    } else {\n      throw new Error(\"THREE.GLTFExporter: No valid image data found. Unable to process texture.\");\n    }\n  }\n  /**\n   * Process sampler\n   * @param  {Texture} map Texture to process\n   * @return {Integer}     Index of the processed texture in the \"samplers\" array\n   */\n  processSampler(map) {\n    const json = this.json;\n    if (!json.samplers) json.samplers = [];\n    const samplerDef = {\n      magFilter: THREE_TO_WEBGL[map.magFilter],\n      minFilter: THREE_TO_WEBGL[map.minFilter],\n      wrapS: THREE_TO_WEBGL[map.wrapS],\n      wrapT: THREE_TO_WEBGL[map.wrapT]\n    };\n    return json.samplers.push(samplerDef) - 1;\n  }\n  /**\n   * Process texture\n   * @param  {Texture} map Map to process\n   * @return {Integer} Index of the processed texture in the \"textures\" array\n   */\n  processTexture(map) {\n    const writer = this;\n    const options = writer.options;\n    const cache = this.cache;\n    const json = this.json;\n    if (cache.textures.has(map)) return cache.textures.get(map);\n    if (!json.textures) json.textures = [];\n    if (map instanceof CompressedTexture) {\n      map = decompress(map, options.maxTextureSize);\n    }\n    let mimeType = map.userData.mimeType;\n    if (mimeType === \"image/webp\") mimeType = \"image/png\";\n    const textureDef = {\n      sampler: this.processSampler(map),\n      source: this.processImage(map.image, map.format, map.flipY, mimeType)\n    };\n    if (map.name) textureDef.name = map.name;\n    this._invokeAll(function (ext) {\n      ext.writeTexture && ext.writeTexture(map, textureDef);\n    });\n    const index = json.textures.push(textureDef) - 1;\n    cache.textures.set(map, index);\n    return index;\n  }\n  /**\n   * Process material\n   * @param  {THREE.Material} material Material to process\n   * @return {Integer|null} Index of the processed material in the \"materials\" array\n   */\n  processMaterial(material) {\n    const cache = this.cache;\n    const json = this.json;\n    if (cache.materials.has(material)) return cache.materials.get(material);\n    if (material.isShaderMaterial) {\n      console.warn(\"GLTFExporter: THREE.ShaderMaterial not supported.\");\n      return null;\n    }\n    if (!json.materials) json.materials = [];\n    const materialDef = {\n      pbrMetallicRoughness: {}\n    };\n    if (material.isMeshStandardMaterial !== true && material.isMeshBasicMaterial !== true) {\n      console.warn(\"GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.\");\n    }\n    const color = material.color.toArray().concat([material.opacity]);\n    if (!equalArray(color, [1, 1, 1, 1])) {\n      materialDef.pbrMetallicRoughness.baseColorFactor = color;\n    }\n    if (material.isMeshStandardMaterial) {\n      materialDef.pbrMetallicRoughness.metallicFactor = material.metalness;\n      materialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;\n    } else {\n      materialDef.pbrMetallicRoughness.metallicFactor = 0.5;\n      materialDef.pbrMetallicRoughness.roughnessFactor = 0.5;\n    }\n    if (material.metalnessMap || material.roughnessMap) {\n      const metalRoughTexture = this.buildMetalRoughTexture(material.metalnessMap, material.roughnessMap);\n      const metalRoughMapDef = {\n        index: this.processTexture(metalRoughTexture),\n        channel: metalRoughTexture.channel\n      };\n      this.applyTextureTransform(metalRoughMapDef, metalRoughTexture);\n      materialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;\n    }\n    if (material.map) {\n      const baseColorMapDef = {\n        index: this.processTexture(material.map),\n        texCoord: material.map.channel\n      };\n      this.applyTextureTransform(baseColorMapDef, material.map);\n      materialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;\n    }\n    if (material.emissive) {\n      const emissive = material.emissive;\n      const maxEmissiveComponent = Math.max(emissive.r, emissive.g, emissive.b);\n      if (maxEmissiveComponent > 0) {\n        materialDef.emissiveFactor = material.emissive.toArray();\n      }\n      if (material.emissiveMap) {\n        const emissiveMapDef = {\n          index: this.processTexture(material.emissiveMap),\n          texCoord: material.emissiveMap.channel\n        };\n        this.applyTextureTransform(emissiveMapDef, material.emissiveMap);\n        materialDef.emissiveTexture = emissiveMapDef;\n      }\n    }\n    if (material.normalMap) {\n      const normalMapDef = {\n        index: this.processTexture(material.normalMap),\n        texCoord: material.normalMap.channel\n      };\n      if (material.normalScale && material.normalScale.x !== 1) {\n        normalMapDef.scale = material.normalScale.x;\n      }\n      this.applyTextureTransform(normalMapDef, material.normalMap);\n      materialDef.normalTexture = normalMapDef;\n    }\n    if (material.aoMap) {\n      const occlusionMapDef = {\n        index: this.processTexture(material.aoMap),\n        texCoord: material.aoMap.channel\n      };\n      if (material.aoMapIntensity !== 1) {\n        occlusionMapDef.strength = material.aoMapIntensity;\n      }\n      this.applyTextureTransform(occlusionMapDef, material.aoMap);\n      materialDef.occlusionTexture = occlusionMapDef;\n    }\n    if (material.transparent) {\n      materialDef.alphaMode = \"BLEND\";\n    } else {\n      if (material.alphaTest > 0) {\n        materialDef.alphaMode = \"MASK\";\n        materialDef.alphaCutoff = material.alphaTest;\n      }\n    }\n    if (material.side === DoubleSide) materialDef.doubleSided = true;\n    if (material.name !== \"\") materialDef.name = material.name;\n    this.serializeUserData(material, materialDef);\n    this._invokeAll(function (ext) {\n      ext.writeMaterial && ext.writeMaterial(material, materialDef);\n    });\n    const index = json.materials.push(materialDef) - 1;\n    cache.materials.set(material, index);\n    return index;\n  }\n  /**\n   * Process mesh\n   * @param  {THREE.Mesh} mesh Mesh to process\n   * @return {Integer|null} Index of the processed mesh in the \"meshes\" array\n   */\n  processMesh(mesh) {\n    const cache = this.cache;\n    const json = this.json;\n    const meshCacheKeyParts = [mesh.geometry.uuid];\n    if (Array.isArray(mesh.material)) {\n      for (let i = 0, l = mesh.material.length; i < l; i++) {\n        meshCacheKeyParts.push(mesh.material[i].uuid);\n      }\n    } else {\n      meshCacheKeyParts.push(mesh.material.uuid);\n    }\n    const meshCacheKey = meshCacheKeyParts.join(\":\");\n    if (cache.meshes.has(meshCacheKey)) return cache.meshes.get(meshCacheKey);\n    const geometry = mesh.geometry;\n    let mode;\n    if (mesh.isLineSegments) {\n      mode = WEBGL_CONSTANTS.LINES;\n    } else if (mesh.isLineLoop) {\n      mode = WEBGL_CONSTANTS.LINE_LOOP;\n    } else if (mesh.isLine) {\n      mode = WEBGL_CONSTANTS.LINE_STRIP;\n    } else if (mesh.isPoints) {\n      mode = WEBGL_CONSTANTS.POINTS;\n    } else {\n      mode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;\n    }\n    const meshDef = {};\n    const attributes = {};\n    const primitives = [];\n    const targets = [];\n    const nameConversion = {\n      ...(version >= 152 ? {\n        uv: \"TEXCOORD_0\",\n        uv1: \"TEXCOORD_1\",\n        uv2: \"TEXCOORD_2\",\n        uv3: \"TEXCOORD_3\"\n      } : {\n        uv: \"TEXCOORD_0\",\n        uv2: \"TEXCOORD_1\"\n      }),\n      color: \"COLOR_0\",\n      skinWeight: \"WEIGHTS_0\",\n      skinIndex: \"JOINTS_0\"\n    };\n    const originalNormal = geometry.getAttribute(\"normal\");\n    if (originalNormal !== void 0 && !this.isNormalizedNormalAttribute(originalNormal)) {\n      console.warn(\"THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.\");\n      geometry.setAttribute(\"normal\", this.createNormalizedNormalAttribute(originalNormal));\n    }\n    let modifiedAttribute = null;\n    for (let attributeName in geometry.attributes) {\n      if (attributeName.slice(0, 5) === \"morph\") continue;\n      const attribute = geometry.attributes[attributeName];\n      attributeName = nameConversion[attributeName] || attributeName.toUpperCase();\n      const validVertexAttributes = /^(POSITION|NORMAL|TANGENT|TEXCOORD_\\d+|COLOR_\\d+|JOINTS_\\d+|WEIGHTS_\\d+)$/;\n      if (!validVertexAttributes.test(attributeName)) attributeName = \"_\" + attributeName;\n      if (cache.attributes.has(this.getUID(attribute))) {\n        attributes[attributeName] = cache.attributes.get(this.getUID(attribute));\n        continue;\n      }\n      modifiedAttribute = null;\n      const array = attribute.array;\n      if (attributeName === \"JOINTS_0\" && !(array instanceof Uint16Array) && !(array instanceof Uint8Array)) {\n        console.warn('GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.');\n        modifiedAttribute = new BufferAttribute(new Uint16Array(array), attribute.itemSize, attribute.normalized);\n      }\n      const accessor = this.processAccessor(modifiedAttribute || attribute, geometry);\n      if (accessor !== null) {\n        if (!attributeName.startsWith(\"_\")) {\n          this.detectMeshQuantization(attributeName, attribute);\n        }\n        attributes[attributeName] = accessor;\n        cache.attributes.set(this.getUID(attribute), accessor);\n      }\n    }\n    if (originalNormal !== void 0) geometry.setAttribute(\"normal\", originalNormal);\n    if (Object.keys(attributes).length === 0) return null;\n    if (mesh.morphTargetInfluences !== void 0 && mesh.morphTargetInfluences.length > 0) {\n      const weights = [];\n      const targetNames = [];\n      const reverseDictionary = {};\n      if (mesh.morphTargetDictionary !== void 0) {\n        for (const key in mesh.morphTargetDictionary) {\n          reverseDictionary[mesh.morphTargetDictionary[key]] = key;\n        }\n      }\n      for (let i = 0; i < mesh.morphTargetInfluences.length; ++i) {\n        const target = {};\n        let warned = false;\n        for (const attributeName in geometry.morphAttributes) {\n          if (attributeName !== \"position\" && attributeName !== \"normal\") {\n            if (!warned) {\n              console.warn(\"GLTFExporter: Only POSITION and NORMAL morph are supported.\");\n              warned = true;\n            }\n            continue;\n          }\n          const attribute = geometry.morphAttributes[attributeName][i];\n          const gltfAttributeName = attributeName.toUpperCase();\n          const baseAttribute = geometry.attributes[attributeName];\n          if (cache.attributes.has(this.getUID(attribute, true))) {\n            target[gltfAttributeName] = cache.attributes.get(this.getUID(attribute, true));\n            continue;\n          }\n          const relativeAttribute = attribute.clone();\n          if (!geometry.morphTargetsRelative) {\n            for (let j = 0, jl = attribute.count; j < jl; j++) {\n              for (let a = 0; a < attribute.itemSize; a++) {\n                if (a === 0) relativeAttribute.setX(j, attribute.getX(j) - baseAttribute.getX(j));\n                if (a === 1) relativeAttribute.setY(j, attribute.getY(j) - baseAttribute.getY(j));\n                if (a === 2) relativeAttribute.setZ(j, attribute.getZ(j) - baseAttribute.getZ(j));\n                if (a === 3) relativeAttribute.setW(j, attribute.getW(j) - baseAttribute.getW(j));\n              }\n            }\n          }\n          target[gltfAttributeName] = this.processAccessor(relativeAttribute, geometry);\n          cache.attributes.set(this.getUID(baseAttribute, true), target[gltfAttributeName]);\n        }\n        targets.push(target);\n        weights.push(mesh.morphTargetInfluences[i]);\n        if (mesh.morphTargetDictionary !== void 0) targetNames.push(reverseDictionary[i]);\n      }\n      meshDef.weights = weights;\n      if (targetNames.length > 0) {\n        meshDef.extras = {};\n        meshDef.extras.targetNames = targetNames;\n      }\n    }\n    const isMultiMaterial = Array.isArray(mesh.material);\n    if (isMultiMaterial && geometry.groups.length === 0) return null;\n    const materials = isMultiMaterial ? mesh.material : [mesh.material];\n    const groups = isMultiMaterial ? geometry.groups : [{\n      materialIndex: 0,\n      start: void 0,\n      count: void 0\n    }];\n    for (let i = 0, il = groups.length; i < il; i++) {\n      const primitive = {\n        mode,\n        attributes\n      };\n      this.serializeUserData(geometry, primitive);\n      if (targets.length > 0) primitive.targets = targets;\n      if (geometry.index !== null) {\n        let cacheKey = this.getUID(geometry.index);\n        if (groups[i].start !== void 0 || groups[i].count !== void 0) {\n          cacheKey += \":\" + groups[i].start + \":\" + groups[i].count;\n        }\n        if (cache.attributes.has(cacheKey)) {\n          primitive.indices = cache.attributes.get(cacheKey);\n        } else {\n          primitive.indices = this.processAccessor(geometry.index, geometry, groups[i].start, groups[i].count);\n          cache.attributes.set(cacheKey, primitive.indices);\n        }\n        if (primitive.indices === null) delete primitive.indices;\n      }\n      const material = this.processMaterial(materials[groups[i].materialIndex]);\n      if (material !== null) primitive.material = material;\n      primitives.push(primitive);\n    }\n    meshDef.primitives = primitives;\n    if (!json.meshes) json.meshes = [];\n    this._invokeAll(function (ext) {\n      ext.writeMesh && ext.writeMesh(mesh, meshDef);\n    });\n    const index = json.meshes.push(meshDef) - 1;\n    cache.meshes.set(meshCacheKey, index);\n    return index;\n  }\n  /**\n   * If a vertex attribute with a\n   * [non-standard data type](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#meshes-overview)\n   * is used, it is checked whether it is a valid data type according to the\n   * [KHR_mesh_quantization](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md)\n   * extension.\n   * In this case the extension is automatically added to the list of used extensions.\n   *\n   * @param {string} attributeName\n   * @param {THREE.BufferAttribute} attribute\n   */\n  detectMeshQuantization(attributeName, attribute) {\n    if (this.extensionsUsed[KHR_MESH_QUANTIZATION]) return;\n    let attrType = void 0;\n    switch (attribute.array.constructor) {\n      case Int8Array:\n        attrType = \"byte\";\n        break;\n      case Uint8Array:\n        attrType = \"unsigned byte\";\n        break;\n      case Int16Array:\n        attrType = \"short\";\n        break;\n      case Uint16Array:\n        attrType = \"unsigned short\";\n        break;\n      default:\n        return;\n    }\n    if (attribute.normalized) attrType += \" normalized\";\n    const attrNamePrefix = attributeName.split(\"_\", 1)[0];\n    if (KHR_mesh_quantization_ExtraAttrTypes[attrNamePrefix] && KHR_mesh_quantization_ExtraAttrTypes[attrNamePrefix].includes(attrType)) {\n      this.extensionsUsed[KHR_MESH_QUANTIZATION] = true;\n      this.extensionsRequired[KHR_MESH_QUANTIZATION] = true;\n    }\n  }\n  /**\n   * Process camera\n   * @param  {THREE.Camera} camera Camera to process\n   * @return {Integer}      Index of the processed mesh in the \"camera\" array\n   */\n  processCamera(camera) {\n    const json = this.json;\n    if (!json.cameras) json.cameras = [];\n    const isOrtho = camera.isOrthographicCamera;\n    const cameraDef = {\n      type: isOrtho ? \"orthographic\" : \"perspective\"\n    };\n    if (isOrtho) {\n      cameraDef.orthographic = {\n        xmag: camera.right * 2,\n        ymag: camera.top * 2,\n        zfar: camera.far <= 0 ? 1e-3 : camera.far,\n        znear: camera.near < 0 ? 0 : camera.near\n      };\n    } else {\n      cameraDef.perspective = {\n        aspectRatio: camera.aspect,\n        yfov: MathUtils.degToRad(camera.fov),\n        zfar: camera.far <= 0 ? 1e-3 : camera.far,\n        znear: camera.near < 0 ? 0 : camera.near\n      };\n    }\n    if (camera.name !== \"\") cameraDef.name = camera.type;\n    return json.cameras.push(cameraDef) - 1;\n  }\n  /**\n   * Creates glTF animation entry from AnimationClip object.\n   *\n   * Status:\n   * - Only properties listed in PATH_PROPERTIES may be animated.\n   *\n   * @param {THREE.AnimationClip} clip\n   * @param {THREE.Object3D} root\n   * @return {number|null}\n   */\n  processAnimation(clip, root) {\n    const json = this.json;\n    const nodeMap = this.nodeMap;\n    if (!json.animations) json.animations = [];\n    clip = GLTFExporter.Utils.mergeMorphTargetTracks(clip.clone(), root);\n    const tracks = clip.tracks;\n    const channels = [];\n    const samplers = [];\n    for (let i = 0; i < tracks.length; ++i) {\n      const track = tracks[i];\n      const trackBinding = PropertyBinding.parseTrackName(track.name);\n      let trackNode = PropertyBinding.findNode(root, trackBinding.nodeName);\n      const trackProperty = PATH_PROPERTIES[trackBinding.propertyName];\n      if (trackBinding.objectName === \"bones\") {\n        if (trackNode.isSkinnedMesh === true) {\n          trackNode = trackNode.skeleton.getBoneByName(trackBinding.objectIndex);\n        } else {\n          trackNode = void 0;\n        }\n      }\n      if (!trackNode || !trackProperty) {\n        console.warn('THREE.GLTFExporter: Could not export animation track \"%s\".', track.name);\n        return null;\n      }\n      const inputItemSize = 1;\n      let outputItemSize = track.values.length / track.times.length;\n      if (trackProperty === PATH_PROPERTIES.morphTargetInfluences) {\n        outputItemSize /= trackNode.morphTargetInfluences.length;\n      }\n      let interpolation;\n      if (track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true) {\n        interpolation = \"CUBICSPLINE\";\n        outputItemSize /= 3;\n      } else if (track.getInterpolation() === InterpolateDiscrete) {\n        interpolation = \"STEP\";\n      } else {\n        interpolation = \"LINEAR\";\n      }\n      samplers.push({\n        input: this.processAccessor(new BufferAttribute(track.times, inputItemSize)),\n        output: this.processAccessor(new BufferAttribute(track.values, outputItemSize)),\n        interpolation\n      });\n      channels.push({\n        sampler: samplers.length - 1,\n        target: {\n          node: nodeMap.get(trackNode),\n          path: trackProperty\n        }\n      });\n    }\n    json.animations.push({\n      name: clip.name || \"clip_\" + json.animations.length,\n      samplers,\n      channels\n    });\n    return json.animations.length - 1;\n  }\n  /**\n   * @param {THREE.Object3D} object\n   * @return {number|null}\n   */\n  processSkin(object) {\n    const json = this.json;\n    const nodeMap = this.nodeMap;\n    const node = json.nodes[nodeMap.get(object)];\n    const skeleton = object.skeleton;\n    if (skeleton === void 0) return null;\n    const rootJoint = object.skeleton.bones[0];\n    if (rootJoint === void 0) return null;\n    const joints = [];\n    const inverseBindMatrices = new Float32Array(skeleton.bones.length * 16);\n    const temporaryBoneInverse = new Matrix4();\n    for (let i = 0; i < skeleton.bones.length; ++i) {\n      joints.push(nodeMap.get(skeleton.bones[i]));\n      temporaryBoneInverse.copy(skeleton.boneInverses[i]);\n      temporaryBoneInverse.multiply(object.bindMatrix).toArray(inverseBindMatrices, i * 16);\n    }\n    if (json.skins === void 0) json.skins = [];\n    json.skins.push({\n      inverseBindMatrices: this.processAccessor(new BufferAttribute(inverseBindMatrices, 16)),\n      joints,\n      skeleton: nodeMap.get(rootJoint)\n    });\n    const skinIndex = node.skin = json.skins.length - 1;\n    return skinIndex;\n  }\n  /**\n   * Process Object3D node\n   * @param  {THREE.Object3D} node Object3D to processNode\n   * @return {Integer} Index of the node in the nodes list\n   */\n  processNode(object) {\n    const json = this.json;\n    const options = this.options;\n    const nodeMap = this.nodeMap;\n    if (!json.nodes) json.nodes = [];\n    const nodeDef = {};\n    if (options.trs) {\n      const rotation = object.quaternion.toArray();\n      const position = object.position.toArray();\n      const scale = object.scale.toArray();\n      if (!equalArray(rotation, [0, 0, 0, 1])) {\n        nodeDef.rotation = rotation;\n      }\n      if (!equalArray(position, [0, 0, 0])) {\n        nodeDef.translation = position;\n      }\n      if (!equalArray(scale, [1, 1, 1])) {\n        nodeDef.scale = scale;\n      }\n    } else {\n      if (object.matrixAutoUpdate) {\n        object.updateMatrix();\n      }\n      if (isIdentityMatrix(object.matrix) === false) {\n        nodeDef.matrix = object.matrix.elements;\n      }\n    }\n    if (object.name !== \"\") nodeDef.name = String(object.name);\n    this.serializeUserData(object, nodeDef);\n    if (object.isMesh || object.isLine || object.isPoints) {\n      const meshIndex = this.processMesh(object);\n      if (meshIndex !== null) nodeDef.mesh = meshIndex;\n    } else if (object.isCamera) {\n      nodeDef.camera = this.processCamera(object);\n    }\n    if (object.isSkinnedMesh) this.skins.push(object);\n    if (object.children.length > 0) {\n      const children = [];\n      for (let i = 0, l = object.children.length; i < l; i++) {\n        const child = object.children[i];\n        if (child.visible || options.onlyVisible === false) {\n          const nodeIndex2 = this.processNode(child);\n          if (nodeIndex2 !== null) children.push(nodeIndex2);\n        }\n      }\n      if (children.length > 0) nodeDef.children = children;\n    }\n    this._invokeAll(function (ext) {\n      ext.writeNode && ext.writeNode(object, nodeDef);\n    });\n    const nodeIndex = json.nodes.push(nodeDef) - 1;\n    nodeMap.set(object, nodeIndex);\n    return nodeIndex;\n  }\n  /**\n   * Process Scene\n   * @param  {Scene} node Scene to process\n   */\n  processScene(scene) {\n    const json = this.json;\n    const options = this.options;\n    if (!json.scenes) {\n      json.scenes = [];\n      json.scene = 0;\n    }\n    const sceneDef = {};\n    if (scene.name !== \"\") sceneDef.name = scene.name;\n    json.scenes.push(sceneDef);\n    const nodes = [];\n    for (let i = 0, l = scene.children.length; i < l; i++) {\n      const child = scene.children[i];\n      if (child.visible || options.onlyVisible === false) {\n        const nodeIndex = this.processNode(child);\n        if (nodeIndex !== null) nodes.push(nodeIndex);\n      }\n    }\n    if (nodes.length > 0) sceneDef.nodes = nodes;\n    this.serializeUserData(scene, sceneDef);\n  }\n  /**\n   * Creates a Scene to hold a list of objects and parse it\n   * @param  {Array} objects List of objects to process\n   */\n  processObjects(objects) {\n    const scene = new Scene();\n    scene.name = \"AuxScene\";\n    for (let i = 0; i < objects.length; i++) {\n      scene.children.push(objects[i]);\n    }\n    this.processScene(scene);\n  }\n  /**\n   * @param {THREE.Object3D|Array<THREE.Object3D>} input\n   */\n  processInput(input) {\n    const options = this.options;\n    input = input instanceof Array ? input : [input];\n    this._invokeAll(function (ext) {\n      ext.beforeParse && ext.beforeParse(input);\n    });\n    const objectsWithoutScene = [];\n    for (let i = 0; i < input.length; i++) {\n      if (input[i] instanceof Scene) {\n        this.processScene(input[i]);\n      } else {\n        objectsWithoutScene.push(input[i]);\n      }\n    }\n    if (objectsWithoutScene.length > 0) this.processObjects(objectsWithoutScene);\n    for (let i = 0; i < this.skins.length; ++i) {\n      this.processSkin(this.skins[i]);\n    }\n    for (let i = 0; i < options.animations.length; ++i) {\n      this.processAnimation(options.animations[i], input[0]);\n    }\n    this._invokeAll(function (ext) {\n      ext.afterParse && ext.afterParse(input);\n    });\n  }\n  _invokeAll(func) {\n    for (let i = 0, il = this.plugins.length; i < il; i++) {\n      func(this.plugins[i]);\n    }\n  }\n}\nclass GLTFLightExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_lights_punctual\";\n  }\n  writeNode(light, nodeDef) {\n    if (!light.isLight) return;\n    if (!light.isDirectionalLight && !light.isPointLight && !light.isSpotLight) {\n      console.warn(\"THREE.GLTFExporter: Only directional, point, and spot lights are supported.\", light);\n      return;\n    }\n    const writer = this.writer;\n    const json = writer.json;\n    const extensionsUsed = writer.extensionsUsed;\n    const lightDef = {};\n    if (light.name) lightDef.name = light.name;\n    lightDef.color = light.color.toArray();\n    lightDef.intensity = light.intensity;\n    if (light.isDirectionalLight) {\n      lightDef.type = \"directional\";\n    } else if (light.isPointLight) {\n      lightDef.type = \"point\";\n      if (light.distance > 0) lightDef.range = light.distance;\n    } else if (light.isSpotLight) {\n      lightDef.type = \"spot\";\n      if (light.distance > 0) lightDef.range = light.distance;\n      lightDef.spot = {};\n      lightDef.spot.innerConeAngle = (light.penumbra - 1) * light.angle * -1;\n      lightDef.spot.outerConeAngle = light.angle;\n    }\n    if (light.decay !== void 0 && light.decay !== 2) {\n      console.warn(\"THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2.\");\n    }\n    if (light.target && (light.target.parent !== light || light.target.position.x !== 0 || light.target.position.y !== 0 || light.target.position.z !== -1)) {\n      console.warn(\"THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1.\");\n    }\n    if (!extensionsUsed[this.name]) {\n      json.extensions = json.extensions || {};\n      json.extensions[this.name] = {\n        lights: []\n      };\n      extensionsUsed[this.name] = true;\n    }\n    const lights = json.extensions[this.name].lights;\n    lights.push(lightDef);\n    nodeDef.extensions = nodeDef.extensions || {};\n    nodeDef.extensions[this.name] = {\n      light: lights.length - 1\n    };\n  }\n}\nclass GLTFMaterialsUnlitExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_unlit\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshBasicMaterial) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = {};\n    extensionsUsed[this.name] = true;\n    materialDef.pbrMetallicRoughness.metallicFactor = 0;\n    materialDef.pbrMetallicRoughness.roughnessFactor = 0.9;\n  }\n}\nclass GLTFMaterialsClearcoatExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_clearcoat\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.clearcoat === 0) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.clearcoatFactor = material.clearcoat;\n    if (material.clearcoatMap) {\n      const clearcoatMapDef = {\n        index: writer.processTexture(material.clearcoatMap),\n        texCoord: material.clearcoatMap.channel\n      };\n      writer.applyTextureTransform(clearcoatMapDef, material.clearcoatMap);\n      extensionDef.clearcoatTexture = clearcoatMapDef;\n    }\n    extensionDef.clearcoatRoughnessFactor = material.clearcoatRoughness;\n    if (material.clearcoatRoughnessMap) {\n      const clearcoatRoughnessMapDef = {\n        index: writer.processTexture(material.clearcoatRoughnessMap),\n        texCoord: material.clearcoatRoughnessMap.channel\n      };\n      writer.applyTextureTransform(clearcoatRoughnessMapDef, material.clearcoatRoughnessMap);\n      extensionDef.clearcoatRoughnessTexture = clearcoatRoughnessMapDef;\n    }\n    if (material.clearcoatNormalMap) {\n      const clearcoatNormalMapDef = {\n        index: writer.processTexture(material.clearcoatNormalMap),\n        texCoord: material.clearcoatNormalMap.channel\n      };\n      writer.applyTextureTransform(clearcoatNormalMapDef, material.clearcoatNormalMap);\n      extensionDef.clearcoatNormalTexture = clearcoatNormalMapDef;\n    }\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsIridescenceExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_iridescence\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.iridescence === 0) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.iridescenceFactor = material.iridescence;\n    if (material.iridescenceMap) {\n      const iridescenceMapDef = {\n        index: writer.processTexture(material.iridescenceMap),\n        texCoord: material.iridescenceMap.channel\n      };\n      writer.applyTextureTransform(iridescenceMapDef, material.iridescenceMap);\n      extensionDef.iridescenceTexture = iridescenceMapDef;\n    }\n    extensionDef.iridescenceIor = material.iridescenceIOR;\n    extensionDef.iridescenceThicknessMinimum = material.iridescenceThicknessRange[0];\n    extensionDef.iridescenceThicknessMaximum = material.iridescenceThicknessRange[1];\n    if (material.iridescenceThicknessMap) {\n      const iridescenceThicknessMapDef = {\n        index: writer.processTexture(material.iridescenceThicknessMap),\n        texCoord: material.iridescenceThicknessMap.channel\n      };\n      writer.applyTextureTransform(iridescenceThicknessMapDef, material.iridescenceThicknessMap);\n      extensionDef.iridescenceThicknessTexture = iridescenceThicknessMapDef;\n    }\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsTransmissionExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_transmission\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.transmission === 0) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.transmissionFactor = material.transmission;\n    if (material.transmissionMap) {\n      const transmissionMapDef = {\n        index: writer.processTexture(material.transmissionMap),\n        texCoord: material.transmissionMap.channel\n      };\n      writer.applyTextureTransform(transmissionMapDef, material.transmissionMap);\n      extensionDef.transmissionTexture = transmissionMapDef;\n    }\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsVolumeExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_volume\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.transmission === 0) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.thicknessFactor = material.thickness;\n    if (material.thicknessMap) {\n      const thicknessMapDef = {\n        index: writer.processTexture(material.thicknessMap),\n        texCoord: material.thicknessMap.channel\n      };\n      writer.applyTextureTransform(thicknessMapDef, material.thicknessMap);\n      extensionDef.thicknessTexture = thicknessMapDef;\n    }\n    extensionDef.attenuationDistance = material.attenuationDistance;\n    extensionDef.attenuationColor = material.attenuationColor.toArray();\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsIorExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_ior\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.ior === 1.5) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.ior = material.ior;\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsSpecularExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_specular\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.specularIntensity === 1 && material.specularColor.equals(DEFAULT_SPECULAR_COLOR) && !material.specularIntensityMap && !material.specularColorTexture) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    if (material.specularIntensityMap) {\n      const specularIntensityMapDef = {\n        index: writer.processTexture(material.specularIntensityMap),\n        texCoord: material.specularIntensityMap.channel\n      };\n      writer.applyTextureTransform(specularIntensityMapDef, material.specularIntensityMap);\n      extensionDef.specularTexture = specularIntensityMapDef;\n    }\n    if (material.specularColorMap) {\n      const specularColorMapDef = {\n        index: writer.processTexture(material.specularColorMap),\n        texCoord: material.specularColorMap.channel\n      };\n      writer.applyTextureTransform(specularColorMapDef, material.specularColorMap);\n      extensionDef.specularColorTexture = specularColorMapDef;\n    }\n    extensionDef.specularFactor = material.specularIntensity;\n    extensionDef.specularColorFactor = material.specularColor.toArray();\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsSheenExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_sheen\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.sheen == 0) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    if (material.sheenRoughnessMap) {\n      const sheenRoughnessMapDef = {\n        index: writer.processTexture(material.sheenRoughnessMap),\n        texCoord: material.sheenRoughnessMap.channel\n      };\n      writer.applyTextureTransform(sheenRoughnessMapDef, material.sheenRoughnessMap);\n      extensionDef.sheenRoughnessTexture = sheenRoughnessMapDef;\n    }\n    if (material.sheenColorMap) {\n      const sheenColorMapDef = {\n        index: writer.processTexture(material.sheenColorMap),\n        texCoord: material.sheenColorMap.channel\n      };\n      writer.applyTextureTransform(sheenColorMapDef, material.sheenColorMap);\n      extensionDef.sheenColorTexture = sheenColorMapDef;\n    }\n    extensionDef.sheenRoughnessFactor = material.sheenRoughness;\n    extensionDef.sheenColorFactor = material.sheenColor.toArray();\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsAnisotropyExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_anisotropy\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.anisotropy == 0) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    if (material.anisotropyMap) {\n      const anisotropyMapDef = {\n        index: writer.processTexture(material.anisotropyMap)\n      };\n      writer.applyTextureTransform(anisotropyMapDef, material.anisotropyMap);\n      extensionDef.anisotropyTexture = anisotropyMapDef;\n    }\n    extensionDef.anisotropyStrength = material.anisotropy;\n    extensionDef.anisotropyRotation = material.anisotropyRotation;\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsEmissiveStrengthExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_emissive_strength\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshStandardMaterial || material.emissiveIntensity === 1) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.emissiveStrength = material.emissiveIntensity;\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nexport { GLTFExporter };","map":{"version":3,"names":["__defProp","Object","defineProperty","__defNormalProp","obj","key","value","enumerable","configurable","writable","__publicField","PropertyBinding","InterpolateLinear","Color","Vector3","CompressedTexture","Texture","MathUtils","RGBAFormat","DoubleSide","BufferAttribute","InterpolateDiscrete","Matrix4","Scene","PlaneGeometry","ShaderMaterial","Uniform","Mesh","PerspectiveCamera","WebGLRenderer","NearestFilter","NearestMipmapNearestFilter","NearestMipmapLinearFilter","LinearFilter","LinearMipmapNearestFilter","LinearMipmapLinearFilter","ClampToEdgeWrapping","RepeatWrapping","MirroredRepeatWrapping","version","readAsDataURL","blob","buffer","arrayBuffer","data","btoa","String","fromCharCode","Uint8Array","type","_renderer","fullscreenQuadGeometry","fullscreenQuadMaterial","fullscreenQuad","decompress","texture","maxTextureSize","Infinity","renderer","uniforms","blitTexture","vertexShader","fragmentShader","defines","IS_SRGB","colorSpace","encoding","needsUpdate","frustrumCulled","_camera","_scene","add","antialias","setSize","Math","min","image","width","height","clear","render","readableTexture","domElement","minFilter","magFilter","wrapS","wrapT","name","dispose","KHR_mesh_quantization_ExtraAttrTypes","POSITION","NORMAL","TANGENT","TEXCOORD","GLTFExporter","GLTFExporter2","constructor","pluginCallbacks","register","writer","GLTFLightExtension","GLTFMaterialsUnlitExtension","GLTFMaterialsTransmissionExtension","GLTFMaterialsVolumeExtension","GLTFMaterialsIorExtension","GLTFMaterialsSpecularExtension","GLTFMaterialsClearcoatExtension","GLTFMaterialsIridescenceExtension","GLTFMaterialsSheenExtension","GLTFMaterialsAnisotropyExtension","GLTFMaterialsEmissiveStrengthExtension","callback","indexOf","push","unregister","splice","parse","input","onDone","onError","options","GLTFWriter","plugins","i","il","length","setPlugins","write","catch","parseAsync","scope","Promise","resolve","reject","insertKeyframe","track","time","tolerance","valueSize","getValueSize","times","TimeBufferType","values","ValueBufferType","interpolant","createInterpolant","index","abs","set","evaluate","slice","mergeMorphTargetTracks","clip","root","tracks","mergedTracks","sourceTracks","sourceTrack","sourceTrackBinding","parseTrackName","sourceTrackNode","findNode","nodeName","propertyName","propertyIndex","InterpolantFactoryMethodDiscrete","InterpolantFactoryMethodLinear","isInterpolantFactoryMethodGLTFCubicSpline","Error","console","warn","clone","setInterpolation","targetCount","morphTargetInfluences","targetIndex","morphTargetDictionary","mergedTrack","uuid","j","sourceInterpolant","keyframeIndex","WEBGL_CONSTANTS","POINTS","LINES","LINE_LOOP","LINE_STRIP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","BYTE","UNSIGNED_BYTE","SHORT","UNSIGNED_SHORT","INT","UNSIGNED_INT","FLOAT","ARRAY_BUFFER","ELEMENT_ARRAY_BUFFER","NEAREST","LINEAR","NEAREST_MIPMAP_NEAREST","LINEAR_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LINEAR_MIPMAP_LINEAR","CLAMP_TO_EDGE","MIRRORED_REPEAT","REPEAT","KHR_MESH_QUANTIZATION","THREE_TO_WEBGL","PATH_PROPERTIES","scale","position","quaternion","DEFAULT_SPECULAR_COLOR","GLB_HEADER_BYTES","GLB_HEADER_MAGIC","GLB_VERSION","GLB_CHUNK_PREFIX_BYTES","GLB_CHUNK_TYPE_JSON","GLB_CHUNK_TYPE_BIN","equalArray","array1","array2","every","element","stringToArrayBuffer","text","TextEncoder","encode","isIdentityMatrix","matrix","elements","getMinMax","attribute","start","count","output","Array","itemSize","fill","Number","POSITIVE_INFINITY","max","NEGATIVE_INFINITY","a","array","getX","getY","getZ","getW","normalized","normalize","getPaddedBufferSize","bufferSize","ceil","getPaddedArrayBuffer","paddingByte","paddedLength","byteLength","getCanvas","document","OffscreenCanvas","createElement","getToBlobPromise","canvas","mimeType","toBlob","quality","convertToBlob","pending","buffers","byteOffset","nodeMap","Map","skins","extensionsUsed","extensionsRequired","uids","uid","json","asset","generator","cache","meshes","attributes","attributesNormalized","materials","textures","images","assign","binary","trs","onlyVisible","animations","includeCustomExtensions","processInput","all","Blob","extensionsUsedList","keys","extensionsRequiredList","size","then","result","binaryChunk","binaryChunkPrefix","DataView","ArrayBuffer","setUint32","jsonChunk","JSON","stringify","jsonChunkPrefix","header","headerView","totalByteLength","glbBlob","uri","serializeUserData","object","objectDef","userData","gltfExtensions","extensions","extensionName","extras","error","message","getUID","isRelativeCopy","has","uids2","get","isNormalizedNormalAttribute","normal","v","fromBufferAttribute","createNormalizedNormalAttribute","x","y","z","setX","setXYZ","applyTextureTransform","mapDef","didTransform","transformDef","offset","toArray","rotation","repeat","buildMetalRoughTexture","metalnessMap","roughnessMap","getEncodingConversion","map","SRGBToLinear","c","pow","LinearToLinear","metalness","roughness","context","getContext","fillStyle","fillRect","composite","getImageData","drawImage","convert","putImageData","reference","source","channel","processBuffer","processBufferView","componentType","target","bufferViews","componentSize","byteStride","dataView","setFloat32","setInt32","setInt16","setUint16","setInt8","setUint8","bufferViewDef","id","processBufferViewImage","processAccessor","geometry","types","Float32Array","Int32Array","Uint32Array","Int16Array","Uint16Array","Int8Array","minMax","bufferViewTarget","bufferView","accessorDef","accessors","processImage","format","flipY","cachedImages","toString","imageDef","ctx","translate","Uint8ClampedArray","ImageData","bufferViewIndex","toDataURL","processSampler","samplers","samplerDef","processTexture","textureDef","sampler","_invokeAll","ext","writeTexture","processMaterial","material","isShaderMaterial","materialDef","pbrMetallicRoughness","isMeshStandardMaterial","isMeshBasicMaterial","color","concat","opacity","baseColorFactor","metallicFactor","roughnessFactor","metalRoughTexture","metalRoughMapDef","metallicRoughnessTexture","baseColorMapDef","texCoord","baseColorTexture","emissive","maxEmissiveComponent","r","g","b","emissiveFactor","emissiveMap","emissiveMapDef","emissiveTexture","normalMap","normalMapDef","normalScale","normalTexture","aoMap","occlusionMapDef","aoMapIntensity","strength","occlusionTexture","transparent","alphaMode","alphaTest","alphaCutoff","side","doubleSided","writeMaterial","processMesh","mesh","meshCacheKeyParts","isArray","l","meshCacheKey","join","mode","isLineSegments","isLineLoop","isLine","isPoints","wireframe","meshDef","primitives","targets","nameConversion","uv","uv1","uv2","uv3","skinWeight","skinIndex","originalNormal","getAttribute","setAttribute","modifiedAttribute","attributeName","toUpperCase","validVertexAttributes","test","accessor","startsWith","detectMeshQuantization","weights","targetNames","reverseDictionary","warned","morphAttributes","gltfAttributeName","baseAttribute","relativeAttribute","morphTargetsRelative","jl","setY","setZ","setW","isMultiMaterial","groups","materialIndex","primitive","cacheKey","indices","writeMesh","attrType","attrNamePrefix","split","includes","processCamera","camera","cameras","isOrtho","isOrthographicCamera","cameraDef","orthographic","xmag","right","ymag","top","zfar","far","znear","near","perspective","aspectRatio","aspect","yfov","degToRad","fov","processAnimation","Utils","channels","trackBinding","trackNode","trackProperty","objectName","isSkinnedMesh","skeleton","getBoneByName","objectIndex","inputItemSize","outputItemSize","interpolation","getInterpolation","node","path","processSkin","nodes","rootJoint","bones","joints","inverseBindMatrices","temporaryBoneInverse","copy","boneInverses","multiply","bindMatrix","skin","processNode","nodeDef","translation","matrixAutoUpdate","updateMatrix","isMesh","meshIndex","isCamera","children","child","visible","nodeIndex2","writeNode","nodeIndex","processScene","scene","scenes","sceneDef","processObjects","objects","beforeParse","objectsWithoutScene","afterParse","func","light","isLight","isDirectionalLight","isPointLight","isSpotLight","lightDef","intensity","distance","range","spot","innerConeAngle","penumbra","angle","outerConeAngle","decay","parent","lights","isMeshPhysicalMaterial","clearcoat","extensionDef","clearcoatFactor","clearcoatMap","clearcoatMapDef","clearcoatTexture","clearcoatRoughnessFactor","clearcoatRoughness","clearcoatRoughnessMap","clearcoatRoughnessMapDef","clearcoatRoughnessTexture","clearcoatNormalMap","clearcoatNormalMapDef","clearcoatNormalTexture","iridescence","iridescenceFactor","iridescenceMap","iridescenceMapDef","iridescenceTexture","iridescenceIor","iridescenceIOR","iridescenceThicknessMinimum","iridescenceThicknessRange","iridescenceThicknessMaximum","iridescenceThicknessMap","iridescenceThicknessMapDef","iridescenceThicknessTexture","transmission","transmissionFactor","transmissionMap","transmissionMapDef","transmissionTexture","thicknessFactor","thickness","thicknessMap","thicknessMapDef","thicknessTexture","attenuationDistance","attenuationColor","ior","specularIntensity","specularColor","equals","specularIntensityMap","specularColorTexture","specularIntensityMapDef","specularTexture","specularColorMap","specularColorMapDef","specularFactor","specularColorFactor","sheen","sheenRoughnessMap","sheenRoughnessMapDef","sheenRoughnessTexture","sheenColorMap","sheenColorMapDef","sheenColorTexture","sheenRoughnessFactor","sheenRoughness","sheenColorFactor","sheenColor","anisotropy","anisotropyMap","anisotropyMapDef","anisotropyTexture","anisotropyStrength","anisotropyRotation","emissiveIntensity","emissiveStrength"],"sources":["C:/Users/srk/Downloads/arq_phantom_clone/node_modules/three-stdlib/exporters/GLTFExporter.js"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { PropertyBinding, InterpolateLinear, Color, Vector3, CompressedTexture, Texture, MathUtils, RGBAFormat, DoubleSide, BufferAttribute, InterpolateDiscrete, Matrix4, Scene, PlaneGeometry, ShaderMaterial, Uniform, Mesh, PerspectiveCamera, WebGLRenderer, NearestFilter, NearestMipmapNearestFilter, NearestMipmapLinearFilter, LinearFilter, LinearMipmapNearestFilter, LinearMipmapLinearFilter, ClampToEdgeWrapping, RepeatWrapping, MirroredRepeatWrapping } from \"three\";\nimport { version } from \"../_polyfill/constants.js\";\nasync function readAsDataURL(blob) {\n  const buffer = await blob.arrayBuffer();\n  const data = btoa(String.fromCharCode(...new Uint8Array(buffer)));\n  return `data:${blob.type || \"\"};base64,${data}`;\n}\nlet _renderer;\nlet fullscreenQuadGeometry;\nlet fullscreenQuadMaterial;\nlet fullscreenQuad;\nfunction decompress(texture, maxTextureSize = Infinity, renderer = null) {\n  if (!fullscreenQuadGeometry)\n    fullscreenQuadGeometry = new PlaneGeometry(2, 2, 1, 1);\n  if (!fullscreenQuadMaterial)\n    fullscreenQuadMaterial = new ShaderMaterial({\n      uniforms: { blitTexture: new Uniform(texture) },\n      vertexShader: (\n        /* glsl */\n        `\n        varying vec2 vUv;\n        void main(){\n            vUv = uv;\n            gl_Position = vec4(position.xy * 1.0,0.,.999999);\n        }\n      `\n      ),\n      fragmentShader: (\n        /* glsl */\n        `\n          uniform sampler2D blitTexture; \n          varying vec2 vUv;\n\n          void main(){ \n              gl_FragColor = vec4(vUv.xy, 0, 1);\n              \n              #ifdef IS_SRGB\n              gl_FragColor = LinearTosRGB( texture2D( blitTexture, vUv) );\n              #else\n              gl_FragColor = texture2D( blitTexture, vUv);\n              #endif\n          }\n      `\n      )\n    });\n  fullscreenQuadMaterial.uniforms.blitTexture.value = texture;\n  fullscreenQuadMaterial.defines.IS_SRGB = \"colorSpace\" in texture ? texture.colorSpace === \"srgb\" : texture.encoding === 3001;\n  fullscreenQuadMaterial.needsUpdate = true;\n  if (!fullscreenQuad) {\n    fullscreenQuad = new Mesh(fullscreenQuadGeometry, fullscreenQuadMaterial);\n    fullscreenQuad.frustrumCulled = false;\n  }\n  const _camera = new PerspectiveCamera();\n  const _scene = new Scene();\n  _scene.add(fullscreenQuad);\n  if (!renderer) {\n    renderer = _renderer = new WebGLRenderer({ antialias: false });\n  }\n  renderer.setSize(Math.min(texture.image.width, maxTextureSize), Math.min(texture.image.height, maxTextureSize));\n  renderer.clear();\n  renderer.render(_scene, _camera);\n  const readableTexture = new Texture(renderer.domElement);\n  readableTexture.minFilter = texture.minFilter;\n  readableTexture.magFilter = texture.magFilter;\n  readableTexture.wrapS = texture.wrapS;\n  readableTexture.wrapT = texture.wrapT;\n  readableTexture.name = texture.name;\n  if (_renderer) {\n    _renderer.dispose();\n    _renderer = null;\n  }\n  return readableTexture;\n}\nconst KHR_mesh_quantization_ExtraAttrTypes = {\n  POSITION: [\n    \"byte\",\n    \"byte normalized\",\n    \"unsigned byte\",\n    \"unsigned byte normalized\",\n    \"short\",\n    \"short normalized\",\n    \"unsigned short\",\n    \"unsigned short normalized\"\n  ],\n  NORMAL: [\"byte normalized\", \"short normalized\"],\n  TANGENT: [\"byte normalized\", \"short normalized\"],\n  TEXCOORD: [\"byte\", \"byte normalized\", \"unsigned byte\", \"short\", \"short normalized\", \"unsigned short\"]\n};\nconst GLTFExporter = /* @__PURE__ */ (() => {\n  class GLTFExporter2 {\n    constructor() {\n      this.pluginCallbacks = [];\n      this.register(function(writer) {\n        return new GLTFLightExtension(writer);\n      });\n      this.register(function(writer) {\n        return new GLTFMaterialsUnlitExtension(writer);\n      });\n      this.register(function(writer) {\n        return new GLTFMaterialsTransmissionExtension(writer);\n      });\n      this.register(function(writer) {\n        return new GLTFMaterialsVolumeExtension(writer);\n      });\n      this.register(function(writer) {\n        return new GLTFMaterialsIorExtension(writer);\n      });\n      this.register(function(writer) {\n        return new GLTFMaterialsSpecularExtension(writer);\n      });\n      this.register(function(writer) {\n        return new GLTFMaterialsClearcoatExtension(writer);\n      });\n      this.register(function(writer) {\n        return new GLTFMaterialsIridescenceExtension(writer);\n      });\n      this.register(function(writer) {\n        return new GLTFMaterialsSheenExtension(writer);\n      });\n      this.register(function(writer) {\n        return new GLTFMaterialsAnisotropyExtension(writer);\n      });\n      this.register(function(writer) {\n        return new GLTFMaterialsEmissiveStrengthExtension(writer);\n      });\n    }\n    register(callback) {\n      if (this.pluginCallbacks.indexOf(callback) === -1) {\n        this.pluginCallbacks.push(callback);\n      }\n      return this;\n    }\n    unregister(callback) {\n      if (this.pluginCallbacks.indexOf(callback) !== -1) {\n        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\n      }\n      return this;\n    }\n    /**\n     * Parse scenes and generate GLTF output\n     * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n     * @param  {Function} onDone  Callback on completed\n     * @param  {Function} onError  Callback on errors\n     * @param  {Object} options options\n     */\n    parse(input, onDone, onError, options) {\n      const writer = new GLTFWriter();\n      const plugins = [];\n      for (let i = 0, il = this.pluginCallbacks.length; i < il; i++) {\n        plugins.push(this.pluginCallbacks[i](writer));\n      }\n      writer.setPlugins(plugins);\n      writer.write(input, onDone, options).catch(onError);\n    }\n    parseAsync(input, options) {\n      const scope = this;\n      return new Promise(function(resolve, reject) {\n        scope.parse(input, resolve, reject, options);\n      });\n    }\n  }\n  /**\n   * Static utility functions\n   */\n  __publicField(GLTFExporter2, \"Utils\", {\n    insertKeyframe: function(track, time) {\n      const tolerance = 1e-3;\n      const valueSize = track.getValueSize();\n      const times = new track.TimeBufferType(track.times.length + 1);\n      const values = new track.ValueBufferType(track.values.length + valueSize);\n      const interpolant = track.createInterpolant(new track.ValueBufferType(valueSize));\n      let index;\n      if (track.times.length === 0) {\n        times[0] = time;\n        for (let i = 0; i < valueSize; i++) {\n          values[i] = 0;\n        }\n        index = 0;\n      } else if (time < track.times[0]) {\n        if (Math.abs(track.times[0] - time) < tolerance)\n          return 0;\n        times[0] = time;\n        times.set(track.times, 1);\n        values.set(interpolant.evaluate(time), 0);\n        values.set(track.values, valueSize);\n        index = 0;\n      } else if (time > track.times[track.times.length - 1]) {\n        if (Math.abs(track.times[track.times.length - 1] - time) < tolerance) {\n          return track.times.length - 1;\n        }\n        times[times.length - 1] = time;\n        times.set(track.times, 0);\n        values.set(track.values, 0);\n        values.set(interpolant.evaluate(time), track.values.length);\n        index = times.length - 1;\n      } else {\n        for (let i = 0; i < track.times.length; i++) {\n          if (Math.abs(track.times[i] - time) < tolerance)\n            return i;\n          if (track.times[i] < time && track.times[i + 1] > time) {\n            times.set(track.times.slice(0, i + 1), 0);\n            times[i + 1] = time;\n            times.set(track.times.slice(i + 1), i + 2);\n            values.set(track.values.slice(0, (i + 1) * valueSize), 0);\n            values.set(interpolant.evaluate(time), (i + 1) * valueSize);\n            values.set(track.values.slice((i + 1) * valueSize), (i + 2) * valueSize);\n            index = i + 1;\n            break;\n          }\n        }\n      }\n      track.times = times;\n      track.values = values;\n      return index;\n    },\n    mergeMorphTargetTracks: function(clip, root) {\n      const tracks = [];\n      const mergedTracks = {};\n      const sourceTracks = clip.tracks;\n      for (let i = 0; i < sourceTracks.length; ++i) {\n        let sourceTrack = sourceTracks[i];\n        const sourceTrackBinding = PropertyBinding.parseTrackName(sourceTrack.name);\n        const sourceTrackNode = PropertyBinding.findNode(root, sourceTrackBinding.nodeName);\n        if (sourceTrackBinding.propertyName !== \"morphTargetInfluences\" || sourceTrackBinding.propertyIndex === void 0) {\n          tracks.push(sourceTrack);\n          continue;\n        }\n        if (sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete && sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear) {\n          if (sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n            throw new Error(\"THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.\");\n          }\n          console.warn(\"THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.\");\n          sourceTrack = sourceTrack.clone();\n          sourceTrack.setInterpolation(InterpolateLinear);\n        }\n        const targetCount = sourceTrackNode.morphTargetInfluences.length;\n        const targetIndex = sourceTrackNode.morphTargetDictionary[sourceTrackBinding.propertyIndex];\n        if (targetIndex === void 0) {\n          throw new Error(\"THREE.GLTFExporter: Morph target name not found: \" + sourceTrackBinding.propertyIndex);\n        }\n        let mergedTrack;\n        if (mergedTracks[sourceTrackNode.uuid] === void 0) {\n          mergedTrack = sourceTrack.clone();\n          const values = new mergedTrack.ValueBufferType(targetCount * mergedTrack.times.length);\n          for (let j = 0; j < mergedTrack.times.length; j++) {\n            values[j * targetCount + targetIndex] = mergedTrack.values[j];\n          }\n          mergedTrack.name = (sourceTrackBinding.nodeName || \"\") + \".morphTargetInfluences\";\n          mergedTrack.values = values;\n          mergedTracks[sourceTrackNode.uuid] = mergedTrack;\n          tracks.push(mergedTrack);\n          continue;\n        }\n        const sourceInterpolant = sourceTrack.createInterpolant(new sourceTrack.ValueBufferType(1));\n        mergedTrack = mergedTracks[sourceTrackNode.uuid];\n        for (let j = 0; j < mergedTrack.times.length; j++) {\n          mergedTrack.values[j * targetCount + targetIndex] = sourceInterpolant.evaluate(mergedTrack.times[j]);\n        }\n        for (let j = 0; j < sourceTrack.times.length; j++) {\n          const keyframeIndex = this.insertKeyframe(mergedTrack, sourceTrack.times[j]);\n          mergedTrack.values[keyframeIndex * targetCount + targetIndex] = sourceTrack.values[j];\n        }\n      }\n      clip.tracks = tracks;\n      return clip;\n    }\n  });\n  return GLTFExporter2;\n})();\nconst WEBGL_CONSTANTS = {\n  POINTS: 0,\n  LINES: 1,\n  LINE_LOOP: 2,\n  LINE_STRIP: 3,\n  TRIANGLES: 4,\n  TRIANGLE_STRIP: 5,\n  TRIANGLE_FAN: 6,\n  BYTE: 5120,\n  UNSIGNED_BYTE: 5121,\n  SHORT: 5122,\n  UNSIGNED_SHORT: 5123,\n  INT: 5124,\n  UNSIGNED_INT: 5125,\n  FLOAT: 5126,\n  ARRAY_BUFFER: 34962,\n  ELEMENT_ARRAY_BUFFER: 34963,\n  NEAREST: 9728,\n  LINEAR: 9729,\n  NEAREST_MIPMAP_NEAREST: 9984,\n  LINEAR_MIPMAP_NEAREST: 9985,\n  NEAREST_MIPMAP_LINEAR: 9986,\n  LINEAR_MIPMAP_LINEAR: 9987,\n  CLAMP_TO_EDGE: 33071,\n  MIRRORED_REPEAT: 33648,\n  REPEAT: 10497\n};\nconst KHR_MESH_QUANTIZATION = \"KHR_mesh_quantization\";\nconst THREE_TO_WEBGL = {};\nTHREE_TO_WEBGL[NearestFilter] = WEBGL_CONSTANTS.NEAREST;\nTHREE_TO_WEBGL[NearestMipmapNearestFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[NearestMipmapLinearFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[LinearFilter] = WEBGL_CONSTANTS.LINEAR;\nTHREE_TO_WEBGL[LinearMipmapNearestFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[LinearMipmapLinearFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[ClampToEdgeWrapping] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;\nTHREE_TO_WEBGL[RepeatWrapping] = WEBGL_CONSTANTS.REPEAT;\nTHREE_TO_WEBGL[MirroredRepeatWrapping] = WEBGL_CONSTANTS.MIRRORED_REPEAT;\nconst PATH_PROPERTIES = {\n  scale: \"scale\",\n  position: \"translation\",\n  quaternion: \"rotation\",\n  morphTargetInfluences: \"weights\"\n};\nconst DEFAULT_SPECULAR_COLOR = /* @__PURE__ */ new Color();\nconst GLB_HEADER_BYTES = 12;\nconst GLB_HEADER_MAGIC = 1179937895;\nconst GLB_VERSION = 2;\nconst GLB_CHUNK_PREFIX_BYTES = 8;\nconst GLB_CHUNK_TYPE_JSON = 1313821514;\nconst GLB_CHUNK_TYPE_BIN = 5130562;\nfunction equalArray(array1, array2) {\n  return array1.length === array2.length && array1.every(function(element, index) {\n    return element === array2[index];\n  });\n}\nfunction stringToArrayBuffer(text) {\n  return new TextEncoder().encode(text).buffer;\n}\nfunction isIdentityMatrix(matrix) {\n  return equalArray(matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n}\nfunction getMinMax(attribute, start, count) {\n  const output = {\n    min: new Array(attribute.itemSize).fill(Number.POSITIVE_INFINITY),\n    max: new Array(attribute.itemSize).fill(Number.NEGATIVE_INFINITY)\n  };\n  for (let i = start; i < start + count; i++) {\n    for (let a = 0; a < attribute.itemSize; a++) {\n      let value;\n      if (attribute.itemSize > 4) {\n        value = attribute.array[i * attribute.itemSize + a];\n      } else {\n        if (a === 0)\n          value = attribute.getX(i);\n        else if (a === 1)\n          value = attribute.getY(i);\n        else if (a === 2)\n          value = attribute.getZ(i);\n        else if (a === 3)\n          value = attribute.getW(i);\n        if (attribute.normalized === true) {\n          value = MathUtils.normalize(value, attribute.array);\n        }\n      }\n      output.min[a] = Math.min(output.min[a], value);\n      output.max[a] = Math.max(output.max[a], value);\n    }\n  }\n  return output;\n}\nfunction getPaddedBufferSize(bufferSize) {\n  return Math.ceil(bufferSize / 4) * 4;\n}\nfunction getPaddedArrayBuffer(arrayBuffer, paddingByte = 0) {\n  const paddedLength = getPaddedBufferSize(arrayBuffer.byteLength);\n  if (paddedLength !== arrayBuffer.byteLength) {\n    const array = new Uint8Array(paddedLength);\n    array.set(new Uint8Array(arrayBuffer));\n    if (paddingByte !== 0) {\n      for (let i = arrayBuffer.byteLength; i < paddedLength; i++) {\n        array[i] = paddingByte;\n      }\n    }\n    return array.buffer;\n  }\n  return arrayBuffer;\n}\nfunction getCanvas() {\n  if (typeof document === \"undefined\" && typeof OffscreenCanvas !== \"undefined\") {\n    return new OffscreenCanvas(1, 1);\n  }\n  return document.createElement(\"canvas\");\n}\nfunction getToBlobPromise(canvas, mimeType) {\n  if (canvas.toBlob !== void 0) {\n    return new Promise((resolve) => canvas.toBlob(resolve, mimeType));\n  }\n  let quality;\n  if (mimeType === \"image/jpeg\") {\n    quality = 0.92;\n  } else if (mimeType === \"image/webp\") {\n    quality = 0.8;\n  }\n  return canvas.convertToBlob({\n    type: mimeType,\n    quality\n  });\n}\nclass GLTFWriter {\n  constructor() {\n    this.plugins = [];\n    this.options = {};\n    this.pending = [];\n    this.buffers = [];\n    this.byteOffset = 0;\n    this.buffers = [];\n    this.nodeMap = /* @__PURE__ */ new Map();\n    this.skins = [];\n    this.extensionsUsed = {};\n    this.extensionsRequired = {};\n    this.uids = /* @__PURE__ */ new Map();\n    this.uid = 0;\n    this.json = {\n      asset: {\n        version: \"2.0\",\n        generator: \"THREE.GLTFExporter\"\n      }\n    };\n    this.cache = {\n      meshes: /* @__PURE__ */ new Map(),\n      attributes: /* @__PURE__ */ new Map(),\n      attributesNormalized: /* @__PURE__ */ new Map(),\n      materials: /* @__PURE__ */ new Map(),\n      textures: /* @__PURE__ */ new Map(),\n      images: /* @__PURE__ */ new Map()\n    };\n  }\n  setPlugins(plugins) {\n    this.plugins = plugins;\n  }\n  /**\n   * Parse scenes and generate GLTF output\n   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n   * @param  {Function} onDone  Callback on completed\n   * @param  {Object} options options\n   */\n  async write(input, onDone, options = {}) {\n    this.options = Object.assign(\n      {\n        // default options\n        binary: false,\n        trs: false,\n        onlyVisible: true,\n        maxTextureSize: Infinity,\n        animations: [],\n        includeCustomExtensions: false\n      },\n      options\n    );\n    if (this.options.animations.length > 0) {\n      this.options.trs = true;\n    }\n    this.processInput(input);\n    await Promise.all(this.pending);\n    const writer = this;\n    const buffers = writer.buffers;\n    const json = writer.json;\n    options = writer.options;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionsRequired = writer.extensionsRequired;\n    const blob = new Blob(buffers, { type: \"application/octet-stream\" });\n    const extensionsUsedList = Object.keys(extensionsUsed);\n    const extensionsRequiredList = Object.keys(extensionsRequired);\n    if (extensionsUsedList.length > 0)\n      json.extensionsUsed = extensionsUsedList;\n    if (extensionsRequiredList.length > 0)\n      json.extensionsRequired = extensionsRequiredList;\n    if (json.buffers && json.buffers.length > 0)\n      json.buffers[0].byteLength = blob.size;\n    if (options.binary === true) {\n      blob.arrayBuffer().then((result) => {\n        const binaryChunk = getPaddedArrayBuffer(result);\n        const binaryChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n        binaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true);\n        binaryChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_BIN, true);\n        const jsonChunk = getPaddedArrayBuffer(stringToArrayBuffer(JSON.stringify(json)), 32);\n        const jsonChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n        jsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true);\n        jsonChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_JSON, true);\n        const header = new ArrayBuffer(GLB_HEADER_BYTES);\n        const headerView = new DataView(header);\n        headerView.setUint32(0, GLB_HEADER_MAGIC, true);\n        headerView.setUint32(4, GLB_VERSION, true);\n        const totalByteLength = GLB_HEADER_BYTES + jsonChunkPrefix.byteLength + jsonChunk.byteLength + binaryChunkPrefix.byteLength + binaryChunk.byteLength;\n        headerView.setUint32(8, totalByteLength, true);\n        const glbBlob = new Blob([header, jsonChunkPrefix, jsonChunk, binaryChunkPrefix, binaryChunk], {\n          type: \"application/octet-stream\"\n        });\n        glbBlob.arrayBuffer().then(onDone);\n      });\n    } else {\n      if (json.buffers && json.buffers.length > 0) {\n        readAsDataURL(blob).then((uri) => {\n          json.buffers[0].uri = uri;\n          onDone(json);\n        });\n      } else {\n        onDone(json);\n      }\n    }\n  }\n  /**\n   * Serializes a userData.\n   *\n   * @param {THREE.Object3D|THREE.Material} object\n   * @param {Object} objectDef\n   */\n  serializeUserData(object, objectDef) {\n    if (Object.keys(object.userData).length === 0)\n      return;\n    const options = this.options;\n    const extensionsUsed = this.extensionsUsed;\n    try {\n      const json = JSON.parse(JSON.stringify(object.userData));\n      if (options.includeCustomExtensions && json.gltfExtensions) {\n        if (objectDef.extensions === void 0)\n          objectDef.extensions = {};\n        for (const extensionName in json.gltfExtensions) {\n          objectDef.extensions[extensionName] = json.gltfExtensions[extensionName];\n          extensionsUsed[extensionName] = true;\n        }\n        delete json.gltfExtensions;\n      }\n      if (Object.keys(json).length > 0)\n        objectDef.extras = json;\n    } catch (error) {\n      console.warn(\n        \"THREE.GLTFExporter: userData of '\" + object.name + \"' won't be serialized because of JSON.stringify error - \" + error.message\n      );\n    }\n  }\n  /**\n   * Returns ids for buffer attributes.\n   * @param  {Object} object\n   * @return {Integer}\n   */\n  getUID(attribute, isRelativeCopy = false) {\n    if (this.uids.has(attribute) === false) {\n      const uids2 = /* @__PURE__ */ new Map();\n      uids2.set(true, this.uid++);\n      uids2.set(false, this.uid++);\n      this.uids.set(attribute, uids2);\n    }\n    const uids = this.uids.get(attribute);\n    return uids.get(isRelativeCopy);\n  }\n  /**\n   * Checks if normal attribute values are normalized.\n   *\n   * @param {BufferAttribute} normal\n   * @returns {Boolean}\n   */\n  isNormalizedNormalAttribute(normal) {\n    const cache = this.cache;\n    if (cache.attributesNormalized.has(normal))\n      return false;\n    const v = new Vector3();\n    for (let i = 0, il = normal.count; i < il; i++) {\n      if (Math.abs(v.fromBufferAttribute(normal, i).length() - 1) > 5e-4)\n        return false;\n    }\n    return true;\n  }\n  /**\n   * Creates normalized normal buffer attribute.\n   *\n   * @param {BufferAttribute} normal\n   * @returns {BufferAttribute}\n   *\n   */\n  createNormalizedNormalAttribute(normal) {\n    const cache = this.cache;\n    if (cache.attributesNormalized.has(normal))\n      return cache.attributesNormalized.get(normal);\n    const attribute = normal.clone();\n    const v = new Vector3();\n    for (let i = 0, il = attribute.count; i < il; i++) {\n      v.fromBufferAttribute(attribute, i);\n      if (v.x === 0 && v.y === 0 && v.z === 0) {\n        v.setX(1);\n      } else {\n        v.normalize();\n      }\n      attribute.setXYZ(i, v.x, v.y, v.z);\n    }\n    cache.attributesNormalized.set(normal, attribute);\n    return attribute;\n  }\n  /**\n   * Applies a texture transform, if present, to the map definition. Requires\n   * the KHR_texture_transform extension.\n   *\n   * @param {Object} mapDef\n   * @param {THREE.Texture} texture\n   */\n  applyTextureTransform(mapDef, texture) {\n    let didTransform = false;\n    const transformDef = {};\n    if (texture.offset.x !== 0 || texture.offset.y !== 0) {\n      transformDef.offset = texture.offset.toArray();\n      didTransform = true;\n    }\n    if (texture.rotation !== 0) {\n      transformDef.rotation = texture.rotation;\n      didTransform = true;\n    }\n    if (texture.repeat.x !== 1 || texture.repeat.y !== 1) {\n      transformDef.scale = texture.repeat.toArray();\n      didTransform = true;\n    }\n    if (didTransform) {\n      mapDef.extensions = mapDef.extensions || {};\n      mapDef.extensions[\"KHR_texture_transform\"] = transformDef;\n      this.extensionsUsed[\"KHR_texture_transform\"] = true;\n    }\n  }\n  buildMetalRoughTexture(metalnessMap, roughnessMap) {\n    if (metalnessMap === roughnessMap)\n      return metalnessMap;\n    function getEncodingConversion(map) {\n      if (\"colorSpace\" in map ? map.colorSpace === \"srgb\" : map.encoding === 3001) {\n        return function SRGBToLinear(c) {\n          return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);\n        };\n      }\n      return function LinearToLinear(c) {\n        return c;\n      };\n    }\n    console.warn(\"THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures.\");\n    if (metalnessMap instanceof CompressedTexture) {\n      metalnessMap = decompress(metalnessMap);\n    }\n    if (roughnessMap instanceof CompressedTexture) {\n      roughnessMap = decompress(roughnessMap);\n    }\n    const metalness = metalnessMap ? metalnessMap.image : null;\n    const roughness = roughnessMap ? roughnessMap.image : null;\n    const width = Math.max(metalness ? metalness.width : 0, roughness ? roughness.width : 0);\n    const height = Math.max(metalness ? metalness.height : 0, roughness ? roughness.height : 0);\n    const canvas = getCanvas();\n    canvas.width = width;\n    canvas.height = height;\n    const context = canvas.getContext(\"2d\");\n    context.fillStyle = \"#00ffff\";\n    context.fillRect(0, 0, width, height);\n    const composite = context.getImageData(0, 0, width, height);\n    if (metalness) {\n      context.drawImage(metalness, 0, 0, width, height);\n      const convert = getEncodingConversion(metalnessMap);\n      const data = context.getImageData(0, 0, width, height).data;\n      for (let i = 2; i < data.length; i += 4) {\n        composite.data[i] = convert(data[i] / 256) * 256;\n      }\n    }\n    if (roughness) {\n      context.drawImage(roughness, 0, 0, width, height);\n      const convert = getEncodingConversion(roughnessMap);\n      const data = context.getImageData(0, 0, width, height).data;\n      for (let i = 1; i < data.length; i += 4) {\n        composite.data[i] = convert(data[i] / 256) * 256;\n      }\n    }\n    context.putImageData(composite, 0, 0);\n    const reference = metalnessMap || roughnessMap;\n    const texture = reference.clone();\n    texture.source = new Texture(canvas).source;\n    if (\"colorSpace\" in texture)\n      texture.colorSpace = \"\";\n    else\n      texture.encoding = 3e3;\n    texture.channel = (metalnessMap || roughnessMap).channel;\n    if (metalnessMap && roughnessMap && metalnessMap.channel !== roughnessMap.channel) {\n      console.warn(\"THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match.\");\n    }\n    return texture;\n  }\n  /**\n   * Process a buffer to append to the default one.\n   * @param  {ArrayBuffer} buffer\n   * @return {Integer}\n   */\n  processBuffer(buffer) {\n    const json = this.json;\n    const buffers = this.buffers;\n    if (!json.buffers)\n      json.buffers = [{ byteLength: 0 }];\n    buffers.push(buffer);\n    return 0;\n  }\n  /**\n   * Process and generate a BufferView\n   * @param  {BufferAttribute} attribute\n   * @param  {number} componentType\n   * @param  {number} start\n   * @param  {number} count\n   * @param  {number} target (Optional) Target usage of the BufferView\n   * @return {Object}\n   */\n  processBufferView(attribute, componentType, start, count, target) {\n    const json = this.json;\n    if (!json.bufferViews)\n      json.bufferViews = [];\n    let componentSize;\n    switch (componentType) {\n      case WEBGL_CONSTANTS.BYTE:\n      case WEBGL_CONSTANTS.UNSIGNED_BYTE:\n        componentSize = 1;\n        break;\n      case WEBGL_CONSTANTS.SHORT:\n      case WEBGL_CONSTANTS.UNSIGNED_SHORT:\n        componentSize = 2;\n        break;\n      default:\n        componentSize = 4;\n    }\n    let byteStride = attribute.itemSize * componentSize;\n    if (target === WEBGL_CONSTANTS.ARRAY_BUFFER) {\n      byteStride = Math.ceil(byteStride / 4) * 4;\n    }\n    const byteLength = getPaddedBufferSize(count * byteStride);\n    const dataView = new DataView(new ArrayBuffer(byteLength));\n    let offset = 0;\n    for (let i = start; i < start + count; i++) {\n      for (let a = 0; a < attribute.itemSize; a++) {\n        let value;\n        if (attribute.itemSize > 4) {\n          value = attribute.array[i * attribute.itemSize + a];\n        } else {\n          if (a === 0)\n            value = attribute.getX(i);\n          else if (a === 1)\n            value = attribute.getY(i);\n          else if (a === 2)\n            value = attribute.getZ(i);\n          else if (a === 3)\n            value = attribute.getW(i);\n          if (attribute.normalized === true) {\n            value = MathUtils.normalize(value, attribute.array);\n          }\n        }\n        if (componentType === WEBGL_CONSTANTS.FLOAT) {\n          dataView.setFloat32(offset, value, true);\n        } else if (componentType === WEBGL_CONSTANTS.INT) {\n          dataView.setInt32(offset, value, true);\n        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_INT) {\n          dataView.setUint32(offset, value, true);\n        } else if (componentType === WEBGL_CONSTANTS.SHORT) {\n          dataView.setInt16(offset, value, true);\n        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\n          dataView.setUint16(offset, value, true);\n        } else if (componentType === WEBGL_CONSTANTS.BYTE) {\n          dataView.setInt8(offset, value);\n        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\n          dataView.setUint8(offset, value);\n        }\n        offset += componentSize;\n      }\n      if (offset % byteStride !== 0) {\n        offset += byteStride - offset % byteStride;\n      }\n    }\n    const bufferViewDef = {\n      buffer: this.processBuffer(dataView.buffer),\n      byteOffset: this.byteOffset,\n      byteLength\n    };\n    if (target !== void 0)\n      bufferViewDef.target = target;\n    if (target === WEBGL_CONSTANTS.ARRAY_BUFFER) {\n      bufferViewDef.byteStride = byteStride;\n    }\n    this.byteOffset += byteLength;\n    json.bufferViews.push(bufferViewDef);\n    const output = {\n      id: json.bufferViews.length - 1,\n      byteLength: 0\n    };\n    return output;\n  }\n  /**\n   * Process and generate a BufferView from an image Blob.\n   * @param {Blob} blob\n   * @return {Promise<Integer>}\n   */\n  processBufferViewImage(blob) {\n    const writer = this;\n    const json = writer.json;\n    if (!json.bufferViews)\n      json.bufferViews = [];\n    return blob.arrayBuffer().then((result) => {\n      const buffer = getPaddedArrayBuffer(result);\n      const bufferViewDef = {\n        buffer: writer.processBuffer(buffer),\n        byteOffset: writer.byteOffset,\n        byteLength: buffer.byteLength\n      };\n      writer.byteOffset += buffer.byteLength;\n      return json.bufferViews.push(bufferViewDef) - 1;\n    });\n  }\n  /**\n   * Process attribute to generate an accessor\n   * @param  {BufferAttribute} attribute Attribute to process\n   * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range\n   * @param  {Integer} start (Optional)\n   * @param  {Integer} count (Optional)\n   * @return {Integer|null} Index of the processed accessor on the \"accessors\" array\n   */\n  processAccessor(attribute, geometry, start, count) {\n    const json = this.json;\n    const types = {\n      1: \"SCALAR\",\n      2: \"VEC2\",\n      3: \"VEC3\",\n      4: \"VEC4\",\n      9: \"MAT3\",\n      16: \"MAT4\"\n    };\n    let componentType;\n    if (attribute.array.constructor === Float32Array) {\n      componentType = WEBGL_CONSTANTS.FLOAT;\n    } else if (attribute.array.constructor === Int32Array) {\n      componentType = WEBGL_CONSTANTS.INT;\n    } else if (attribute.array.constructor === Uint32Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_INT;\n    } else if (attribute.array.constructor === Int16Array) {\n      componentType = WEBGL_CONSTANTS.SHORT;\n    } else if (attribute.array.constructor === Uint16Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;\n    } else if (attribute.array.constructor === Int8Array) {\n      componentType = WEBGL_CONSTANTS.BYTE;\n    } else if (attribute.array.constructor === Uint8Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;\n    } else {\n      throw new Error(\n        \"THREE.GLTFExporter: Unsupported bufferAttribute component type: \" + attribute.array.constructor.name\n      );\n    }\n    if (start === void 0)\n      start = 0;\n    if (count === void 0)\n      count = attribute.count;\n    if (count === 0)\n      return null;\n    const minMax = getMinMax(attribute, start, count);\n    let bufferViewTarget;\n    if (geometry !== void 0) {\n      bufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;\n    }\n    const bufferView = this.processBufferView(attribute, componentType, start, count, bufferViewTarget);\n    const accessorDef = {\n      bufferView: bufferView.id,\n      byteOffset: bufferView.byteOffset,\n      componentType,\n      count,\n      max: minMax.max,\n      min: minMax.min,\n      type: types[attribute.itemSize]\n    };\n    if (attribute.normalized === true)\n      accessorDef.normalized = true;\n    if (!json.accessors)\n      json.accessors = [];\n    return json.accessors.push(accessorDef) - 1;\n  }\n  /**\n   * Process image\n   * @param  {Image} image to process\n   * @param  {Integer} format of the image (RGBAFormat)\n   * @param  {Boolean} flipY before writing out the image\n   * @param  {String} mimeType export format\n   * @return {Integer}     Index of the processed texture in the \"images\" array\n   */\n  processImage(image, format, flipY, mimeType = \"image/png\") {\n    if (image !== null) {\n      const writer = this;\n      const cache = writer.cache;\n      const json = writer.json;\n      const options = writer.options;\n      const pending = writer.pending;\n      if (!cache.images.has(image))\n        cache.images.set(image, {});\n      const cachedImages = cache.images.get(image);\n      const key = mimeType + \":flipY/\" + flipY.toString();\n      if (cachedImages[key] !== void 0)\n        return cachedImages[key];\n      if (!json.images)\n        json.images = [];\n      const imageDef = { mimeType };\n      const canvas = getCanvas();\n      canvas.width = Math.min(image.width, options.maxTextureSize);\n      canvas.height = Math.min(image.height, options.maxTextureSize);\n      const ctx = canvas.getContext(\"2d\");\n      if (flipY === true) {\n        ctx.translate(0, canvas.height);\n        ctx.scale(1, -1);\n      }\n      if (image.data !== void 0) {\n        if (format !== RGBAFormat) {\n          console.error(\"GLTFExporter: Only RGBAFormat is supported.\", format);\n        }\n        if (image.width > options.maxTextureSize || image.height > options.maxTextureSize) {\n          console.warn(\"GLTFExporter: Image size is bigger than maxTextureSize\", image);\n        }\n        const data = new Uint8ClampedArray(image.height * image.width * 4);\n        for (let i = 0; i < data.length; i += 4) {\n          data[i + 0] = image.data[i + 0];\n          data[i + 1] = image.data[i + 1];\n          data[i + 2] = image.data[i + 2];\n          data[i + 3] = image.data[i + 3];\n        }\n        ctx.putImageData(new ImageData(data, image.width, image.height), 0, 0);\n      } else {\n        ctx.drawImage(image, 0, 0, canvas.width, canvas.height);\n      }\n      if (options.binary === true) {\n        pending.push(\n          getToBlobPromise(canvas, mimeType).then((blob) => writer.processBufferViewImage(blob)).then((bufferViewIndex) => {\n            imageDef.bufferView = bufferViewIndex;\n          })\n        );\n      } else {\n        if (canvas.toDataURL !== void 0) {\n          imageDef.uri = canvas.toDataURL(mimeType);\n        } else {\n          pending.push(\n            getToBlobPromise(canvas, mimeType).then(readAsDataURL).then((uri) => {\n              imageDef.uri = uri;\n            })\n          );\n        }\n      }\n      const index = json.images.push(imageDef) - 1;\n      cachedImages[key] = index;\n      return index;\n    } else {\n      throw new Error(\"THREE.GLTFExporter: No valid image data found. Unable to process texture.\");\n    }\n  }\n  /**\n   * Process sampler\n   * @param  {Texture} map Texture to process\n   * @return {Integer}     Index of the processed texture in the \"samplers\" array\n   */\n  processSampler(map) {\n    const json = this.json;\n    if (!json.samplers)\n      json.samplers = [];\n    const samplerDef = {\n      magFilter: THREE_TO_WEBGL[map.magFilter],\n      minFilter: THREE_TO_WEBGL[map.minFilter],\n      wrapS: THREE_TO_WEBGL[map.wrapS],\n      wrapT: THREE_TO_WEBGL[map.wrapT]\n    };\n    return json.samplers.push(samplerDef) - 1;\n  }\n  /**\n   * Process texture\n   * @param  {Texture} map Map to process\n   * @return {Integer} Index of the processed texture in the \"textures\" array\n   */\n  processTexture(map) {\n    const writer = this;\n    const options = writer.options;\n    const cache = this.cache;\n    const json = this.json;\n    if (cache.textures.has(map))\n      return cache.textures.get(map);\n    if (!json.textures)\n      json.textures = [];\n    if (map instanceof CompressedTexture) {\n      map = decompress(map, options.maxTextureSize);\n    }\n    let mimeType = map.userData.mimeType;\n    if (mimeType === \"image/webp\")\n      mimeType = \"image/png\";\n    const textureDef = {\n      sampler: this.processSampler(map),\n      source: this.processImage(map.image, map.format, map.flipY, mimeType)\n    };\n    if (map.name)\n      textureDef.name = map.name;\n    this._invokeAll(function(ext) {\n      ext.writeTexture && ext.writeTexture(map, textureDef);\n    });\n    const index = json.textures.push(textureDef) - 1;\n    cache.textures.set(map, index);\n    return index;\n  }\n  /**\n   * Process material\n   * @param  {THREE.Material} material Material to process\n   * @return {Integer|null} Index of the processed material in the \"materials\" array\n   */\n  processMaterial(material) {\n    const cache = this.cache;\n    const json = this.json;\n    if (cache.materials.has(material))\n      return cache.materials.get(material);\n    if (material.isShaderMaterial) {\n      console.warn(\"GLTFExporter: THREE.ShaderMaterial not supported.\");\n      return null;\n    }\n    if (!json.materials)\n      json.materials = [];\n    const materialDef = { pbrMetallicRoughness: {} };\n    if (material.isMeshStandardMaterial !== true && material.isMeshBasicMaterial !== true) {\n      console.warn(\"GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.\");\n    }\n    const color = material.color.toArray().concat([material.opacity]);\n    if (!equalArray(color, [1, 1, 1, 1])) {\n      materialDef.pbrMetallicRoughness.baseColorFactor = color;\n    }\n    if (material.isMeshStandardMaterial) {\n      materialDef.pbrMetallicRoughness.metallicFactor = material.metalness;\n      materialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;\n    } else {\n      materialDef.pbrMetallicRoughness.metallicFactor = 0.5;\n      materialDef.pbrMetallicRoughness.roughnessFactor = 0.5;\n    }\n    if (material.metalnessMap || material.roughnessMap) {\n      const metalRoughTexture = this.buildMetalRoughTexture(material.metalnessMap, material.roughnessMap);\n      const metalRoughMapDef = {\n        index: this.processTexture(metalRoughTexture),\n        channel: metalRoughTexture.channel\n      };\n      this.applyTextureTransform(metalRoughMapDef, metalRoughTexture);\n      materialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;\n    }\n    if (material.map) {\n      const baseColorMapDef = {\n        index: this.processTexture(material.map),\n        texCoord: material.map.channel\n      };\n      this.applyTextureTransform(baseColorMapDef, material.map);\n      materialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;\n    }\n    if (material.emissive) {\n      const emissive = material.emissive;\n      const maxEmissiveComponent = Math.max(emissive.r, emissive.g, emissive.b);\n      if (maxEmissiveComponent > 0) {\n        materialDef.emissiveFactor = material.emissive.toArray();\n      }\n      if (material.emissiveMap) {\n        const emissiveMapDef = {\n          index: this.processTexture(material.emissiveMap),\n          texCoord: material.emissiveMap.channel\n        };\n        this.applyTextureTransform(emissiveMapDef, material.emissiveMap);\n        materialDef.emissiveTexture = emissiveMapDef;\n      }\n    }\n    if (material.normalMap) {\n      const normalMapDef = {\n        index: this.processTexture(material.normalMap),\n        texCoord: material.normalMap.channel\n      };\n      if (material.normalScale && material.normalScale.x !== 1) {\n        normalMapDef.scale = material.normalScale.x;\n      }\n      this.applyTextureTransform(normalMapDef, material.normalMap);\n      materialDef.normalTexture = normalMapDef;\n    }\n    if (material.aoMap) {\n      const occlusionMapDef = {\n        index: this.processTexture(material.aoMap),\n        texCoord: material.aoMap.channel\n      };\n      if (material.aoMapIntensity !== 1) {\n        occlusionMapDef.strength = material.aoMapIntensity;\n      }\n      this.applyTextureTransform(occlusionMapDef, material.aoMap);\n      materialDef.occlusionTexture = occlusionMapDef;\n    }\n    if (material.transparent) {\n      materialDef.alphaMode = \"BLEND\";\n    } else {\n      if (material.alphaTest > 0) {\n        materialDef.alphaMode = \"MASK\";\n        materialDef.alphaCutoff = material.alphaTest;\n      }\n    }\n    if (material.side === DoubleSide)\n      materialDef.doubleSided = true;\n    if (material.name !== \"\")\n      materialDef.name = material.name;\n    this.serializeUserData(material, materialDef);\n    this._invokeAll(function(ext) {\n      ext.writeMaterial && ext.writeMaterial(material, materialDef);\n    });\n    const index = json.materials.push(materialDef) - 1;\n    cache.materials.set(material, index);\n    return index;\n  }\n  /**\n   * Process mesh\n   * @param  {THREE.Mesh} mesh Mesh to process\n   * @return {Integer|null} Index of the processed mesh in the \"meshes\" array\n   */\n  processMesh(mesh) {\n    const cache = this.cache;\n    const json = this.json;\n    const meshCacheKeyParts = [mesh.geometry.uuid];\n    if (Array.isArray(mesh.material)) {\n      for (let i = 0, l = mesh.material.length; i < l; i++) {\n        meshCacheKeyParts.push(mesh.material[i].uuid);\n      }\n    } else {\n      meshCacheKeyParts.push(mesh.material.uuid);\n    }\n    const meshCacheKey = meshCacheKeyParts.join(\":\");\n    if (cache.meshes.has(meshCacheKey))\n      return cache.meshes.get(meshCacheKey);\n    const geometry = mesh.geometry;\n    let mode;\n    if (mesh.isLineSegments) {\n      mode = WEBGL_CONSTANTS.LINES;\n    } else if (mesh.isLineLoop) {\n      mode = WEBGL_CONSTANTS.LINE_LOOP;\n    } else if (mesh.isLine) {\n      mode = WEBGL_CONSTANTS.LINE_STRIP;\n    } else if (mesh.isPoints) {\n      mode = WEBGL_CONSTANTS.POINTS;\n    } else {\n      mode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;\n    }\n    const meshDef = {};\n    const attributes = {};\n    const primitives = [];\n    const targets = [];\n    const nameConversion = {\n      ...version >= 152 ? {\n        uv: \"TEXCOORD_0\",\n        uv1: \"TEXCOORD_1\",\n        uv2: \"TEXCOORD_2\",\n        uv3: \"TEXCOORD_3\"\n      } : {\n        uv: \"TEXCOORD_0\",\n        uv2: \"TEXCOORD_1\"\n      },\n      color: \"COLOR_0\",\n      skinWeight: \"WEIGHTS_0\",\n      skinIndex: \"JOINTS_0\"\n    };\n    const originalNormal = geometry.getAttribute(\"normal\");\n    if (originalNormal !== void 0 && !this.isNormalizedNormalAttribute(originalNormal)) {\n      console.warn(\"THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.\");\n      geometry.setAttribute(\"normal\", this.createNormalizedNormalAttribute(originalNormal));\n    }\n    let modifiedAttribute = null;\n    for (let attributeName in geometry.attributes) {\n      if (attributeName.slice(0, 5) === \"morph\")\n        continue;\n      const attribute = geometry.attributes[attributeName];\n      attributeName = nameConversion[attributeName] || attributeName.toUpperCase();\n      const validVertexAttributes = /^(POSITION|NORMAL|TANGENT|TEXCOORD_\\d+|COLOR_\\d+|JOINTS_\\d+|WEIGHTS_\\d+)$/;\n      if (!validVertexAttributes.test(attributeName))\n        attributeName = \"_\" + attributeName;\n      if (cache.attributes.has(this.getUID(attribute))) {\n        attributes[attributeName] = cache.attributes.get(this.getUID(attribute));\n        continue;\n      }\n      modifiedAttribute = null;\n      const array = attribute.array;\n      if (attributeName === \"JOINTS_0\" && !(array instanceof Uint16Array) && !(array instanceof Uint8Array)) {\n        console.warn('GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.');\n        modifiedAttribute = new BufferAttribute(new Uint16Array(array), attribute.itemSize, attribute.normalized);\n      }\n      const accessor = this.processAccessor(modifiedAttribute || attribute, geometry);\n      if (accessor !== null) {\n        if (!attributeName.startsWith(\"_\")) {\n          this.detectMeshQuantization(attributeName, attribute);\n        }\n        attributes[attributeName] = accessor;\n        cache.attributes.set(this.getUID(attribute), accessor);\n      }\n    }\n    if (originalNormal !== void 0)\n      geometry.setAttribute(\"normal\", originalNormal);\n    if (Object.keys(attributes).length === 0)\n      return null;\n    if (mesh.morphTargetInfluences !== void 0 && mesh.morphTargetInfluences.length > 0) {\n      const weights = [];\n      const targetNames = [];\n      const reverseDictionary = {};\n      if (mesh.morphTargetDictionary !== void 0) {\n        for (const key in mesh.morphTargetDictionary) {\n          reverseDictionary[mesh.morphTargetDictionary[key]] = key;\n        }\n      }\n      for (let i = 0; i < mesh.morphTargetInfluences.length; ++i) {\n        const target = {};\n        let warned = false;\n        for (const attributeName in geometry.morphAttributes) {\n          if (attributeName !== \"position\" && attributeName !== \"normal\") {\n            if (!warned) {\n              console.warn(\"GLTFExporter: Only POSITION and NORMAL morph are supported.\");\n              warned = true;\n            }\n            continue;\n          }\n          const attribute = geometry.morphAttributes[attributeName][i];\n          const gltfAttributeName = attributeName.toUpperCase();\n          const baseAttribute = geometry.attributes[attributeName];\n          if (cache.attributes.has(this.getUID(attribute, true))) {\n            target[gltfAttributeName] = cache.attributes.get(this.getUID(attribute, true));\n            continue;\n          }\n          const relativeAttribute = attribute.clone();\n          if (!geometry.morphTargetsRelative) {\n            for (let j = 0, jl = attribute.count; j < jl; j++) {\n              for (let a = 0; a < attribute.itemSize; a++) {\n                if (a === 0)\n                  relativeAttribute.setX(j, attribute.getX(j) - baseAttribute.getX(j));\n                if (a === 1)\n                  relativeAttribute.setY(j, attribute.getY(j) - baseAttribute.getY(j));\n                if (a === 2)\n                  relativeAttribute.setZ(j, attribute.getZ(j) - baseAttribute.getZ(j));\n                if (a === 3)\n                  relativeAttribute.setW(j, attribute.getW(j) - baseAttribute.getW(j));\n              }\n            }\n          }\n          target[gltfAttributeName] = this.processAccessor(relativeAttribute, geometry);\n          cache.attributes.set(this.getUID(baseAttribute, true), target[gltfAttributeName]);\n        }\n        targets.push(target);\n        weights.push(mesh.morphTargetInfluences[i]);\n        if (mesh.morphTargetDictionary !== void 0)\n          targetNames.push(reverseDictionary[i]);\n      }\n      meshDef.weights = weights;\n      if (targetNames.length > 0) {\n        meshDef.extras = {};\n        meshDef.extras.targetNames = targetNames;\n      }\n    }\n    const isMultiMaterial = Array.isArray(mesh.material);\n    if (isMultiMaterial && geometry.groups.length === 0)\n      return null;\n    const materials = isMultiMaterial ? mesh.material : [mesh.material];\n    const groups = isMultiMaterial ? geometry.groups : [{ materialIndex: 0, start: void 0, count: void 0 }];\n    for (let i = 0, il = groups.length; i < il; i++) {\n      const primitive = {\n        mode,\n        attributes\n      };\n      this.serializeUserData(geometry, primitive);\n      if (targets.length > 0)\n        primitive.targets = targets;\n      if (geometry.index !== null) {\n        let cacheKey = this.getUID(geometry.index);\n        if (groups[i].start !== void 0 || groups[i].count !== void 0) {\n          cacheKey += \":\" + groups[i].start + \":\" + groups[i].count;\n        }\n        if (cache.attributes.has(cacheKey)) {\n          primitive.indices = cache.attributes.get(cacheKey);\n        } else {\n          primitive.indices = this.processAccessor(geometry.index, geometry, groups[i].start, groups[i].count);\n          cache.attributes.set(cacheKey, primitive.indices);\n        }\n        if (primitive.indices === null)\n          delete primitive.indices;\n      }\n      const material = this.processMaterial(materials[groups[i].materialIndex]);\n      if (material !== null)\n        primitive.material = material;\n      primitives.push(primitive);\n    }\n    meshDef.primitives = primitives;\n    if (!json.meshes)\n      json.meshes = [];\n    this._invokeAll(function(ext) {\n      ext.writeMesh && ext.writeMesh(mesh, meshDef);\n    });\n    const index = json.meshes.push(meshDef) - 1;\n    cache.meshes.set(meshCacheKey, index);\n    return index;\n  }\n  /**\n   * If a vertex attribute with a\n   * [non-standard data type](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#meshes-overview)\n   * is used, it is checked whether it is a valid data type according to the\n   * [KHR_mesh_quantization](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md)\n   * extension.\n   * In this case the extension is automatically added to the list of used extensions.\n   *\n   * @param {string} attributeName\n   * @param {THREE.BufferAttribute} attribute\n   */\n  detectMeshQuantization(attributeName, attribute) {\n    if (this.extensionsUsed[KHR_MESH_QUANTIZATION])\n      return;\n    let attrType = void 0;\n    switch (attribute.array.constructor) {\n      case Int8Array:\n        attrType = \"byte\";\n        break;\n      case Uint8Array:\n        attrType = \"unsigned byte\";\n        break;\n      case Int16Array:\n        attrType = \"short\";\n        break;\n      case Uint16Array:\n        attrType = \"unsigned short\";\n        break;\n      default:\n        return;\n    }\n    if (attribute.normalized)\n      attrType += \" normalized\";\n    const attrNamePrefix = attributeName.split(\"_\", 1)[0];\n    if (KHR_mesh_quantization_ExtraAttrTypes[attrNamePrefix] && KHR_mesh_quantization_ExtraAttrTypes[attrNamePrefix].includes(attrType)) {\n      this.extensionsUsed[KHR_MESH_QUANTIZATION] = true;\n      this.extensionsRequired[KHR_MESH_QUANTIZATION] = true;\n    }\n  }\n  /**\n   * Process camera\n   * @param  {THREE.Camera} camera Camera to process\n   * @return {Integer}      Index of the processed mesh in the \"camera\" array\n   */\n  processCamera(camera) {\n    const json = this.json;\n    if (!json.cameras)\n      json.cameras = [];\n    const isOrtho = camera.isOrthographicCamera;\n    const cameraDef = {\n      type: isOrtho ? \"orthographic\" : \"perspective\"\n    };\n    if (isOrtho) {\n      cameraDef.orthographic = {\n        xmag: camera.right * 2,\n        ymag: camera.top * 2,\n        zfar: camera.far <= 0 ? 1e-3 : camera.far,\n        znear: camera.near < 0 ? 0 : camera.near\n      };\n    } else {\n      cameraDef.perspective = {\n        aspectRatio: camera.aspect,\n        yfov: MathUtils.degToRad(camera.fov),\n        zfar: camera.far <= 0 ? 1e-3 : camera.far,\n        znear: camera.near < 0 ? 0 : camera.near\n      };\n    }\n    if (camera.name !== \"\")\n      cameraDef.name = camera.type;\n    return json.cameras.push(cameraDef) - 1;\n  }\n  /**\n   * Creates glTF animation entry from AnimationClip object.\n   *\n   * Status:\n   * - Only properties listed in PATH_PROPERTIES may be animated.\n   *\n   * @param {THREE.AnimationClip} clip\n   * @param {THREE.Object3D} root\n   * @return {number|null}\n   */\n  processAnimation(clip, root) {\n    const json = this.json;\n    const nodeMap = this.nodeMap;\n    if (!json.animations)\n      json.animations = [];\n    clip = GLTFExporter.Utils.mergeMorphTargetTracks(clip.clone(), root);\n    const tracks = clip.tracks;\n    const channels = [];\n    const samplers = [];\n    for (let i = 0; i < tracks.length; ++i) {\n      const track = tracks[i];\n      const trackBinding = PropertyBinding.parseTrackName(track.name);\n      let trackNode = PropertyBinding.findNode(root, trackBinding.nodeName);\n      const trackProperty = PATH_PROPERTIES[trackBinding.propertyName];\n      if (trackBinding.objectName === \"bones\") {\n        if (trackNode.isSkinnedMesh === true) {\n          trackNode = trackNode.skeleton.getBoneByName(trackBinding.objectIndex);\n        } else {\n          trackNode = void 0;\n        }\n      }\n      if (!trackNode || !trackProperty) {\n        console.warn('THREE.GLTFExporter: Could not export animation track \"%s\".', track.name);\n        return null;\n      }\n      const inputItemSize = 1;\n      let outputItemSize = track.values.length / track.times.length;\n      if (trackProperty === PATH_PROPERTIES.morphTargetInfluences) {\n        outputItemSize /= trackNode.morphTargetInfluences.length;\n      }\n      let interpolation;\n      if (track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true) {\n        interpolation = \"CUBICSPLINE\";\n        outputItemSize /= 3;\n      } else if (track.getInterpolation() === InterpolateDiscrete) {\n        interpolation = \"STEP\";\n      } else {\n        interpolation = \"LINEAR\";\n      }\n      samplers.push({\n        input: this.processAccessor(new BufferAttribute(track.times, inputItemSize)),\n        output: this.processAccessor(new BufferAttribute(track.values, outputItemSize)),\n        interpolation\n      });\n      channels.push({\n        sampler: samplers.length - 1,\n        target: {\n          node: nodeMap.get(trackNode),\n          path: trackProperty\n        }\n      });\n    }\n    json.animations.push({\n      name: clip.name || \"clip_\" + json.animations.length,\n      samplers,\n      channels\n    });\n    return json.animations.length - 1;\n  }\n  /**\n   * @param {THREE.Object3D} object\n   * @return {number|null}\n   */\n  processSkin(object) {\n    const json = this.json;\n    const nodeMap = this.nodeMap;\n    const node = json.nodes[nodeMap.get(object)];\n    const skeleton = object.skeleton;\n    if (skeleton === void 0)\n      return null;\n    const rootJoint = object.skeleton.bones[0];\n    if (rootJoint === void 0)\n      return null;\n    const joints = [];\n    const inverseBindMatrices = new Float32Array(skeleton.bones.length * 16);\n    const temporaryBoneInverse = new Matrix4();\n    for (let i = 0; i < skeleton.bones.length; ++i) {\n      joints.push(nodeMap.get(skeleton.bones[i]));\n      temporaryBoneInverse.copy(skeleton.boneInverses[i]);\n      temporaryBoneInverse.multiply(object.bindMatrix).toArray(inverseBindMatrices, i * 16);\n    }\n    if (json.skins === void 0)\n      json.skins = [];\n    json.skins.push({\n      inverseBindMatrices: this.processAccessor(new BufferAttribute(inverseBindMatrices, 16)),\n      joints,\n      skeleton: nodeMap.get(rootJoint)\n    });\n    const skinIndex = node.skin = json.skins.length - 1;\n    return skinIndex;\n  }\n  /**\n   * Process Object3D node\n   * @param  {THREE.Object3D} node Object3D to processNode\n   * @return {Integer} Index of the node in the nodes list\n   */\n  processNode(object) {\n    const json = this.json;\n    const options = this.options;\n    const nodeMap = this.nodeMap;\n    if (!json.nodes)\n      json.nodes = [];\n    const nodeDef = {};\n    if (options.trs) {\n      const rotation = object.quaternion.toArray();\n      const position = object.position.toArray();\n      const scale = object.scale.toArray();\n      if (!equalArray(rotation, [0, 0, 0, 1])) {\n        nodeDef.rotation = rotation;\n      }\n      if (!equalArray(position, [0, 0, 0])) {\n        nodeDef.translation = position;\n      }\n      if (!equalArray(scale, [1, 1, 1])) {\n        nodeDef.scale = scale;\n      }\n    } else {\n      if (object.matrixAutoUpdate) {\n        object.updateMatrix();\n      }\n      if (isIdentityMatrix(object.matrix) === false) {\n        nodeDef.matrix = object.matrix.elements;\n      }\n    }\n    if (object.name !== \"\")\n      nodeDef.name = String(object.name);\n    this.serializeUserData(object, nodeDef);\n    if (object.isMesh || object.isLine || object.isPoints) {\n      const meshIndex = this.processMesh(object);\n      if (meshIndex !== null)\n        nodeDef.mesh = meshIndex;\n    } else if (object.isCamera) {\n      nodeDef.camera = this.processCamera(object);\n    }\n    if (object.isSkinnedMesh)\n      this.skins.push(object);\n    if (object.children.length > 0) {\n      const children = [];\n      for (let i = 0, l = object.children.length; i < l; i++) {\n        const child = object.children[i];\n        if (child.visible || options.onlyVisible === false) {\n          const nodeIndex2 = this.processNode(child);\n          if (nodeIndex2 !== null)\n            children.push(nodeIndex2);\n        }\n      }\n      if (children.length > 0)\n        nodeDef.children = children;\n    }\n    this._invokeAll(function(ext) {\n      ext.writeNode && ext.writeNode(object, nodeDef);\n    });\n    const nodeIndex = json.nodes.push(nodeDef) - 1;\n    nodeMap.set(object, nodeIndex);\n    return nodeIndex;\n  }\n  /**\n   * Process Scene\n   * @param  {Scene} node Scene to process\n   */\n  processScene(scene) {\n    const json = this.json;\n    const options = this.options;\n    if (!json.scenes) {\n      json.scenes = [];\n      json.scene = 0;\n    }\n    const sceneDef = {};\n    if (scene.name !== \"\")\n      sceneDef.name = scene.name;\n    json.scenes.push(sceneDef);\n    const nodes = [];\n    for (let i = 0, l = scene.children.length; i < l; i++) {\n      const child = scene.children[i];\n      if (child.visible || options.onlyVisible === false) {\n        const nodeIndex = this.processNode(child);\n        if (nodeIndex !== null)\n          nodes.push(nodeIndex);\n      }\n    }\n    if (nodes.length > 0)\n      sceneDef.nodes = nodes;\n    this.serializeUserData(scene, sceneDef);\n  }\n  /**\n   * Creates a Scene to hold a list of objects and parse it\n   * @param  {Array} objects List of objects to process\n   */\n  processObjects(objects) {\n    const scene = new Scene();\n    scene.name = \"AuxScene\";\n    for (let i = 0; i < objects.length; i++) {\n      scene.children.push(objects[i]);\n    }\n    this.processScene(scene);\n  }\n  /**\n   * @param {THREE.Object3D|Array<THREE.Object3D>} input\n   */\n  processInput(input) {\n    const options = this.options;\n    input = input instanceof Array ? input : [input];\n    this._invokeAll(function(ext) {\n      ext.beforeParse && ext.beforeParse(input);\n    });\n    const objectsWithoutScene = [];\n    for (let i = 0; i < input.length; i++) {\n      if (input[i] instanceof Scene) {\n        this.processScene(input[i]);\n      } else {\n        objectsWithoutScene.push(input[i]);\n      }\n    }\n    if (objectsWithoutScene.length > 0)\n      this.processObjects(objectsWithoutScene);\n    for (let i = 0; i < this.skins.length; ++i) {\n      this.processSkin(this.skins[i]);\n    }\n    for (let i = 0; i < options.animations.length; ++i) {\n      this.processAnimation(options.animations[i], input[0]);\n    }\n    this._invokeAll(function(ext) {\n      ext.afterParse && ext.afterParse(input);\n    });\n  }\n  _invokeAll(func) {\n    for (let i = 0, il = this.plugins.length; i < il; i++) {\n      func(this.plugins[i]);\n    }\n  }\n}\nclass GLTFLightExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_lights_punctual\";\n  }\n  writeNode(light, nodeDef) {\n    if (!light.isLight)\n      return;\n    if (!light.isDirectionalLight && !light.isPointLight && !light.isSpotLight) {\n      console.warn(\"THREE.GLTFExporter: Only directional, point, and spot lights are supported.\", light);\n      return;\n    }\n    const writer = this.writer;\n    const json = writer.json;\n    const extensionsUsed = writer.extensionsUsed;\n    const lightDef = {};\n    if (light.name)\n      lightDef.name = light.name;\n    lightDef.color = light.color.toArray();\n    lightDef.intensity = light.intensity;\n    if (light.isDirectionalLight) {\n      lightDef.type = \"directional\";\n    } else if (light.isPointLight) {\n      lightDef.type = \"point\";\n      if (light.distance > 0)\n        lightDef.range = light.distance;\n    } else if (light.isSpotLight) {\n      lightDef.type = \"spot\";\n      if (light.distance > 0)\n        lightDef.range = light.distance;\n      lightDef.spot = {};\n      lightDef.spot.innerConeAngle = (light.penumbra - 1) * light.angle * -1;\n      lightDef.spot.outerConeAngle = light.angle;\n    }\n    if (light.decay !== void 0 && light.decay !== 2) {\n      console.warn(\n        \"THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2.\"\n      );\n    }\n    if (light.target && (light.target.parent !== light || light.target.position.x !== 0 || light.target.position.y !== 0 || light.target.position.z !== -1)) {\n      console.warn(\n        \"THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1.\"\n      );\n    }\n    if (!extensionsUsed[this.name]) {\n      json.extensions = json.extensions || {};\n      json.extensions[this.name] = { lights: [] };\n      extensionsUsed[this.name] = true;\n    }\n    const lights = json.extensions[this.name].lights;\n    lights.push(lightDef);\n    nodeDef.extensions = nodeDef.extensions || {};\n    nodeDef.extensions[this.name] = { light: lights.length - 1 };\n  }\n}\nclass GLTFMaterialsUnlitExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_unlit\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshBasicMaterial)\n      return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = {};\n    extensionsUsed[this.name] = true;\n    materialDef.pbrMetallicRoughness.metallicFactor = 0;\n    materialDef.pbrMetallicRoughness.roughnessFactor = 0.9;\n  }\n}\nclass GLTFMaterialsClearcoatExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_clearcoat\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.clearcoat === 0)\n      return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.clearcoatFactor = material.clearcoat;\n    if (material.clearcoatMap) {\n      const clearcoatMapDef = {\n        index: writer.processTexture(material.clearcoatMap),\n        texCoord: material.clearcoatMap.channel\n      };\n      writer.applyTextureTransform(clearcoatMapDef, material.clearcoatMap);\n      extensionDef.clearcoatTexture = clearcoatMapDef;\n    }\n    extensionDef.clearcoatRoughnessFactor = material.clearcoatRoughness;\n    if (material.clearcoatRoughnessMap) {\n      const clearcoatRoughnessMapDef = {\n        index: writer.processTexture(material.clearcoatRoughnessMap),\n        texCoord: material.clearcoatRoughnessMap.channel\n      };\n      writer.applyTextureTransform(clearcoatRoughnessMapDef, material.clearcoatRoughnessMap);\n      extensionDef.clearcoatRoughnessTexture = clearcoatRoughnessMapDef;\n    }\n    if (material.clearcoatNormalMap) {\n      const clearcoatNormalMapDef = {\n        index: writer.processTexture(material.clearcoatNormalMap),\n        texCoord: material.clearcoatNormalMap.channel\n      };\n      writer.applyTextureTransform(clearcoatNormalMapDef, material.clearcoatNormalMap);\n      extensionDef.clearcoatNormalTexture = clearcoatNormalMapDef;\n    }\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsIridescenceExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_iridescence\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.iridescence === 0)\n      return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.iridescenceFactor = material.iridescence;\n    if (material.iridescenceMap) {\n      const iridescenceMapDef = {\n        index: writer.processTexture(material.iridescenceMap),\n        texCoord: material.iridescenceMap.channel\n      };\n      writer.applyTextureTransform(iridescenceMapDef, material.iridescenceMap);\n      extensionDef.iridescenceTexture = iridescenceMapDef;\n    }\n    extensionDef.iridescenceIor = material.iridescenceIOR;\n    extensionDef.iridescenceThicknessMinimum = material.iridescenceThicknessRange[0];\n    extensionDef.iridescenceThicknessMaximum = material.iridescenceThicknessRange[1];\n    if (material.iridescenceThicknessMap) {\n      const iridescenceThicknessMapDef = {\n        index: writer.processTexture(material.iridescenceThicknessMap),\n        texCoord: material.iridescenceThicknessMap.channel\n      };\n      writer.applyTextureTransform(iridescenceThicknessMapDef, material.iridescenceThicknessMap);\n      extensionDef.iridescenceThicknessTexture = iridescenceThicknessMapDef;\n    }\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsTransmissionExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_transmission\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.transmission === 0)\n      return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.transmissionFactor = material.transmission;\n    if (material.transmissionMap) {\n      const transmissionMapDef = {\n        index: writer.processTexture(material.transmissionMap),\n        texCoord: material.transmissionMap.channel\n      };\n      writer.applyTextureTransform(transmissionMapDef, material.transmissionMap);\n      extensionDef.transmissionTexture = transmissionMapDef;\n    }\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsVolumeExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_volume\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.transmission === 0)\n      return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.thicknessFactor = material.thickness;\n    if (material.thicknessMap) {\n      const thicknessMapDef = {\n        index: writer.processTexture(material.thicknessMap),\n        texCoord: material.thicknessMap.channel\n      };\n      writer.applyTextureTransform(thicknessMapDef, material.thicknessMap);\n      extensionDef.thicknessTexture = thicknessMapDef;\n    }\n    extensionDef.attenuationDistance = material.attenuationDistance;\n    extensionDef.attenuationColor = material.attenuationColor.toArray();\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsIorExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_ior\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.ior === 1.5)\n      return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.ior = material.ior;\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsSpecularExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_specular\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.specularIntensity === 1 && material.specularColor.equals(DEFAULT_SPECULAR_COLOR) && !material.specularIntensityMap && !material.specularColorTexture)\n      return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    if (material.specularIntensityMap) {\n      const specularIntensityMapDef = {\n        index: writer.processTexture(material.specularIntensityMap),\n        texCoord: material.specularIntensityMap.channel\n      };\n      writer.applyTextureTransform(specularIntensityMapDef, material.specularIntensityMap);\n      extensionDef.specularTexture = specularIntensityMapDef;\n    }\n    if (material.specularColorMap) {\n      const specularColorMapDef = {\n        index: writer.processTexture(material.specularColorMap),\n        texCoord: material.specularColorMap.channel\n      };\n      writer.applyTextureTransform(specularColorMapDef, material.specularColorMap);\n      extensionDef.specularColorTexture = specularColorMapDef;\n    }\n    extensionDef.specularFactor = material.specularIntensity;\n    extensionDef.specularColorFactor = material.specularColor.toArray();\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsSheenExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_sheen\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.sheen == 0)\n      return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    if (material.sheenRoughnessMap) {\n      const sheenRoughnessMapDef = {\n        index: writer.processTexture(material.sheenRoughnessMap),\n        texCoord: material.sheenRoughnessMap.channel\n      };\n      writer.applyTextureTransform(sheenRoughnessMapDef, material.sheenRoughnessMap);\n      extensionDef.sheenRoughnessTexture = sheenRoughnessMapDef;\n    }\n    if (material.sheenColorMap) {\n      const sheenColorMapDef = {\n        index: writer.processTexture(material.sheenColorMap),\n        texCoord: material.sheenColorMap.channel\n      };\n      writer.applyTextureTransform(sheenColorMapDef, material.sheenColorMap);\n      extensionDef.sheenColorTexture = sheenColorMapDef;\n    }\n    extensionDef.sheenRoughnessFactor = material.sheenRoughness;\n    extensionDef.sheenColorFactor = material.sheenColor.toArray();\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsAnisotropyExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_anisotropy\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.anisotropy == 0)\n      return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    if (material.anisotropyMap) {\n      const anisotropyMapDef = { index: writer.processTexture(material.anisotropyMap) };\n      writer.applyTextureTransform(anisotropyMapDef, material.anisotropyMap);\n      extensionDef.anisotropyTexture = anisotropyMapDef;\n    }\n    extensionDef.anisotropyStrength = material.anisotropy;\n    extensionDef.anisotropyRotation = material.anisotropyRotation;\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsEmissiveStrengthExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_emissive_strength\";\n  }\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshStandardMaterial || material.emissiveIntensity === 1)\n      return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.emissiveStrength = material.emissiveIntensity;\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nexport {\n  GLTFExporter\n};\n//# sourceMappingURL=GLTFExporter.js.map\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}