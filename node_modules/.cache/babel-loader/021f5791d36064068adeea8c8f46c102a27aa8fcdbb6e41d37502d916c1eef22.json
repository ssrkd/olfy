{"ast":null,"code":"import _objectSpread from \"C:/Users/srk/Documents/GitHub/olfy/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"C:/Users/srk/Documents/GitHub/olfy/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"base\"],\n  _excluded2 = [\"padTo\", \"floor\"];\nimport { hasLocaleWeekInfo, hasRelative, padStart, roundTo, validateWeekSettings } from \"./util.js\";\nimport * as English from \"./english.js\";\nimport Settings from \"../settings.js\";\nimport DateTime from \"../datetime.js\";\nimport IANAZone from \"../zones/IANAZone.js\";\n\n// todo - remap caching\n\nlet intlLFCache = {};\nfunction getCachedLF(locString) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const key = JSON.stringify([locString, opts]);\n  let dtf = intlLFCache[key];\n  if (!dtf) {\n    dtf = new Intl.ListFormat(locString, opts);\n    intlLFCache[key] = dtf;\n  }\n  return dtf;\n}\nconst intlDTCache = new Map();\nfunction getCachedDTF(locString) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const key = JSON.stringify([locString, opts]);\n  let dtf = intlDTCache.get(key);\n  if (dtf === undefined) {\n    dtf = new Intl.DateTimeFormat(locString, opts);\n    intlDTCache.set(key, dtf);\n  }\n  return dtf;\n}\nconst intlNumCache = new Map();\nfunction getCachedINF(locString) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const key = JSON.stringify([locString, opts]);\n  let inf = intlNumCache.get(key);\n  if (inf === undefined) {\n    inf = new Intl.NumberFormat(locString, opts);\n    intlNumCache.set(key, inf);\n  }\n  return inf;\n}\nconst intlRelCache = new Map();\nfunction getCachedRTF(locString) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n      base\n    } = opts,\n    cacheKeyOpts = _objectWithoutProperties(opts, _excluded); // exclude `base` from the options\n  const key = JSON.stringify([locString, cacheKeyOpts]);\n  let inf = intlRelCache.get(key);\n  if (inf === undefined) {\n    inf = new Intl.RelativeTimeFormat(locString, opts);\n    intlRelCache.set(key, inf);\n  }\n  return inf;\n}\nlet sysLocaleCache = null;\nfunction systemLocale() {\n  if (sysLocaleCache) {\n    return sysLocaleCache;\n  } else {\n    sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;\n    return sysLocaleCache;\n  }\n}\nconst intlResolvedOptionsCache = new Map();\nfunction getCachedIntResolvedOptions(locString) {\n  let opts = intlResolvedOptionsCache.get(locString);\n  if (opts === undefined) {\n    opts = new Intl.DateTimeFormat(locString).resolvedOptions();\n    intlResolvedOptionsCache.set(locString, opts);\n  }\n  return opts;\n}\nconst weekInfoCache = new Map();\nfunction getCachedWeekInfo(locString) {\n  let data = weekInfoCache.get(locString);\n  if (!data) {\n    const locale = new Intl.Locale(locString);\n    // browsers currently implement this as a property, but spec says it should be a getter function\n    data = \"getWeekInfo\" in locale ? locale.getWeekInfo() : locale.weekInfo;\n    // minimalDays was removed from WeekInfo: https://github.com/tc39/proposal-intl-locale-info/issues/86\n    if (!(\"minimalDays\" in data)) {\n      data = _objectSpread(_objectSpread({}, fallbackWeekSettings), data);\n    }\n    weekInfoCache.set(locString, data);\n  }\n  return data;\n}\nfunction parseLocaleString(localeStr) {\n  // I really want to avoid writing a BCP 47 parser\n  // see, e.g. https://github.com/wooorm/bcp-47\n  // Instead, we'll do this:\n\n  // a) if the string has no -u extensions, just leave it alone\n  // b) if it does, use Intl to resolve everything\n  // c) if Intl fails, try again without the -u\n\n  // private subtags and unicode subtags have ordering requirements,\n  // and we're not properly parsing this, so just strip out the\n  // private ones if they exist.\n  const xIndex = localeStr.indexOf(\"-x-\");\n  if (xIndex !== -1) {\n    localeStr = localeStr.substring(0, xIndex);\n  }\n  const uIndex = localeStr.indexOf(\"-u-\");\n  if (uIndex === -1) {\n    return [localeStr];\n  } else {\n    let options;\n    let selectedStr;\n    try {\n      options = getCachedDTF(localeStr).resolvedOptions();\n      selectedStr = localeStr;\n    } catch (e) {\n      const smaller = localeStr.substring(0, uIndex);\n      options = getCachedDTF(smaller).resolvedOptions();\n      selectedStr = smaller;\n    }\n    const {\n      numberingSystem,\n      calendar\n    } = options;\n    return [selectedStr, numberingSystem, calendar];\n  }\n}\nfunction intlConfigString(localeStr, numberingSystem, outputCalendar) {\n  if (outputCalendar || numberingSystem) {\n    if (!localeStr.includes(\"-u-\")) {\n      localeStr += \"-u\";\n    }\n    if (outputCalendar) {\n      localeStr += \"-ca-\".concat(outputCalendar);\n    }\n    if (numberingSystem) {\n      localeStr += \"-nu-\".concat(numberingSystem);\n    }\n    return localeStr;\n  } else {\n    return localeStr;\n  }\n}\nfunction mapMonths(f) {\n  const ms = [];\n  for (let i = 1; i <= 12; i++) {\n    const dt = DateTime.utc(2009, i, 1);\n    ms.push(f(dt));\n  }\n  return ms;\n}\nfunction mapWeekdays(f) {\n  const ms = [];\n  for (let i = 1; i <= 7; i++) {\n    const dt = DateTime.utc(2016, 11, 13 + i);\n    ms.push(f(dt));\n  }\n  return ms;\n}\nfunction listStuff(loc, length, englishFn, intlFn) {\n  const mode = loc.listingMode();\n  if (mode === \"error\") {\n    return null;\n  } else if (mode === \"en\") {\n    return englishFn(length);\n  } else {\n    return intlFn(length);\n  }\n}\nfunction supportsFastNumbers(loc) {\n  if (loc.numberingSystem && loc.numberingSystem !== \"latn\") {\n    return false;\n  } else {\n    return loc.numberingSystem === \"latn\" || !loc.locale || loc.locale.startsWith(\"en\") || getCachedIntResolvedOptions(loc.locale).numberingSystem === \"latn\";\n  }\n}\n\n/**\n * @private\n */\n\nclass PolyNumberFormatter {\n  constructor(intl, forceSimple, opts) {\n    this.padTo = opts.padTo || 0;\n    this.floor = opts.floor || false;\n    const {\n        padTo,\n        floor\n      } = opts,\n      otherOpts = _objectWithoutProperties(opts, _excluded2);\n    if (!forceSimple || Object.keys(otherOpts).length > 0) {\n      const intlOpts = _objectSpread({\n        useGrouping: false\n      }, opts);\n      if (opts.padTo > 0) intlOpts.minimumIntegerDigits = opts.padTo;\n      this.inf = getCachedINF(intl, intlOpts);\n    }\n  }\n  format(i) {\n    if (this.inf) {\n      const fixed = this.floor ? Math.floor(i) : i;\n      return this.inf.format(fixed);\n    } else {\n      // to match the browser's numberformatter defaults\n      const fixed = this.floor ? Math.floor(i) : roundTo(i, 3);\n      return padStart(fixed, this.padTo);\n    }\n  }\n}\n\n/**\n * @private\n */\n\nclass PolyDateFormatter {\n  constructor(dt, intl, opts) {\n    this.opts = opts;\n    this.originalZone = undefined;\n    let z = undefined;\n    if (this.opts.timeZone) {\n      // Don't apply any workarounds if a timeZone is explicitly provided in opts\n      this.dt = dt;\n    } else if (dt.zone.type === \"fixed\") {\n      // UTC-8 or Etc/UTC-8 are not part of tzdata, only Etc/GMT+8 and the like.\n      // That is why fixed-offset TZ is set to that unless it is:\n      // 1. Representing offset 0 when UTC is used to maintain previous behavior and does not become GMT.\n      // 2. Unsupported by the browser:\n      //    - some do not support Etc/\n      //    - < Etc/GMT-14, > Etc/GMT+12, and 30-minute or 45-minute offsets are not part of tzdata\n      const gmtOffset = -1 * (dt.offset / 60);\n      const offsetZ = gmtOffset >= 0 ? \"Etc/GMT+\".concat(gmtOffset) : \"Etc/GMT\".concat(gmtOffset);\n      if (dt.offset !== 0 && IANAZone.create(offsetZ).valid) {\n        z = offsetZ;\n        this.dt = dt;\n      } else {\n        // Not all fixed-offset zones like Etc/+4:30 are present in tzdata so\n        // we manually apply the offset and substitute the zone as needed.\n        z = \"UTC\";\n        this.dt = dt.offset === 0 ? dt : dt.setZone(\"UTC\").plus({\n          minutes: dt.offset\n        });\n        this.originalZone = dt.zone;\n      }\n    } else if (dt.zone.type === \"system\") {\n      this.dt = dt;\n    } else if (dt.zone.type === \"iana\") {\n      this.dt = dt;\n      z = dt.zone.name;\n    } else {\n      // Custom zones can have any offset / offsetName so we just manually\n      // apply the offset and substitute the zone as needed.\n      z = \"UTC\";\n      this.dt = dt.setZone(\"UTC\").plus({\n        minutes: dt.offset\n      });\n      this.originalZone = dt.zone;\n    }\n    const intlOpts = _objectSpread({}, this.opts);\n    intlOpts.timeZone = intlOpts.timeZone || z;\n    this.dtf = getCachedDTF(intl, intlOpts);\n  }\n  format() {\n    if (this.originalZone) {\n      // If we have to substitute in the actual zone name, we have to use\n      // formatToParts so that the timezone can be replaced.\n      return this.formatToParts().map(_ref => {\n        let {\n          value\n        } = _ref;\n        return value;\n      }).join(\"\");\n    }\n    return this.dtf.format(this.dt.toJSDate());\n  }\n  formatToParts() {\n    const parts = this.dtf.formatToParts(this.dt.toJSDate());\n    if (this.originalZone) {\n      return parts.map(part => {\n        if (part.type === \"timeZoneName\") {\n          const offsetName = this.originalZone.offsetName(this.dt.ts, {\n            locale: this.dt.locale,\n            format: this.opts.timeZoneName\n          });\n          return _objectSpread(_objectSpread({}, part), {}, {\n            value: offsetName\n          });\n        } else {\n          return part;\n        }\n      });\n    }\n    return parts;\n  }\n  resolvedOptions() {\n    return this.dtf.resolvedOptions();\n  }\n}\n\n/**\n * @private\n */\nclass PolyRelFormatter {\n  constructor(intl, isEnglish, opts) {\n    this.opts = _objectSpread({\n      style: \"long\"\n    }, opts);\n    if (!isEnglish && hasRelative()) {\n      this.rtf = getCachedRTF(intl, opts);\n    }\n  }\n  format(count, unit) {\n    if (this.rtf) {\n      return this.rtf.format(count, unit);\n    } else {\n      return English.formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== \"long\");\n    }\n  }\n  formatToParts(count, unit) {\n    if (this.rtf) {\n      return this.rtf.formatToParts(count, unit);\n    } else {\n      return [];\n    }\n  }\n}\nconst fallbackWeekSettings = {\n  firstDay: 1,\n  minimalDays: 4,\n  weekend: [6, 7]\n};\n\n/**\n * @private\n */\nexport default class Locale {\n  static fromOpts(opts) {\n    return Locale.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.weekSettings, opts.defaultToEN);\n  }\n  static create(locale, numberingSystem, outputCalendar, weekSettings) {\n    let defaultToEN = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    const specifiedLocale = locale || Settings.defaultLocale;\n    // the system locale is useful for human-readable strings but annoying for parsing/formatting known formats\n    const localeR = specifiedLocale || (defaultToEN ? \"en-US\" : systemLocale());\n    const numberingSystemR = numberingSystem || Settings.defaultNumberingSystem;\n    const outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;\n    const weekSettingsR = validateWeekSettings(weekSettings) || Settings.defaultWeekSettings;\n    return new Locale(localeR, numberingSystemR, outputCalendarR, weekSettingsR, specifiedLocale);\n  }\n  static resetCache() {\n    sysLocaleCache = null;\n    intlDTCache.clear();\n    intlNumCache.clear();\n    intlRelCache.clear();\n    intlResolvedOptionsCache.clear();\n    weekInfoCache.clear();\n  }\n  static fromObject() {\n    let {\n      locale,\n      numberingSystem,\n      outputCalendar,\n      weekSettings\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return Locale.create(locale, numberingSystem, outputCalendar, weekSettings);\n  }\n  constructor(locale, numbering, outputCalendar, weekSettings, specifiedLocale) {\n    const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale);\n    this.locale = parsedLocale;\n    this.numberingSystem = numbering || parsedNumberingSystem || null;\n    this.outputCalendar = outputCalendar || parsedOutputCalendar || null;\n    this.weekSettings = weekSettings;\n    this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);\n    this.weekdaysCache = {\n      format: {},\n      standalone: {}\n    };\n    this.monthsCache = {\n      format: {},\n      standalone: {}\n    };\n    this.meridiemCache = null;\n    this.eraCache = {};\n    this.specifiedLocale = specifiedLocale;\n    this.fastNumbersCached = null;\n  }\n  get fastNumbers() {\n    if (this.fastNumbersCached == null) {\n      this.fastNumbersCached = supportsFastNumbers(this);\n    }\n    return this.fastNumbersCached;\n  }\n  listingMode() {\n    const isActuallyEn = this.isEnglish();\n    const hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === \"latn\") && (this.outputCalendar === null || this.outputCalendar === \"gregory\");\n    return isActuallyEn && hasNoWeirdness ? \"en\" : \"intl\";\n  }\n  clone(alts) {\n    if (!alts || Object.getOwnPropertyNames(alts).length === 0) {\n      return this;\n    } else {\n      return Locale.create(alts.locale || this.specifiedLocale, alts.numberingSystem || this.numberingSystem, alts.outputCalendar || this.outputCalendar, validateWeekSettings(alts.weekSettings) || this.weekSettings, alts.defaultToEN || false);\n    }\n  }\n  redefaultToEN() {\n    let alts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this.clone(_objectSpread(_objectSpread({}, alts), {}, {\n      defaultToEN: true\n    }));\n  }\n  redefaultToSystem() {\n    let alts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this.clone(_objectSpread(_objectSpread({}, alts), {}, {\n      defaultToEN: false\n    }));\n  }\n  months(length) {\n    let format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return listStuff(this, length, English.months, () => {\n      const intl = format ? {\n          month: length,\n          day: \"numeric\"\n        } : {\n          month: length\n        },\n        formatStr = format ? \"format\" : \"standalone\";\n      if (!this.monthsCache[formatStr][length]) {\n        this.monthsCache[formatStr][length] = mapMonths(dt => this.extract(dt, intl, \"month\"));\n      }\n      return this.monthsCache[formatStr][length];\n    });\n  }\n  weekdays(length) {\n    let format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return listStuff(this, length, English.weekdays, () => {\n      const intl = format ? {\n          weekday: length,\n          year: \"numeric\",\n          month: \"long\",\n          day: \"numeric\"\n        } : {\n          weekday: length\n        },\n        formatStr = format ? \"format\" : \"standalone\";\n      if (!this.weekdaysCache[formatStr][length]) {\n        this.weekdaysCache[formatStr][length] = mapWeekdays(dt => this.extract(dt, intl, \"weekday\"));\n      }\n      return this.weekdaysCache[formatStr][length];\n    });\n  }\n  meridiems() {\n    return listStuff(this, undefined, () => English.meridiems, () => {\n      // In theory there could be aribitrary day periods. We're gonna assume there are exactly two\n      // for AM and PM. This is probably wrong, but it's makes parsing way easier.\n      if (!this.meridiemCache) {\n        const intl = {\n          hour: \"numeric\",\n          hourCycle: \"h12\"\n        };\n        this.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map(dt => this.extract(dt, intl, \"dayperiod\"));\n      }\n      return this.meridiemCache;\n    });\n  }\n  eras(length) {\n    return listStuff(this, length, English.eras, () => {\n      const intl = {\n        era: length\n      };\n\n      // This is problematic. Different calendars are going to define eras totally differently. What I need is the minimum set of dates\n      // to definitely enumerate them.\n      if (!this.eraCache[length]) {\n        this.eraCache[length] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map(dt => this.extract(dt, intl, \"era\"));\n      }\n      return this.eraCache[length];\n    });\n  }\n  extract(dt, intlOpts, field) {\n    const df = this.dtFormatter(dt, intlOpts),\n      results = df.formatToParts(),\n      matching = results.find(m => m.type.toLowerCase() === field);\n    return matching ? matching.value : null;\n  }\n  numberFormatter() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // this forcesimple option is never used (the only caller short-circuits on it, but it seems safer to leave)\n    // (in contrast, the rest of the condition is used heavily)\n    return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);\n  }\n  dtFormatter(dt) {\n    let intlOpts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return new PolyDateFormatter(dt, this.intl, intlOpts);\n  }\n  relFormatter() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return new PolyRelFormatter(this.intl, this.isEnglish(), opts);\n  }\n  listFormatter() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return getCachedLF(this.intl, opts);\n  }\n  isEnglish() {\n    return this.locale === \"en\" || this.locale.toLowerCase() === \"en-us\" || getCachedIntResolvedOptions(this.intl).locale.startsWith(\"en-us\");\n  }\n  getWeekSettings() {\n    if (this.weekSettings) {\n      return this.weekSettings;\n    } else if (!hasLocaleWeekInfo()) {\n      return fallbackWeekSettings;\n    } else {\n      return getCachedWeekInfo(this.locale);\n    }\n  }\n  getStartOfWeek() {\n    return this.getWeekSettings().firstDay;\n  }\n  getMinDaysInFirstWeek() {\n    return this.getWeekSettings().minimalDays;\n  }\n  getWeekendDays() {\n    return this.getWeekSettings().weekend;\n  }\n  equals(other) {\n    return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;\n  }\n  toString() {\n    return \"Locale(\".concat(this.locale, \", \").concat(this.numberingSystem, \", \").concat(this.outputCalendar, \")\");\n  }\n}","map":{"version":3,"names":["hasLocaleWeekInfo","hasRelative","padStart","roundTo","validateWeekSettings","English","Settings","DateTime","IANAZone","intlLFCache","getCachedLF","locString","opts","arguments","length","undefined","key","JSON","stringify","dtf","Intl","ListFormat","intlDTCache","Map","getCachedDTF","get","DateTimeFormat","set","intlNumCache","getCachedINF","inf","NumberFormat","intlRelCache","getCachedRTF","base","cacheKeyOpts","_objectWithoutProperties","_excluded","RelativeTimeFormat","sysLocaleCache","systemLocale","resolvedOptions","locale","intlResolvedOptionsCache","getCachedIntResolvedOptions","weekInfoCache","getCachedWeekInfo","data","Locale","getWeekInfo","weekInfo","_objectSpread","fallbackWeekSettings","parseLocaleString","localeStr","xIndex","indexOf","substring","uIndex","options","selectedStr","e","smaller","numberingSystem","calendar","intlConfigString","outputCalendar","includes","concat","mapMonths","f","ms","i","dt","utc","push","mapWeekdays","listStuff","loc","englishFn","intlFn","mode","listingMode","supportsFastNumbers","startsWith","PolyNumberFormatter","constructor","intl","forceSimple","padTo","floor","otherOpts","_excluded2","Object","keys","intlOpts","useGrouping","minimumIntegerDigits","format","fixed","Math","PolyDateFormatter","originalZone","z","timeZone","zone","type","gmtOffset","offset","offsetZ","create","valid","setZone","plus","minutes","name","formatToParts","map","_ref","value","join","toJSDate","parts","part","offsetName","ts","timeZoneName","PolyRelFormatter","isEnglish","style","rtf","count","unit","formatRelativeTime","numeric","firstDay","minimalDays","weekend","fromOpts","weekSettings","defaultToEN","specifiedLocale","defaultLocale","localeR","numberingSystemR","defaultNumberingSystem","outputCalendarR","defaultOutputCalendar","weekSettingsR","defaultWeekSettings","resetCache","clear","fromObject","numbering","parsedLocale","parsedNumberingSystem","parsedOutputCalendar","weekdaysCache","standalone","monthsCache","meridiemCache","eraCache","fastNumbersCached","fastNumbers","isActuallyEn","hasNoWeirdness","clone","alts","getOwnPropertyNames","redefaultToEN","redefaultToSystem","months","month","day","formatStr","extract","weekdays","weekday","year","meridiems","hour","hourCycle","eras","era","field","df","dtFormatter","results","matching","find","m","toLowerCase","numberFormatter","relFormatter","listFormatter","getWeekSettings","getStartOfWeek","getMinDaysInFirstWeek","getWeekendDays","equals","other","toString"],"sources":["C:/Users/srk/Documents/GitHub/olfy/node_modules/luxon/src/impl/locale.js"],"sourcesContent":["import { hasLocaleWeekInfo, hasRelative, padStart, roundTo, validateWeekSettings } from \"./util.js\";\nimport * as English from \"./english.js\";\nimport Settings from \"../settings.js\";\nimport DateTime from \"../datetime.js\";\nimport IANAZone from \"../zones/IANAZone.js\";\n\n// todo - remap caching\n\nlet intlLFCache = {};\nfunction getCachedLF(locString, opts = {}) {\n  const key = JSON.stringify([locString, opts]);\n  let dtf = intlLFCache[key];\n  if (!dtf) {\n    dtf = new Intl.ListFormat(locString, opts);\n    intlLFCache[key] = dtf;\n  }\n  return dtf;\n}\n\nconst intlDTCache = new Map();\nfunction getCachedDTF(locString, opts = {}) {\n  const key = JSON.stringify([locString, opts]);\n  let dtf = intlDTCache.get(key);\n  if (dtf === undefined) {\n    dtf = new Intl.DateTimeFormat(locString, opts);\n    intlDTCache.set(key, dtf);\n  }\n  return dtf;\n}\n\nconst intlNumCache = new Map();\nfunction getCachedINF(locString, opts = {}) {\n  const key = JSON.stringify([locString, opts]);\n  let inf = intlNumCache.get(key);\n  if (inf === undefined) {\n    inf = new Intl.NumberFormat(locString, opts);\n    intlNumCache.set(key, inf);\n  }\n  return inf;\n}\n\nconst intlRelCache = new Map();\nfunction getCachedRTF(locString, opts = {}) {\n  const { base, ...cacheKeyOpts } = opts; // exclude `base` from the options\n  const key = JSON.stringify([locString, cacheKeyOpts]);\n  let inf = intlRelCache.get(key);\n  if (inf === undefined) {\n    inf = new Intl.RelativeTimeFormat(locString, opts);\n    intlRelCache.set(key, inf);\n  }\n  return inf;\n}\n\nlet sysLocaleCache = null;\nfunction systemLocale() {\n  if (sysLocaleCache) {\n    return sysLocaleCache;\n  } else {\n    sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;\n    return sysLocaleCache;\n  }\n}\n\nconst intlResolvedOptionsCache = new Map();\nfunction getCachedIntResolvedOptions(locString) {\n  let opts = intlResolvedOptionsCache.get(locString);\n  if (opts === undefined) {\n    opts = new Intl.DateTimeFormat(locString).resolvedOptions();\n    intlResolvedOptionsCache.set(locString, opts);\n  }\n  return opts;\n}\n\nconst weekInfoCache = new Map();\nfunction getCachedWeekInfo(locString) {\n  let data = weekInfoCache.get(locString);\n  if (!data) {\n    const locale = new Intl.Locale(locString);\n    // browsers currently implement this as a property, but spec says it should be a getter function\n    data = \"getWeekInfo\" in locale ? locale.getWeekInfo() : locale.weekInfo;\n    // minimalDays was removed from WeekInfo: https://github.com/tc39/proposal-intl-locale-info/issues/86\n    if (!(\"minimalDays\" in data)) {\n      data = { ...fallbackWeekSettings, ...data };\n    }\n    weekInfoCache.set(locString, data);\n  }\n  return data;\n}\n\nfunction parseLocaleString(localeStr) {\n  // I really want to avoid writing a BCP 47 parser\n  // see, e.g. https://github.com/wooorm/bcp-47\n  // Instead, we'll do this:\n\n  // a) if the string has no -u extensions, just leave it alone\n  // b) if it does, use Intl to resolve everything\n  // c) if Intl fails, try again without the -u\n\n  // private subtags and unicode subtags have ordering requirements,\n  // and we're not properly parsing this, so just strip out the\n  // private ones if they exist.\n  const xIndex = localeStr.indexOf(\"-x-\");\n  if (xIndex !== -1) {\n    localeStr = localeStr.substring(0, xIndex);\n  }\n\n  const uIndex = localeStr.indexOf(\"-u-\");\n  if (uIndex === -1) {\n    return [localeStr];\n  } else {\n    let options;\n    let selectedStr;\n    try {\n      options = getCachedDTF(localeStr).resolvedOptions();\n      selectedStr = localeStr;\n    } catch (e) {\n      const smaller = localeStr.substring(0, uIndex);\n      options = getCachedDTF(smaller).resolvedOptions();\n      selectedStr = smaller;\n    }\n\n    const { numberingSystem, calendar } = options;\n    return [selectedStr, numberingSystem, calendar];\n  }\n}\n\nfunction intlConfigString(localeStr, numberingSystem, outputCalendar) {\n  if (outputCalendar || numberingSystem) {\n    if (!localeStr.includes(\"-u-\")) {\n      localeStr += \"-u\";\n    }\n\n    if (outputCalendar) {\n      localeStr += `-ca-${outputCalendar}`;\n    }\n\n    if (numberingSystem) {\n      localeStr += `-nu-${numberingSystem}`;\n    }\n    return localeStr;\n  } else {\n    return localeStr;\n  }\n}\n\nfunction mapMonths(f) {\n  const ms = [];\n  for (let i = 1; i <= 12; i++) {\n    const dt = DateTime.utc(2009, i, 1);\n    ms.push(f(dt));\n  }\n  return ms;\n}\n\nfunction mapWeekdays(f) {\n  const ms = [];\n  for (let i = 1; i <= 7; i++) {\n    const dt = DateTime.utc(2016, 11, 13 + i);\n    ms.push(f(dt));\n  }\n  return ms;\n}\n\nfunction listStuff(loc, length, englishFn, intlFn) {\n  const mode = loc.listingMode();\n\n  if (mode === \"error\") {\n    return null;\n  } else if (mode === \"en\") {\n    return englishFn(length);\n  } else {\n    return intlFn(length);\n  }\n}\n\nfunction supportsFastNumbers(loc) {\n  if (loc.numberingSystem && loc.numberingSystem !== \"latn\") {\n    return false;\n  } else {\n    return (\n      loc.numberingSystem === \"latn\" ||\n      !loc.locale ||\n      loc.locale.startsWith(\"en\") ||\n      getCachedIntResolvedOptions(loc.locale).numberingSystem === \"latn\"\n    );\n  }\n}\n\n/**\n * @private\n */\n\nclass PolyNumberFormatter {\n  constructor(intl, forceSimple, opts) {\n    this.padTo = opts.padTo || 0;\n    this.floor = opts.floor || false;\n\n    const { padTo, floor, ...otherOpts } = opts;\n\n    if (!forceSimple || Object.keys(otherOpts).length > 0) {\n      const intlOpts = { useGrouping: false, ...opts };\n      if (opts.padTo > 0) intlOpts.minimumIntegerDigits = opts.padTo;\n      this.inf = getCachedINF(intl, intlOpts);\n    }\n  }\n\n  format(i) {\n    if (this.inf) {\n      const fixed = this.floor ? Math.floor(i) : i;\n      return this.inf.format(fixed);\n    } else {\n      // to match the browser's numberformatter defaults\n      const fixed = this.floor ? Math.floor(i) : roundTo(i, 3);\n      return padStart(fixed, this.padTo);\n    }\n  }\n}\n\n/**\n * @private\n */\n\nclass PolyDateFormatter {\n  constructor(dt, intl, opts) {\n    this.opts = opts;\n    this.originalZone = undefined;\n\n    let z = undefined;\n    if (this.opts.timeZone) {\n      // Don't apply any workarounds if a timeZone is explicitly provided in opts\n      this.dt = dt;\n    } else if (dt.zone.type === \"fixed\") {\n      // UTC-8 or Etc/UTC-8 are not part of tzdata, only Etc/GMT+8 and the like.\n      // That is why fixed-offset TZ is set to that unless it is:\n      // 1. Representing offset 0 when UTC is used to maintain previous behavior and does not become GMT.\n      // 2. Unsupported by the browser:\n      //    - some do not support Etc/\n      //    - < Etc/GMT-14, > Etc/GMT+12, and 30-minute or 45-minute offsets are not part of tzdata\n      const gmtOffset = -1 * (dt.offset / 60);\n      const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;\n      if (dt.offset !== 0 && IANAZone.create(offsetZ).valid) {\n        z = offsetZ;\n        this.dt = dt;\n      } else {\n        // Not all fixed-offset zones like Etc/+4:30 are present in tzdata so\n        // we manually apply the offset and substitute the zone as needed.\n        z = \"UTC\";\n        this.dt = dt.offset === 0 ? dt : dt.setZone(\"UTC\").plus({ minutes: dt.offset });\n        this.originalZone = dt.zone;\n      }\n    } else if (dt.zone.type === \"system\") {\n      this.dt = dt;\n    } else if (dt.zone.type === \"iana\") {\n      this.dt = dt;\n      z = dt.zone.name;\n    } else {\n      // Custom zones can have any offset / offsetName so we just manually\n      // apply the offset and substitute the zone as needed.\n      z = \"UTC\";\n      this.dt = dt.setZone(\"UTC\").plus({ minutes: dt.offset });\n      this.originalZone = dt.zone;\n    }\n\n    const intlOpts = { ...this.opts };\n    intlOpts.timeZone = intlOpts.timeZone || z;\n    this.dtf = getCachedDTF(intl, intlOpts);\n  }\n\n  format() {\n    if (this.originalZone) {\n      // If we have to substitute in the actual zone name, we have to use\n      // formatToParts so that the timezone can be replaced.\n      return this.formatToParts()\n        .map(({ value }) => value)\n        .join(\"\");\n    }\n    return this.dtf.format(this.dt.toJSDate());\n  }\n\n  formatToParts() {\n    const parts = this.dtf.formatToParts(this.dt.toJSDate());\n    if (this.originalZone) {\n      return parts.map((part) => {\n        if (part.type === \"timeZoneName\") {\n          const offsetName = this.originalZone.offsetName(this.dt.ts, {\n            locale: this.dt.locale,\n            format: this.opts.timeZoneName,\n          });\n          return {\n            ...part,\n            value: offsetName,\n          };\n        } else {\n          return part;\n        }\n      });\n    }\n    return parts;\n  }\n\n  resolvedOptions() {\n    return this.dtf.resolvedOptions();\n  }\n}\n\n/**\n * @private\n */\nclass PolyRelFormatter {\n  constructor(intl, isEnglish, opts) {\n    this.opts = { style: \"long\", ...opts };\n    if (!isEnglish && hasRelative()) {\n      this.rtf = getCachedRTF(intl, opts);\n    }\n  }\n\n  format(count, unit) {\n    if (this.rtf) {\n      return this.rtf.format(count, unit);\n    } else {\n      return English.formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== \"long\");\n    }\n  }\n\n  formatToParts(count, unit) {\n    if (this.rtf) {\n      return this.rtf.formatToParts(count, unit);\n    } else {\n      return [];\n    }\n  }\n}\n\nconst fallbackWeekSettings = {\n  firstDay: 1,\n  minimalDays: 4,\n  weekend: [6, 7],\n};\n\n/**\n * @private\n */\nexport default class Locale {\n  static fromOpts(opts) {\n    return Locale.create(\n      opts.locale,\n      opts.numberingSystem,\n      opts.outputCalendar,\n      opts.weekSettings,\n      opts.defaultToEN\n    );\n  }\n\n  static create(locale, numberingSystem, outputCalendar, weekSettings, defaultToEN = false) {\n    const specifiedLocale = locale || Settings.defaultLocale;\n    // the system locale is useful for human-readable strings but annoying for parsing/formatting known formats\n    const localeR = specifiedLocale || (defaultToEN ? \"en-US\" : systemLocale());\n    const numberingSystemR = numberingSystem || Settings.defaultNumberingSystem;\n    const outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;\n    const weekSettingsR = validateWeekSettings(weekSettings) || Settings.defaultWeekSettings;\n    return new Locale(localeR, numberingSystemR, outputCalendarR, weekSettingsR, specifiedLocale);\n  }\n\n  static resetCache() {\n    sysLocaleCache = null;\n    intlDTCache.clear();\n    intlNumCache.clear();\n    intlRelCache.clear();\n    intlResolvedOptionsCache.clear();\n    weekInfoCache.clear();\n  }\n\n  static fromObject({ locale, numberingSystem, outputCalendar, weekSettings } = {}) {\n    return Locale.create(locale, numberingSystem, outputCalendar, weekSettings);\n  }\n\n  constructor(locale, numbering, outputCalendar, weekSettings, specifiedLocale) {\n    const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale);\n\n    this.locale = parsedLocale;\n    this.numberingSystem = numbering || parsedNumberingSystem || null;\n    this.outputCalendar = outputCalendar || parsedOutputCalendar || null;\n    this.weekSettings = weekSettings;\n    this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);\n\n    this.weekdaysCache = { format: {}, standalone: {} };\n    this.monthsCache = { format: {}, standalone: {} };\n    this.meridiemCache = null;\n    this.eraCache = {};\n\n    this.specifiedLocale = specifiedLocale;\n    this.fastNumbersCached = null;\n  }\n\n  get fastNumbers() {\n    if (this.fastNumbersCached == null) {\n      this.fastNumbersCached = supportsFastNumbers(this);\n    }\n\n    return this.fastNumbersCached;\n  }\n\n  listingMode() {\n    const isActuallyEn = this.isEnglish();\n    const hasNoWeirdness =\n      (this.numberingSystem === null || this.numberingSystem === \"latn\") &&\n      (this.outputCalendar === null || this.outputCalendar === \"gregory\");\n    return isActuallyEn && hasNoWeirdness ? \"en\" : \"intl\";\n  }\n\n  clone(alts) {\n    if (!alts || Object.getOwnPropertyNames(alts).length === 0) {\n      return this;\n    } else {\n      return Locale.create(\n        alts.locale || this.specifiedLocale,\n        alts.numberingSystem || this.numberingSystem,\n        alts.outputCalendar || this.outputCalendar,\n        validateWeekSettings(alts.weekSettings) || this.weekSettings,\n        alts.defaultToEN || false\n      );\n    }\n  }\n\n  redefaultToEN(alts = {}) {\n    return this.clone({ ...alts, defaultToEN: true });\n  }\n\n  redefaultToSystem(alts = {}) {\n    return this.clone({ ...alts, defaultToEN: false });\n  }\n\n  months(length, format = false) {\n    return listStuff(this, length, English.months, () => {\n      const intl = format ? { month: length, day: \"numeric\" } : { month: length },\n        formatStr = format ? \"format\" : \"standalone\";\n      if (!this.monthsCache[formatStr][length]) {\n        this.monthsCache[formatStr][length] = mapMonths((dt) => this.extract(dt, intl, \"month\"));\n      }\n      return this.monthsCache[formatStr][length];\n    });\n  }\n\n  weekdays(length, format = false) {\n    return listStuff(this, length, English.weekdays, () => {\n      const intl = format\n          ? { weekday: length, year: \"numeric\", month: \"long\", day: \"numeric\" }\n          : { weekday: length },\n        formatStr = format ? \"format\" : \"standalone\";\n      if (!this.weekdaysCache[formatStr][length]) {\n        this.weekdaysCache[formatStr][length] = mapWeekdays((dt) =>\n          this.extract(dt, intl, \"weekday\")\n        );\n      }\n      return this.weekdaysCache[formatStr][length];\n    });\n  }\n\n  meridiems() {\n    return listStuff(\n      this,\n      undefined,\n      () => English.meridiems,\n      () => {\n        // In theory there could be aribitrary day periods. We're gonna assume there are exactly two\n        // for AM and PM. This is probably wrong, but it's makes parsing way easier.\n        if (!this.meridiemCache) {\n          const intl = { hour: \"numeric\", hourCycle: \"h12\" };\n          this.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map(\n            (dt) => this.extract(dt, intl, \"dayperiod\")\n          );\n        }\n\n        return this.meridiemCache;\n      }\n    );\n  }\n\n  eras(length) {\n    return listStuff(this, length, English.eras, () => {\n      const intl = { era: length };\n\n      // This is problematic. Different calendars are going to define eras totally differently. What I need is the minimum set of dates\n      // to definitely enumerate them.\n      if (!this.eraCache[length]) {\n        this.eraCache[length] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map((dt) =>\n          this.extract(dt, intl, \"era\")\n        );\n      }\n\n      return this.eraCache[length];\n    });\n  }\n\n  extract(dt, intlOpts, field) {\n    const df = this.dtFormatter(dt, intlOpts),\n      results = df.formatToParts(),\n      matching = results.find((m) => m.type.toLowerCase() === field);\n    return matching ? matching.value : null;\n  }\n\n  numberFormatter(opts = {}) {\n    // this forcesimple option is never used (the only caller short-circuits on it, but it seems safer to leave)\n    // (in contrast, the rest of the condition is used heavily)\n    return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);\n  }\n\n  dtFormatter(dt, intlOpts = {}) {\n    return new PolyDateFormatter(dt, this.intl, intlOpts);\n  }\n\n  relFormatter(opts = {}) {\n    return new PolyRelFormatter(this.intl, this.isEnglish(), opts);\n  }\n\n  listFormatter(opts = {}) {\n    return getCachedLF(this.intl, opts);\n  }\n\n  isEnglish() {\n    return (\n      this.locale === \"en\" ||\n      this.locale.toLowerCase() === \"en-us\" ||\n      getCachedIntResolvedOptions(this.intl).locale.startsWith(\"en-us\")\n    );\n  }\n\n  getWeekSettings() {\n    if (this.weekSettings) {\n      return this.weekSettings;\n    } else if (!hasLocaleWeekInfo()) {\n      return fallbackWeekSettings;\n    } else {\n      return getCachedWeekInfo(this.locale);\n    }\n  }\n\n  getStartOfWeek() {\n    return this.getWeekSettings().firstDay;\n  }\n\n  getMinDaysInFirstWeek() {\n    return this.getWeekSettings().minimalDays;\n  }\n\n  getWeekendDays() {\n    return this.getWeekSettings().weekend;\n  }\n\n  equals(other) {\n    return (\n      this.locale === other.locale &&\n      this.numberingSystem === other.numberingSystem &&\n      this.outputCalendar === other.outputCalendar\n    );\n  }\n\n  toString() {\n    return `Locale(${this.locale}, ${this.numberingSystem}, ${this.outputCalendar})`;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}