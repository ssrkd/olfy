{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Mesh, Matrix4, Vector2, Color, Vector3, PerspectiveCamera, DepthTexture, UnsignedShortType, NearestFilter, WebGLRenderTarget, ShaderMaterial, UniformsUtils, Plane, HalfFloatType } from \"three\";\nconst ReflectorForSSRPass = /* @__PURE__ */(() => {\n  const _ReflectorForSSRPass = class extends Mesh {\n    constructor(geometry, options = {}) {\n      super(geometry);\n      this.isReflectorForSSRPass = true;\n      this.type = \"ReflectorForSSRPass\";\n      const scope = this;\n      const color = options.color !== void 0 ? new Color(options.color) : new Color(8355711);\n      const textureWidth = options.textureWidth || 512;\n      const textureHeight = options.textureHeight || 512;\n      const clipBias = options.clipBias || 0;\n      const shader = options.shader || _ReflectorForSSRPass.ReflectorShader;\n      const useDepthTexture = options.useDepthTexture === true;\n      const yAxis = new Vector3(0, 1, 0);\n      const vecTemp0 = new Vector3();\n      const vecTemp1 = new Vector3();\n      scope.needsUpdate = false;\n      scope.maxDistance = _ReflectorForSSRPass.ReflectorShader.uniforms.maxDistance.value;\n      scope.opacity = _ReflectorForSSRPass.ReflectorShader.uniforms.opacity.value;\n      scope.color = color;\n      scope.resolution = options.resolution || new Vector2(window.innerWidth, window.innerHeight);\n      scope._distanceAttenuation = _ReflectorForSSRPass.ReflectorShader.defines.DISTANCE_ATTENUATION;\n      Object.defineProperty(scope, \"distanceAttenuation\", {\n        get() {\n          return scope._distanceAttenuation;\n        },\n        set(val) {\n          if (scope._distanceAttenuation === val) return;\n          scope._distanceAttenuation = val;\n          scope.material.defines.DISTANCE_ATTENUATION = val;\n          scope.material.needsUpdate = true;\n        }\n      });\n      scope._fresnel = _ReflectorForSSRPass.ReflectorShader.defines.FRESNEL;\n      Object.defineProperty(scope, \"fresnel\", {\n        get() {\n          return scope._fresnel;\n        },\n        set(val) {\n          if (scope._fresnel === val) return;\n          scope._fresnel = val;\n          scope.material.defines.FRESNEL = val;\n          scope.material.needsUpdate = true;\n        }\n      });\n      const normal = new Vector3();\n      const reflectorWorldPosition = new Vector3();\n      const cameraWorldPosition = new Vector3();\n      const rotationMatrix = new Matrix4();\n      const lookAtPosition = new Vector3(0, 0, -1);\n      const view = new Vector3();\n      const target = new Vector3();\n      const textureMatrix = new Matrix4();\n      const virtualCamera = new PerspectiveCamera();\n      let depthTexture;\n      if (useDepthTexture) {\n        depthTexture = new DepthTexture();\n        depthTexture.type = UnsignedShortType;\n        depthTexture.minFilter = NearestFilter;\n        depthTexture.magFilter = NearestFilter;\n      }\n      const parameters = {\n        depthTexture: useDepthTexture ? depthTexture : null,\n        type: HalfFloatType\n      };\n      const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, parameters);\n      const material = new ShaderMaterial({\n        transparent: useDepthTexture,\n        defines: Object.assign({}, _ReflectorForSSRPass.ReflectorShader.defines, {\n          useDepthTexture\n        }),\n        uniforms: UniformsUtils.clone(shader.uniforms),\n        fragmentShader: shader.fragmentShader,\n        vertexShader: shader.vertexShader\n      });\n      material.uniforms[\"tDiffuse\"].value = renderTarget.texture;\n      material.uniforms[\"color\"].value = scope.color;\n      material.uniforms[\"textureMatrix\"].value = textureMatrix;\n      if (useDepthTexture) {\n        material.uniforms[\"tDepth\"].value = renderTarget.depthTexture;\n      }\n      this.material = material;\n      const globalPlane = new Plane(new Vector3(0, 1, 0), clipBias);\n      const globalPlanes = [globalPlane];\n      this.doRender = function (renderer, scene, camera) {\n        material.uniforms[\"maxDistance\"].value = scope.maxDistance;\n        material.uniforms[\"color\"].value = scope.color;\n        material.uniforms[\"opacity\"].value = scope.opacity;\n        vecTemp0.copy(camera.position).normalize();\n        vecTemp1.copy(vecTemp0).reflect(yAxis);\n        material.uniforms[\"fresnelCoe\"].value = (vecTemp0.dot(vecTemp1) + 1) / 2;\n        reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n        cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n        rotationMatrix.extractRotation(scope.matrixWorld);\n        normal.set(0, 0, 1);\n        normal.applyMatrix4(rotationMatrix);\n        view.subVectors(reflectorWorldPosition, cameraWorldPosition);\n        if (view.dot(normal) > 0) return;\n        view.reflect(normal).negate();\n        view.add(reflectorWorldPosition);\n        rotationMatrix.extractRotation(camera.matrixWorld);\n        lookAtPosition.set(0, 0, -1);\n        lookAtPosition.applyMatrix4(rotationMatrix);\n        lookAtPosition.add(cameraWorldPosition);\n        target.subVectors(reflectorWorldPosition, lookAtPosition);\n        target.reflect(normal).negate();\n        target.add(reflectorWorldPosition);\n        virtualCamera.position.copy(view);\n        virtualCamera.up.set(0, 1, 0);\n        virtualCamera.up.applyMatrix4(rotationMatrix);\n        virtualCamera.up.reflect(normal);\n        virtualCamera.lookAt(target);\n        virtualCamera.far = camera.far;\n        virtualCamera.updateMatrixWorld();\n        virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n        material.uniforms[\"virtualCameraNear\"].value = camera.near;\n        material.uniforms[\"virtualCameraFar\"].value = camera.far;\n        material.uniforms[\"virtualCameraMatrixWorld\"].value = virtualCamera.matrixWorld;\n        material.uniforms[\"virtualCameraProjectionMatrix\"].value = camera.projectionMatrix;\n        material.uniforms[\"virtualCameraProjectionMatrixInverse\"].value = camera.projectionMatrixInverse;\n        material.uniforms[\"resolution\"].value = scope.resolution;\n        textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);\n        textureMatrix.multiply(virtualCamera.projectionMatrix);\n        textureMatrix.multiply(virtualCamera.matrixWorldInverse);\n        textureMatrix.multiply(scope.matrixWorld);\n        const currentRenderTarget = renderer.getRenderTarget();\n        const currentXrEnabled = renderer.xr.enabled;\n        const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n        const currentClippingPlanes = renderer.clippingPlanes;\n        renderer.xr.enabled = false;\n        renderer.shadowMap.autoUpdate = false;\n        renderer.clippingPlanes = globalPlanes;\n        renderer.setRenderTarget(renderTarget);\n        renderer.state.buffers.depth.setMask(true);\n        if (renderer.autoClear === false) renderer.clear();\n        renderer.render(scene, virtualCamera);\n        renderer.xr.enabled = currentXrEnabled;\n        renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n        renderer.clippingPlanes = currentClippingPlanes;\n        renderer.setRenderTarget(currentRenderTarget);\n        const viewport = camera.viewport;\n        if (viewport !== void 0) {\n          renderer.state.viewport(viewport);\n        }\n      };\n      this.getRenderTarget = function () {\n        return renderTarget;\n      };\n    }\n  };\n  let ReflectorForSSRPass2 = _ReflectorForSSRPass;\n  __publicField(ReflectorForSSRPass2, \"ReflectorShader\", {\n    defines: {\n      DISTANCE_ATTENUATION: true,\n      FRESNEL: true\n    },\n    uniforms: {\n      color: {\n        value: null\n      },\n      tDiffuse: {\n        value: null\n      },\n      tDepth: {\n        value: null\n      },\n      textureMatrix: {\n        value: new Matrix4()\n      },\n      maxDistance: {\n        value: 180\n      },\n      opacity: {\n        value: 0.5\n      },\n      fresnelCoe: {\n        value: null\n      },\n      virtualCameraNear: {\n        value: null\n      },\n      virtualCameraFar: {\n        value: null\n      },\n      virtualCameraProjectionMatrix: {\n        value: new Matrix4()\n      },\n      virtualCameraMatrixWorld: {\n        value: new Matrix4()\n      },\n      virtualCameraProjectionMatrixInverse: {\n        value: new Matrix4()\n      },\n      resolution: {\n        value: new Vector2()\n      }\n    },\n    vertexShader: (/* glsl */\n    `\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`),\n    fragmentShader: (/* glsl */\n    `\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform sampler2D tDepth;\n\t\tuniform float maxDistance;\n\t\tuniform float opacity;\n\t\tuniform float fresnelCoe;\n\t\tuniform float virtualCameraNear;\n\t\tuniform float virtualCameraFar;\n\t\tuniform mat4 virtualCameraProjectionMatrix;\n\t\tuniform mat4 virtualCameraProjectionMatrixInverse;\n\t\tuniform mat4 virtualCameraMatrixWorld;\n\t\tuniform vec2 resolution;\n\t\tvarying vec4 vUv;\n\t\t#include <packing>\n\t\tfloat blendOverlay( float base, float blend ) {\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\t\t}\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\t\t}\n\t\tfloat getDepth( const in vec2 uv ) {\n\t\t\treturn texture2D( tDepth, uv ).x;\n\t\t}\n\t\tfloat getViewZ( const in float depth ) {\n\t\t\treturn perspectiveDepthToViewZ( depth, virtualCameraNear, virtualCameraFar );\n\t\t}\n\t\tvec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {\n\t\t\tvec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc\n\t\t\tclipPosition *= clipW; //clip\n\t\t\treturn ( virtualCameraProjectionMatrixInverse * clipPosition ).xyz;//view\n\t\t}\n\t\tvoid main() {\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\t#ifdef useDepthTexture\n\t\t\t\tvec2 uv=(gl_FragCoord.xy-.5)/resolution.xy;\n\t\t\t\tuv.x=1.-uv.x;\n\t\t\t\tfloat depth = texture2DProj( tDepth, vUv ).r;\n\t\t\t\tfloat viewZ = getViewZ( depth );\n\t\t\t\tfloat clipW = virtualCameraProjectionMatrix[2][3] * viewZ+virtualCameraProjectionMatrix[3][3];\n\t\t\t\tvec3 viewPosition=getViewPosition( uv, depth, clipW );\n\t\t\t\tvec3 worldPosition=(virtualCameraMatrixWorld*vec4(viewPosition,1)).xyz;\n\t\t\t\tif(worldPosition.y>maxDistance) discard;\n\t\t\t\tfloat op=opacity;\n\t\t\t\t#ifdef DISTANCE_ATTENUATION\n\t\t\t\t\tfloat ratio=1.-(worldPosition.y/maxDistance);\n\t\t\t\t\tfloat attenuation=ratio*ratio;\n\t\t\t\t\top=opacity*attenuation;\n\t\t\t\t#endif\n\t\t\t\t#ifdef FRESNEL\n\t\t\t\t\top*=fresnelCoe;\n\t\t\t\t#endif\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), op );\n\t\t\t#else\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\t\t\t#endif\n\t\t}\n\t`)\n  });\n  return ReflectorForSSRPass2;\n})();\nexport { ReflectorForSSRPass };","map":{"version":3,"names":["__defProp","Object","defineProperty","__defNormalProp","obj","key","value","enumerable","configurable","writable","__publicField","Mesh","Matrix4","Vector2","Color","Vector3","PerspectiveCamera","DepthTexture","UnsignedShortType","NearestFilter","WebGLRenderTarget","ShaderMaterial","UniformsUtils","Plane","HalfFloatType","ReflectorForSSRPass","_ReflectorForSSRPass","constructor","geometry","options","isReflectorForSSRPass","type","scope","color","textureWidth","textureHeight","clipBias","shader","ReflectorShader","useDepthTexture","yAxis","vecTemp0","vecTemp1","needsUpdate","maxDistance","uniforms","opacity","resolution","window","innerWidth","innerHeight","_distanceAttenuation","defines","DISTANCE_ATTENUATION","get","set","val","material","_fresnel","FRESNEL","normal","reflectorWorldPosition","cameraWorldPosition","rotationMatrix","lookAtPosition","view","target","textureMatrix","virtualCamera","depthTexture","minFilter","magFilter","parameters","renderTarget","transparent","assign","clone","fragmentShader","vertexShader","texture","globalPlane","globalPlanes","doRender","renderer","scene","camera","copy","position","normalize","reflect","dot","setFromMatrixPosition","matrixWorld","extractRotation","applyMatrix4","subVectors","negate","add","up","lookAt","far","updateMatrixWorld","projectionMatrix","near","projectionMatrixInverse","multiply","matrixWorldInverse","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","currentClippingPlanes","clippingPlanes","setRenderTarget","state","buffers","depth","setMask","autoClear","clear","render","viewport","ReflectorForSSRPass2","tDiffuse","tDepth","fresnelCoe","virtualCameraNear","virtualCameraFar","virtualCameraProjectionMatrix","virtualCameraMatrixWorld","virtualCameraProjectionMatrixInverse"],"sources":["C:/Users/srk/Downloads/arq_phantom_clone/node_modules/three-stdlib/objects/ReflectorForSSRPass.js"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Mesh, Matrix4, Vector2, Color, Vector3, PerspectiveCamera, DepthTexture, UnsignedShortType, NearestFilter, WebGLRenderTarget, ShaderMaterial, UniformsUtils, Plane, HalfFloatType } from \"three\";\nconst ReflectorForSSRPass = /* @__PURE__ */ (() => {\n  const _ReflectorForSSRPass = class extends Mesh {\n    constructor(geometry, options = {}) {\n      super(geometry);\n      this.isReflectorForSSRPass = true;\n      this.type = \"ReflectorForSSRPass\";\n      const scope = this;\n      const color = options.color !== void 0 ? new Color(options.color) : new Color(8355711);\n      const textureWidth = options.textureWidth || 512;\n      const textureHeight = options.textureHeight || 512;\n      const clipBias = options.clipBias || 0;\n      const shader = options.shader || _ReflectorForSSRPass.ReflectorShader;\n      const useDepthTexture = options.useDepthTexture === true;\n      const yAxis = new Vector3(0, 1, 0);\n      const vecTemp0 = new Vector3();\n      const vecTemp1 = new Vector3();\n      scope.needsUpdate = false;\n      scope.maxDistance = _ReflectorForSSRPass.ReflectorShader.uniforms.maxDistance.value;\n      scope.opacity = _ReflectorForSSRPass.ReflectorShader.uniforms.opacity.value;\n      scope.color = color;\n      scope.resolution = options.resolution || new Vector2(window.innerWidth, window.innerHeight);\n      scope._distanceAttenuation = _ReflectorForSSRPass.ReflectorShader.defines.DISTANCE_ATTENUATION;\n      Object.defineProperty(scope, \"distanceAttenuation\", {\n        get() {\n          return scope._distanceAttenuation;\n        },\n        set(val) {\n          if (scope._distanceAttenuation === val)\n            return;\n          scope._distanceAttenuation = val;\n          scope.material.defines.DISTANCE_ATTENUATION = val;\n          scope.material.needsUpdate = true;\n        }\n      });\n      scope._fresnel = _ReflectorForSSRPass.ReflectorShader.defines.FRESNEL;\n      Object.defineProperty(scope, \"fresnel\", {\n        get() {\n          return scope._fresnel;\n        },\n        set(val) {\n          if (scope._fresnel === val)\n            return;\n          scope._fresnel = val;\n          scope.material.defines.FRESNEL = val;\n          scope.material.needsUpdate = true;\n        }\n      });\n      const normal = new Vector3();\n      const reflectorWorldPosition = new Vector3();\n      const cameraWorldPosition = new Vector3();\n      const rotationMatrix = new Matrix4();\n      const lookAtPosition = new Vector3(0, 0, -1);\n      const view = new Vector3();\n      const target = new Vector3();\n      const textureMatrix = new Matrix4();\n      const virtualCamera = new PerspectiveCamera();\n      let depthTexture;\n      if (useDepthTexture) {\n        depthTexture = new DepthTexture();\n        depthTexture.type = UnsignedShortType;\n        depthTexture.minFilter = NearestFilter;\n        depthTexture.magFilter = NearestFilter;\n      }\n      const parameters = {\n        depthTexture: useDepthTexture ? depthTexture : null,\n        type: HalfFloatType\n      };\n      const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, parameters);\n      const material = new ShaderMaterial({\n        transparent: useDepthTexture,\n        defines: Object.assign({}, _ReflectorForSSRPass.ReflectorShader.defines, {\n          useDepthTexture\n        }),\n        uniforms: UniformsUtils.clone(shader.uniforms),\n        fragmentShader: shader.fragmentShader,\n        vertexShader: shader.vertexShader\n      });\n      material.uniforms[\"tDiffuse\"].value = renderTarget.texture;\n      material.uniforms[\"color\"].value = scope.color;\n      material.uniforms[\"textureMatrix\"].value = textureMatrix;\n      if (useDepthTexture) {\n        material.uniforms[\"tDepth\"].value = renderTarget.depthTexture;\n      }\n      this.material = material;\n      const globalPlane = new Plane(new Vector3(0, 1, 0), clipBias);\n      const globalPlanes = [globalPlane];\n      this.doRender = function(renderer, scene, camera) {\n        material.uniforms[\"maxDistance\"].value = scope.maxDistance;\n        material.uniforms[\"color\"].value = scope.color;\n        material.uniforms[\"opacity\"].value = scope.opacity;\n        vecTemp0.copy(camera.position).normalize();\n        vecTemp1.copy(vecTemp0).reflect(yAxis);\n        material.uniforms[\"fresnelCoe\"].value = (vecTemp0.dot(vecTemp1) + 1) / 2;\n        reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n        cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n        rotationMatrix.extractRotation(scope.matrixWorld);\n        normal.set(0, 0, 1);\n        normal.applyMatrix4(rotationMatrix);\n        view.subVectors(reflectorWorldPosition, cameraWorldPosition);\n        if (view.dot(normal) > 0)\n          return;\n        view.reflect(normal).negate();\n        view.add(reflectorWorldPosition);\n        rotationMatrix.extractRotation(camera.matrixWorld);\n        lookAtPosition.set(0, 0, -1);\n        lookAtPosition.applyMatrix4(rotationMatrix);\n        lookAtPosition.add(cameraWorldPosition);\n        target.subVectors(reflectorWorldPosition, lookAtPosition);\n        target.reflect(normal).negate();\n        target.add(reflectorWorldPosition);\n        virtualCamera.position.copy(view);\n        virtualCamera.up.set(0, 1, 0);\n        virtualCamera.up.applyMatrix4(rotationMatrix);\n        virtualCamera.up.reflect(normal);\n        virtualCamera.lookAt(target);\n        virtualCamera.far = camera.far;\n        virtualCamera.updateMatrixWorld();\n        virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n        material.uniforms[\"virtualCameraNear\"].value = camera.near;\n        material.uniforms[\"virtualCameraFar\"].value = camera.far;\n        material.uniforms[\"virtualCameraMatrixWorld\"].value = virtualCamera.matrixWorld;\n        material.uniforms[\"virtualCameraProjectionMatrix\"].value = camera.projectionMatrix;\n        material.uniforms[\"virtualCameraProjectionMatrixInverse\"].value = camera.projectionMatrixInverse;\n        material.uniforms[\"resolution\"].value = scope.resolution;\n        textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);\n        textureMatrix.multiply(virtualCamera.projectionMatrix);\n        textureMatrix.multiply(virtualCamera.matrixWorldInverse);\n        textureMatrix.multiply(scope.matrixWorld);\n        const currentRenderTarget = renderer.getRenderTarget();\n        const currentXrEnabled = renderer.xr.enabled;\n        const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n        const currentClippingPlanes = renderer.clippingPlanes;\n        renderer.xr.enabled = false;\n        renderer.shadowMap.autoUpdate = false;\n        renderer.clippingPlanes = globalPlanes;\n        renderer.setRenderTarget(renderTarget);\n        renderer.state.buffers.depth.setMask(true);\n        if (renderer.autoClear === false)\n          renderer.clear();\n        renderer.render(scene, virtualCamera);\n        renderer.xr.enabled = currentXrEnabled;\n        renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n        renderer.clippingPlanes = currentClippingPlanes;\n        renderer.setRenderTarget(currentRenderTarget);\n        const viewport = camera.viewport;\n        if (viewport !== void 0) {\n          renderer.state.viewport(viewport);\n        }\n      };\n      this.getRenderTarget = function() {\n        return renderTarget;\n      };\n    }\n  };\n  let ReflectorForSSRPass2 = _ReflectorForSSRPass;\n  __publicField(ReflectorForSSRPass2, \"ReflectorShader\", {\n    defines: {\n      DISTANCE_ATTENUATION: true,\n      FRESNEL: true\n    },\n    uniforms: {\n      color: { value: null },\n      tDiffuse: { value: null },\n      tDepth: { value: null },\n      textureMatrix: { value: new Matrix4() },\n      maxDistance: { value: 180 },\n      opacity: { value: 0.5 },\n      fresnelCoe: { value: null },\n      virtualCameraNear: { value: null },\n      virtualCameraFar: { value: null },\n      virtualCameraProjectionMatrix: { value: new Matrix4() },\n      virtualCameraMatrixWorld: { value: new Matrix4() },\n      virtualCameraProjectionMatrixInverse: { value: new Matrix4() },\n      resolution: { value: new Vector2() }\n    },\n    vertexShader: (\n      /* glsl */\n      `\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`\n    ),\n    fragmentShader: (\n      /* glsl */\n      `\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform sampler2D tDepth;\n\t\tuniform float maxDistance;\n\t\tuniform float opacity;\n\t\tuniform float fresnelCoe;\n\t\tuniform float virtualCameraNear;\n\t\tuniform float virtualCameraFar;\n\t\tuniform mat4 virtualCameraProjectionMatrix;\n\t\tuniform mat4 virtualCameraProjectionMatrixInverse;\n\t\tuniform mat4 virtualCameraMatrixWorld;\n\t\tuniform vec2 resolution;\n\t\tvarying vec4 vUv;\n\t\t#include <packing>\n\t\tfloat blendOverlay( float base, float blend ) {\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\t\t}\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\t\t}\n\t\tfloat getDepth( const in vec2 uv ) {\n\t\t\treturn texture2D( tDepth, uv ).x;\n\t\t}\n\t\tfloat getViewZ( const in float depth ) {\n\t\t\treturn perspectiveDepthToViewZ( depth, virtualCameraNear, virtualCameraFar );\n\t\t}\n\t\tvec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {\n\t\t\tvec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc\n\t\t\tclipPosition *= clipW; //clip\n\t\t\treturn ( virtualCameraProjectionMatrixInverse * clipPosition ).xyz;//view\n\t\t}\n\t\tvoid main() {\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\t#ifdef useDepthTexture\n\t\t\t\tvec2 uv=(gl_FragCoord.xy-.5)/resolution.xy;\n\t\t\t\tuv.x=1.-uv.x;\n\t\t\t\tfloat depth = texture2DProj( tDepth, vUv ).r;\n\t\t\t\tfloat viewZ = getViewZ( depth );\n\t\t\t\tfloat clipW = virtualCameraProjectionMatrix[2][3] * viewZ+virtualCameraProjectionMatrix[3][3];\n\t\t\t\tvec3 viewPosition=getViewPosition( uv, depth, clipW );\n\t\t\t\tvec3 worldPosition=(virtualCameraMatrixWorld*vec4(viewPosition,1)).xyz;\n\t\t\t\tif(worldPosition.y>maxDistance) discard;\n\t\t\t\tfloat op=opacity;\n\t\t\t\t#ifdef DISTANCE_ATTENUATION\n\t\t\t\t\tfloat ratio=1.-(worldPosition.y/maxDistance);\n\t\t\t\t\tfloat attenuation=ratio*ratio;\n\t\t\t\t\top=opacity*attenuation;\n\t\t\t\t#endif\n\t\t\t\t#ifdef FRESNEL\n\t\t\t\t\top*=fresnelCoe;\n\t\t\t\t#endif\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), op );\n\t\t\t#else\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\t\t\t#endif\n\t\t}\n\t`\n    )\n  });\n  return ReflectorForSSRPass2;\n})();\nexport {\n  ReflectorForSSRPass\n};\n//# sourceMappingURL=ReflectorForSSRPass.js.map\n"],"mappings":"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E;MAAK,CAAC;MAClC6H,gBAAgB,EAAE;QAAE7H,KAAK,EAAE;MAAK,CAAC;MACjC8H,6BAA6B,EAAE;QAAE9H,KAAK,EAAE,IAAIM,OAAO,CAAC;MAAE,CAAC;MACvDyH,wBAAwB,EAAE;QAAE/H,KAAK,EAAE,IAAIM,OAAO,CAAC;MAAE,CAAC;MAClD0H,oCAAoC,EAAE;QAAEhI,KAAK,EAAE,IAAIM,OAAO,CAAC;MAAE,CAAC;MAC9DmC,UAAU,EAAE;QAAEzC,KAAK,EAAE,IAAIO,OAAO,CAAC;MAAE;IACrC,CAAC;IACDiE,YAAY,GACV;IACA;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,CACC;IACDD,cAAc,GACZ;IACA;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;EAEA,CAAC,CAAC;EACF,OAAOiD,oBAAoB;AAC7B,CAAC,EAAE,CAAC;AACJ,SACErG,mBAAmB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}