{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Mesh, PerspectiveCamera, Color, Plane, Matrix4, WebGLRenderTarget, HalfFloatType, ShaderMaterial, UniformsUtils, Vector3, Quaternion, Vector4, NoToneMapping } from \"three\";\nimport { version } from \"../_polyfill/constants.js\";\nconst Refractor = /* @__PURE__ */(() => {\n  const _Refractor = class extends Mesh {\n    constructor(geometry, options = {}) {\n      super(geometry);\n      this.isRefractor = true;\n      this.type = \"Refractor\";\n      this.camera = new PerspectiveCamera();\n      const scope = this;\n      const color = options.color !== void 0 ? new Color(options.color) : new Color(8355711);\n      const textureWidth = options.textureWidth || 512;\n      const textureHeight = options.textureHeight || 512;\n      const clipBias = options.clipBias || 0;\n      const shader = options.shader || _Refractor.RefractorShader;\n      const multisample = options.multisample !== void 0 ? options.multisample : 4;\n      const virtualCamera = this.camera;\n      virtualCamera.matrixAutoUpdate = false;\n      virtualCamera.userData.refractor = true;\n      const refractorPlane = new Plane();\n      const textureMatrix = new Matrix4();\n      const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, {\n        samples: multisample,\n        type: HalfFloatType\n      });\n      this.material = new ShaderMaterial({\n        uniforms: UniformsUtils.clone(shader.uniforms),\n        vertexShader: shader.vertexShader,\n        fragmentShader: shader.fragmentShader,\n        transparent: true\n        // ensures, refractors are drawn from farthest to closest\n      });\n      this.material.uniforms[\"color\"].value = color;\n      this.material.uniforms[\"tDiffuse\"].value = renderTarget.texture;\n      this.material.uniforms[\"textureMatrix\"].value = textureMatrix;\n      const visible = function () {\n        const refractorWorldPosition = new Vector3();\n        const cameraWorldPosition = new Vector3();\n        const rotationMatrix = new Matrix4();\n        const view = new Vector3();\n        const normal = new Vector3();\n        return function visible2(camera) {\n          refractorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n          cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n          view.subVectors(refractorWorldPosition, cameraWorldPosition);\n          rotationMatrix.extractRotation(scope.matrixWorld);\n          normal.set(0, 0, 1);\n          normal.applyMatrix4(rotationMatrix);\n          return view.dot(normal) < 0;\n        };\n      }();\n      const updateRefractorPlane = function () {\n        const normal = new Vector3();\n        const position = new Vector3();\n        const quaternion = new Quaternion();\n        const scale = new Vector3();\n        return function updateRefractorPlane2() {\n          scope.matrixWorld.decompose(position, quaternion, scale);\n          normal.set(0, 0, 1).applyQuaternion(quaternion).normalize();\n          normal.negate();\n          refractorPlane.setFromNormalAndCoplanarPoint(normal, position);\n        };\n      }();\n      const updateVirtualCamera = function () {\n        const clipPlane = new Plane();\n        const clipVector = new Vector4();\n        const q = new Vector4();\n        return function updateVirtualCamera2(camera) {\n          virtualCamera.matrixWorld.copy(camera.matrixWorld);\n          virtualCamera.matrixWorldInverse.copy(virtualCamera.matrixWorld).invert();\n          virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n          virtualCamera.far = camera.far;\n          clipPlane.copy(refractorPlane);\n          clipPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n          clipVector.set(clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.constant);\n          const projectionMatrix = virtualCamera.projectionMatrix;\n          q.x = (Math.sign(clipVector.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n          q.y = (Math.sign(clipVector.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n          q.z = -1;\n          q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];\n          clipVector.multiplyScalar(2 / clipVector.dot(q));\n          projectionMatrix.elements[2] = clipVector.x;\n          projectionMatrix.elements[6] = clipVector.y;\n          projectionMatrix.elements[10] = clipVector.z + 1 - clipBias;\n          projectionMatrix.elements[14] = clipVector.w;\n        };\n      }();\n      function updateTextureMatrix(camera) {\n        textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);\n        textureMatrix.multiply(camera.projectionMatrix);\n        textureMatrix.multiply(camera.matrixWorldInverse);\n        textureMatrix.multiply(scope.matrixWorld);\n      }\n      function render(renderer, scene, camera) {\n        scope.visible = false;\n        const currentRenderTarget = renderer.getRenderTarget();\n        const currentXrEnabled = renderer.xr.enabled;\n        const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n        const currentToneMapping = renderer.toneMapping;\n        let isSRGB = false;\n        if (\"outputColorSpace\" in renderer) isSRGB = renderer.outputColorSpace === \"srgb\";else isSRGB = renderer.outputEncoding === 3001;\n        renderer.xr.enabled = false;\n        renderer.shadowMap.autoUpdate = false;\n        if (\"outputColorSpace\" in renderer) renderer.outputColorSpace = \"srgb-linear\";else renderer.outputEncoding = 3e3;\n        renderer.toneMapping = NoToneMapping;\n        renderer.setRenderTarget(renderTarget);\n        if (renderer.autoClear === false) renderer.clear();\n        renderer.render(scene, virtualCamera);\n        renderer.xr.enabled = currentXrEnabled;\n        renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n        renderer.toneMapping = currentToneMapping;\n        renderer.setRenderTarget(currentRenderTarget);\n        if (\"outputColorSpace\" in renderer) renderer.outputColorSpace = isSRGB ? \"srgb\" : \"srgb-linear\";else renderer.outputEncoding = isSRGB ? 3001 : 3e3;\n        const viewport = camera.viewport;\n        if (viewport !== void 0) {\n          renderer.state.viewport(viewport);\n        }\n        scope.visible = true;\n      }\n      this.onBeforeRender = function (renderer, scene, camera) {\n        if (camera.userData.refractor === true) return;\n        if (!visible(camera) === true) return;\n        updateRefractorPlane();\n        updateTextureMatrix(camera);\n        updateVirtualCamera(camera);\n        render(renderer, scene, camera);\n      };\n      this.getRenderTarget = function () {\n        return renderTarget;\n      };\n      this.dispose = function () {\n        renderTarget.dispose();\n        scope.material.dispose();\n      };\n    }\n  };\n  let Refractor2 = _Refractor;\n  __publicField(Refractor2, \"RefractorShader\", {\n    uniforms: {\n      color: {\n        value: null\n      },\n      tDiffuse: {\n        value: null\n      },\n      textureMatrix: {\n        value: null\n      }\n    },\n    vertexShader: (/* glsl */\n    `\n\n\t\tuniform mat4 textureMatrix;\n\n\t\tvarying vec4 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`),\n    fragmentShader: (/* glsl */\n    `\n\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec4 vUv;\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <${version >= 154 ? \"colorspace_fragment\" : \"encodings_fragment\"}>\n\n\t\t}`)\n  });\n  return Refractor2;\n})();\nexport { Refractor };","map":{"version":3,"names":["__defProp","Object","defineProperty","__defNormalProp","obj","key","value","enumerable","configurable","writable","__publicField","Mesh","PerspectiveCamera","Color","Plane","Matrix4","WebGLRenderTarget","HalfFloatType","ShaderMaterial","UniformsUtils","Vector3","Quaternion","Vector4","NoToneMapping","version","Refractor","_Refractor","constructor","geometry","options","isRefractor","type","camera","scope","color","textureWidth","textureHeight","clipBias","shader","RefractorShader","multisample","virtualCamera","matrixAutoUpdate","userData","refractor","refractorPlane","textureMatrix","renderTarget","samples","material","uniforms","clone","vertexShader","fragmentShader","transparent","texture","visible","refractorWorldPosition","cameraWorldPosition","rotationMatrix","view","normal","visible2","setFromMatrixPosition","matrixWorld","subVectors","extractRotation","set","applyMatrix4","dot","updateRefractorPlane","position","quaternion","scale","updateRefractorPlane2","decompose","applyQuaternion","normalize","negate","setFromNormalAndCoplanarPoint","updateVirtualCamera","clipPlane","clipVector","q","updateVirtualCamera2","copy","matrixWorldInverse","invert","projectionMatrix","far","x","y","z","constant","Math","sign","elements","w","multiplyScalar","updateTextureMatrix","multiply","render","renderer","scene","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","currentToneMapping","toneMapping","isSRGB","outputColorSpace","outputEncoding","setRenderTarget","autoClear","clear","viewport","state","onBeforeRender","dispose","Refractor2","tDiffuse"],"sources":["C:/Users/srk/Downloads/arq_phantom_clone/node_modules/three-stdlib/objects/Refractor.js"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Mesh, PerspectiveCamera, Color, Plane, Matrix4, WebGLRenderTarget, HalfFloatType, ShaderMaterial, UniformsUtils, Vector3, Quaternion, Vector4, NoToneMapping } from \"three\";\nimport { version } from \"../_polyfill/constants.js\";\nconst Refractor = /* @__PURE__ */ (() => {\n  const _Refractor = class extends Mesh {\n    constructor(geometry, options = {}) {\n      super(geometry);\n      this.isRefractor = true;\n      this.type = \"Refractor\";\n      this.camera = new PerspectiveCamera();\n      const scope = this;\n      const color = options.color !== void 0 ? new Color(options.color) : new Color(8355711);\n      const textureWidth = options.textureWidth || 512;\n      const textureHeight = options.textureHeight || 512;\n      const clipBias = options.clipBias || 0;\n      const shader = options.shader || _Refractor.RefractorShader;\n      const multisample = options.multisample !== void 0 ? options.multisample : 4;\n      const virtualCamera = this.camera;\n      virtualCamera.matrixAutoUpdate = false;\n      virtualCamera.userData.refractor = true;\n      const refractorPlane = new Plane();\n      const textureMatrix = new Matrix4();\n      const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, {\n        samples: multisample,\n        type: HalfFloatType\n      });\n      this.material = new ShaderMaterial({\n        uniforms: UniformsUtils.clone(shader.uniforms),\n        vertexShader: shader.vertexShader,\n        fragmentShader: shader.fragmentShader,\n        transparent: true\n        // ensures, refractors are drawn from farthest to closest\n      });\n      this.material.uniforms[\"color\"].value = color;\n      this.material.uniforms[\"tDiffuse\"].value = renderTarget.texture;\n      this.material.uniforms[\"textureMatrix\"].value = textureMatrix;\n      const visible = function() {\n        const refractorWorldPosition = new Vector3();\n        const cameraWorldPosition = new Vector3();\n        const rotationMatrix = new Matrix4();\n        const view = new Vector3();\n        const normal = new Vector3();\n        return function visible2(camera) {\n          refractorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n          cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n          view.subVectors(refractorWorldPosition, cameraWorldPosition);\n          rotationMatrix.extractRotation(scope.matrixWorld);\n          normal.set(0, 0, 1);\n          normal.applyMatrix4(rotationMatrix);\n          return view.dot(normal) < 0;\n        };\n      }();\n      const updateRefractorPlane = function() {\n        const normal = new Vector3();\n        const position = new Vector3();\n        const quaternion = new Quaternion();\n        const scale = new Vector3();\n        return function updateRefractorPlane2() {\n          scope.matrixWorld.decompose(position, quaternion, scale);\n          normal.set(0, 0, 1).applyQuaternion(quaternion).normalize();\n          normal.negate();\n          refractorPlane.setFromNormalAndCoplanarPoint(normal, position);\n        };\n      }();\n      const updateVirtualCamera = function() {\n        const clipPlane = new Plane();\n        const clipVector = new Vector4();\n        const q = new Vector4();\n        return function updateVirtualCamera2(camera) {\n          virtualCamera.matrixWorld.copy(camera.matrixWorld);\n          virtualCamera.matrixWorldInverse.copy(virtualCamera.matrixWorld).invert();\n          virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n          virtualCamera.far = camera.far;\n          clipPlane.copy(refractorPlane);\n          clipPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n          clipVector.set(clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.constant);\n          const projectionMatrix = virtualCamera.projectionMatrix;\n          q.x = (Math.sign(clipVector.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n          q.y = (Math.sign(clipVector.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n          q.z = -1;\n          q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];\n          clipVector.multiplyScalar(2 / clipVector.dot(q));\n          projectionMatrix.elements[2] = clipVector.x;\n          projectionMatrix.elements[6] = clipVector.y;\n          projectionMatrix.elements[10] = clipVector.z + 1 - clipBias;\n          projectionMatrix.elements[14] = clipVector.w;\n        };\n      }();\n      function updateTextureMatrix(camera) {\n        textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);\n        textureMatrix.multiply(camera.projectionMatrix);\n        textureMatrix.multiply(camera.matrixWorldInverse);\n        textureMatrix.multiply(scope.matrixWorld);\n      }\n      function render(renderer, scene, camera) {\n        scope.visible = false;\n        const currentRenderTarget = renderer.getRenderTarget();\n        const currentXrEnabled = renderer.xr.enabled;\n        const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n        const currentToneMapping = renderer.toneMapping;\n        let isSRGB = false;\n        if (\"outputColorSpace\" in renderer)\n          isSRGB = renderer.outputColorSpace === \"srgb\";\n        else\n          isSRGB = renderer.outputEncoding === 3001;\n        renderer.xr.enabled = false;\n        renderer.shadowMap.autoUpdate = false;\n        if (\"outputColorSpace\" in renderer)\n          renderer.outputColorSpace = \"srgb-linear\";\n        else\n          renderer.outputEncoding = 3e3;\n        renderer.toneMapping = NoToneMapping;\n        renderer.setRenderTarget(renderTarget);\n        if (renderer.autoClear === false)\n          renderer.clear();\n        renderer.render(scene, virtualCamera);\n        renderer.xr.enabled = currentXrEnabled;\n        renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n        renderer.toneMapping = currentToneMapping;\n        renderer.setRenderTarget(currentRenderTarget);\n        if (\"outputColorSpace\" in renderer)\n          renderer.outputColorSpace = isSRGB ? \"srgb\" : \"srgb-linear\";\n        else\n          renderer.outputEncoding = isSRGB ? 3001 : 3e3;\n        const viewport = camera.viewport;\n        if (viewport !== void 0) {\n          renderer.state.viewport(viewport);\n        }\n        scope.visible = true;\n      }\n      this.onBeforeRender = function(renderer, scene, camera) {\n        if (camera.userData.refractor === true)\n          return;\n        if (!visible(camera) === true)\n          return;\n        updateRefractorPlane();\n        updateTextureMatrix(camera);\n        updateVirtualCamera(camera);\n        render(renderer, scene, camera);\n      };\n      this.getRenderTarget = function() {\n        return renderTarget;\n      };\n      this.dispose = function() {\n        renderTarget.dispose();\n        scope.material.dispose();\n      };\n    }\n  };\n  let Refractor2 = _Refractor;\n  __publicField(Refractor2, \"RefractorShader\", {\n    uniforms: {\n      color: {\n        value: null\n      },\n      tDiffuse: {\n        value: null\n      },\n      textureMatrix: {\n        value: null\n      }\n    },\n    vertexShader: (\n      /* glsl */\n      `\n\n\t\tuniform mat4 textureMatrix;\n\n\t\tvarying vec4 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`\n    ),\n    fragmentShader: (\n      /* glsl */\n      `\n\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec4 vUv;\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <${version >= 154 ? \"colorspace_fragment\" : \"encodings_fragment\"}>\n\n\t\t}`\n    )\n  });\n  return Refractor2;\n})();\nexport {\n  Refractor\n};\n//# sourceMappingURL=Refractor.js.map\n"],"mappings":"AAAA,IAAIA,SAAS,GAAGC,MAAM,CAACC,cAAc;AACrC,IAAIC,eAAe,GAAGA,CAACC,GAAG,EAAEC,GAAG,EAAEC,KAAK,KAAKD,GAAG,IAAID,GAAG,GAAGJ,SAAS,CAACI,GAAG,EAAEC,GAAG,EAAE;EAAEE,UAAU,EAAE,IAAI;EAAEC,YAAY,EAAE,IAAI;EAAEC,QAAQ,EAAE,IAAI;EAAEH;AAAM,CAAC,CAAC,GAAGF,GAAG,CAACC,GAAG,CAAC,GAAGC,KAAK;AAC/J,IAAII,aAAa,GAAGA,CAACN,GAAG,EAAEC,GAAG,EAAEC,KAAK,KAAK;EACvCH,eAAe,CAACC,GAAG,EAAE,OAAOC,GAAG,KAAK,QAAQ,GAAGA,GAAG,GAAG,EAAE,GAAGA,GAAG,EAAEC,KAAK,CAAC;EACrE,OAAOA,KAAK;AACd,CAAC;AACD,SAASK,IAAI,EAAEC,iBAAiB,EAAEC,KAAK,EAAEC,KAAK,EAAEC,OAAO,EAAEC,iBAAiB,EAAEC,aAAa,EAAEC,cAAc,EAAEC,aAAa,EAAEC,OAAO,EAAEC,UAAU,EAAEC,OAAO,EAAEC,aAAa,QAAQ,OAAO;AACpL,SAASC,OAAO,QAAQ,2BAA2B;AACnD,MAAMC,SAAS,GAAG,eAAgB,CAAC,MAAM;EACvC,MAAMC,UAAU,GAAG,cAAcf,IAAI,CAAC;IACpCgB,WAAWA,CAACC,QAAQ,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAE;MAClC,KAAK,CAACD,QAAQ,CAAC;MACf,IAAI,CAACE,WAAW,GAAG,IAAI;MACvB,IAAI,CAACC,IAAI,GAAG,WAAW;MACvB,IAAI,CAACC,MAAM,GAAG,IAAIpB,iBAAiB,CAAC,CAAC;MACrC,MAAMqB,KAAK,GAAG,IAAI;MAClB,MAAMC,KAAK,GAAGL,OAAO,CAACK,KAAK,KAAK,KAAK,CAAC,GAAG,IAAIrB,KAAK,CAACgB,OAAO,CAACK,KAAK,CAAC,GAAG,IAAIrB,KAAK,CAAC,OAAO,CAAC;MACtF,MAAMsB,YAAY,GAAGN,OAAO,CAACM,YAAY,IAAI,GAAG;MAChD,MAAMC,aAAa,GAAGP,OAAO,CAACO,aAAa,IAAI,GAAG;MAClD,MAAMC,QAAQ,GAAGR,OAAO,CAACQ,QAAQ,IAAI,CAAC;MACtC,MAAMC,MAAM,GAAGT,OAAO,CAACS,MAAM,IAAIZ,UAAU,CAACa,eAAe;MAC3D,MAAMC,WAAW,GAAGX,OAAO,CAACW,WAAW,KAAK,KAAK,CAAC,GAAGX,OAAO,CAACW,WAAW,GAAG,CAAC;MAC5E,MAAMC,aAAa,GAAG,IAAI,CAACT,MAAM;MACjCS,aAAa,CAACC,gBAAgB,GAAG,KAAK;MACtCD,aAAa,CAACE,QAAQ,CAACC,SAAS,GAAG,IAAI;MACvC,MAAMC,cAAc,GAAG,IAAI/B,KAAK,CAAC,CAAC;MAClC,MAAMgC,aAAa,GAAG,IAAI/B,OAAO,CAAC,CAAC;MACnC,MAAMgC,YAAY,GAAG,IAAI/B,iBAAiB,CAACmB,YAAY,EAAEC,aAAa,EAAE;QACtEY,OAAO,EAAER,WAAW;QACpBT,IAAI,EAAEd;MACR,CAAC,CAAC;MACF,IAAI,CAACgC,QAAQ,GAAG,IAAI/B,cAAc,CAAC;QACjCgC,QAAQ,EAAE/B,aAAa,CAACgC,KAAK,CAACb,MAAM,CAACY,QAAQ,CAAC;QAC9CE,YAAY,EAAEd,MAAM,CAACc,YAAY;QACjCC,cAAc,EAAEf,MAAM,CAACe,cAAc;QACrCC,WAAW,EAAE;QACb;MACF,CAAC,CAAC;MACF,IAAI,CAACL,QAAQ,CAACC,QAAQ,CAAC,OAAO,CAAC,CAAC5C,KAAK,GAAG4B,KAAK;MAC7C,IAAI,CAACe,QAAQ,CAACC,QAAQ,CAAC,UAAU,CAAC,CAAC5C,KAAK,GAAGyC,YAAY,CAACQ,OAAO;MAC/D,IAAI,CAACN,QAAQ,CAACC,QAAQ,CAAC,eAAe,CAAC,CAAC5C,KAAK,GAAGwC,aAAa;MAC7D,MAAMU,OAAO,GAAG,YAAW;QACzB,MAAMC,sBAAsB,GAAG,IAAIrC,OAAO,CAAC,CAAC;QAC5C,MAAMsC,mBAAmB,GAAG,IAAItC,OAAO,CAAC,CAAC;QACzC,MAAMuC,cAAc,GAAG,IAAI5C,OAAO,CAAC,CAAC;QACpC,MAAM6C,IAAI,GAAG,IAAIxC,OAAO,CAAC,CAAC;QAC1B,MAAMyC,MAAM,GAAG,IAAIzC,OAAO,CAAC,CAAC;QAC5B,OAAO,SAAS0C,QAAQA,CAAC9B,MAAM,EAAE;UAC/ByB,sBAAsB,CAACM,qBAAqB,CAAC9B,KAAK,CAAC+B,WAAW,CAAC;UAC/DN,mBAAmB,CAACK,qBAAqB,CAAC/B,MAAM,CAACgC,WAAW,CAAC;UAC7DJ,IAAI,CAACK,UAAU,CAACR,sBAAsB,EAAEC,mBAAmB,CAAC;UAC5DC,cAAc,CAACO,eAAe,CAACjC,KAAK,CAAC+B,WAAW,CAAC;UACjDH,MAAM,CAACM,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;UACnBN,MAAM,CAACO,YAAY,CAACT,cAAc,CAAC;UACnC,OAAOC,IAAI,CAACS,GAAG,CAACR,MAAM,CAAC,GAAG,CAAC;QAC7B,CAAC;MACH,CAAC,CAAC,CAAC;MACH,MAAMS,oBAAoB,GAAG,YAAW;QACtC,MAAMT,MAAM,GAAG,IAAIzC,OAAO,CAAC,CAAC;QAC5B,MAAMmD,QAAQ,GAAG,IAAInD,OAAO,CAAC,CAAC;QAC9B,MAAMoD,UAAU,GAAG,IAAInD,UAAU,CAAC,CAAC;QACnC,MAAMoD,KAAK,GAAG,IAAIrD,OAAO,CAAC,CAAC;QAC3B,OAAO,SAASsD,qBAAqBA,CAAA,EAAG;UACtCzC,KAAK,CAAC+B,WAAW,CAACW,SAAS,CAACJ,QAAQ,EAAEC,UAAU,EAAEC,KAAK,CAAC;UACxDZ,MAAM,CAACM,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAACS,eAAe,CAACJ,UAAU,CAAC,CAACK,SAAS,CAAC,CAAC;UAC3DhB,MAAM,CAACiB,MAAM,CAAC,CAAC;UACfjC,cAAc,CAACkC,6BAA6B,CAAClB,MAAM,EAAEU,QAAQ,CAAC;QAChE,CAAC;MACH,CAAC,CAAC,CAAC;MACH,MAAMS,mBAAmB,GAAG,YAAW;QACrC,MAAMC,SAAS,GAAG,IAAInE,KAAK,CAAC,CAAC;QAC7B,MAAMoE,UAAU,GAAG,IAAI5D,OAAO,CAAC,CAAC;QAChC,MAAM6D,CAAC,GAAG,IAAI7D,OAAO,CAAC,CAAC;QACvB,OAAO,SAAS8D,oBAAoBA,CAACpD,MAAM,EAAE;UAC3CS,aAAa,CAACuB,WAAW,CAACqB,IAAI,CAACrD,MAAM,CAACgC,WAAW,CAAC;UAClDvB,aAAa,CAAC6C,kBAAkB,CAACD,IAAI,CAAC5C,aAAa,CAACuB,WAAW,CAAC,CAACuB,MAAM,CAAC,CAAC;UACzE9C,aAAa,CAAC+C,gBAAgB,CAACH,IAAI,CAACrD,MAAM,CAACwD,gBAAgB,CAAC;UAC5D/C,aAAa,CAACgD,GAAG,GAAGzD,MAAM,CAACyD,GAAG;UAC9BR,SAAS,CAACI,IAAI,CAACxC,cAAc,CAAC;UAC9BoC,SAAS,CAACb,YAAY,CAAC3B,aAAa,CAAC6C,kBAAkB,CAAC;UACxDJ,UAAU,CAACf,GAAG,CAACc,SAAS,CAACpB,MAAM,CAAC6B,CAAC,EAAET,SAAS,CAACpB,MAAM,CAAC8B,CAAC,EAAEV,SAAS,CAACpB,MAAM,CAAC+B,CAAC,EAAEX,SAAS,CAACY,QAAQ,CAAC;UAC9F,MAAML,gBAAgB,GAAG/C,aAAa,CAAC+C,gBAAgB;UACvDL,CAAC,CAACO,CAAC,GAAG,CAACI,IAAI,CAACC,IAAI,CAACb,UAAU,CAACQ,CAAC,CAAC,GAAGF,gBAAgB,CAACQ,QAAQ,CAAC,CAAC,CAAC,IAAIR,gBAAgB,CAACQ,QAAQ,CAAC,CAAC,CAAC;UAC7Fb,CAAC,CAACQ,CAAC,GAAG,CAACG,IAAI,CAACC,IAAI,CAACb,UAAU,CAACS,CAAC,CAAC,GAAGH,gBAAgB,CAACQ,QAAQ,CAAC,CAAC,CAAC,IAAIR,gBAAgB,CAACQ,QAAQ,CAAC,CAAC,CAAC;UAC7Fb,CAAC,CAACS,CAAC,GAAG,CAAC,CAAC;UACRT,CAAC,CAACc,CAAC,GAAG,CAAC,CAAC,GAAGT,gBAAgB,CAACQ,QAAQ,CAAC,EAAE,CAAC,IAAIR,gBAAgB,CAACQ,QAAQ,CAAC,EAAE,CAAC;UACzEd,UAAU,CAACgB,cAAc,CAAC,CAAC,GAAGhB,UAAU,CAACb,GAAG,CAACc,CAAC,CAAC,CAAC;UAChDK,gBAAgB,CAACQ,QAAQ,CAAC,CAAC,CAAC,GAAGd,UAAU,CAACQ,CAAC;UAC3CF,gBAAgB,CAACQ,QAAQ,CAAC,CAAC,CAAC,GAAGd,UAAU,CAACS,CAAC;UAC3CH,gBAAgB,CAACQ,QAAQ,CAAC,EAAE,CAAC,GAAGd,UAAU,CAACU,CAAC,GAAG,CAAC,GAAGvD,QAAQ;UAC3DmD,gBAAgB,CAACQ,QAAQ,CAAC,EAAE,CAAC,GAAGd,UAAU,CAACe,CAAC;QAC9C,CAAC;MACH,CAAC,CAAC,CAAC;MACH,SAASE,mBAAmBA,CAACnE,MAAM,EAAE;QACnCc,aAAa,CAACqB,GAAG,CAAC,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;QAC7ErB,aAAa,CAACsD,QAAQ,CAACpE,MAAM,CAACwD,gBAAgB,CAAC;QAC/C1C,aAAa,CAACsD,QAAQ,CAACpE,MAAM,CAACsD,kBAAkB,CAAC;QACjDxC,aAAa,CAACsD,QAAQ,CAACnE,KAAK,CAAC+B,WAAW,CAAC;MAC3C;MACA,SAASqC,MAAMA,CAACC,QAAQ,EAAEC,KAAK,EAAEvE,MAAM,EAAE;QACvCC,KAAK,CAACuB,OAAO,GAAG,KAAK;QACrB,MAAMgD,mBAAmB,GAAGF,QAAQ,CAACG,eAAe,CAAC,CAAC;QACtD,MAAMC,gBAAgB,GAAGJ,QAAQ,CAACK,EAAE,CAACC,OAAO;QAC5C,MAAMC,uBAAuB,GAAGP,QAAQ,CAACQ,SAAS,CAACC,UAAU;QAC7D,MAAMC,kBAAkB,GAAGV,QAAQ,CAACW,WAAW;QAC/C,IAAIC,MAAM,GAAG,KAAK;QAClB,IAAI,kBAAkB,IAAIZ,QAAQ,EAChCY,MAAM,GAAGZ,QAAQ,CAACa,gBAAgB,KAAK,MAAM,CAAC,KAE9CD,MAAM,GAAGZ,QAAQ,CAACc,cAAc,KAAK,IAAI;QAC3Cd,QAAQ,CAACK,EAAE,CAACC,OAAO,GAAG,KAAK;QAC3BN,QAAQ,CAACQ,SAAS,CAACC,UAAU,GAAG,KAAK;QACrC,IAAI,kBAAkB,IAAIT,QAAQ,EAChCA,QAAQ,CAACa,gBAAgB,GAAG,aAAa,CAAC,KAE1Cb,QAAQ,CAACc,cAAc,GAAG,GAAG;QAC/Bd,QAAQ,CAACW,WAAW,GAAG1F,aAAa;QACpC+E,QAAQ,CAACe,eAAe,CAACtE,YAAY,CAAC;QACtC,IAAIuD,QAAQ,CAACgB,SAAS,KAAK,KAAK,EAC9BhB,QAAQ,CAACiB,KAAK,CAAC,CAAC;QAClBjB,QAAQ,CAACD,MAAM,CAACE,KAAK,EAAE9D,aAAa,CAAC;QACrC6D,QAAQ,CAACK,EAAE,CAACC,OAAO,GAAGF,gBAAgB;QACtCJ,QAAQ,CAACQ,SAAS,CAACC,UAAU,GAAGF,uBAAuB;QACvDP,QAAQ,CAACW,WAAW,GAAGD,kBAAkB;QACzCV,QAAQ,CAACe,eAAe,CAACb,mBAAmB,CAAC;QAC7C,IAAI,kBAAkB,IAAIF,QAAQ,EAChCA,QAAQ,CAACa,gBAAgB,GAAGD,MAAM,GAAG,MAAM,GAAG,aAAa,CAAC,KAE5DZ,QAAQ,CAACc,cAAc,GAAGF,MAAM,GAAG,IAAI,GAAG,GAAG;QAC/C,MAAMM,QAAQ,GAAGxF,MAAM,CAACwF,QAAQ;QAChC,IAAIA,QAAQ,KAAK,KAAK,CAAC,EAAE;UACvBlB,QAAQ,CAACmB,KAAK,CAACD,QAAQ,CAACA,QAAQ,CAAC;QACnC;QACAvF,KAAK,CAACuB,OAAO,GAAG,IAAI;MACtB;MACA,IAAI,CAACkE,cAAc,GAAG,UAASpB,QAAQ,EAAEC,KAAK,EAAEvE,MAAM,EAAE;QACtD,IAAIA,MAAM,CAACW,QAAQ,CAACC,SAAS,KAAK,IAAI,EACpC;QACF,IAAI,CAACY,OAAO,CAACxB,MAAM,CAAC,KAAK,IAAI,EAC3B;QACFsC,oBAAoB,CAAC,CAAC;QACtB6B,mBAAmB,CAACnE,MAAM,CAAC;QAC3BgD,mBAAmB,CAAChD,MAAM,CAAC;QAC3BqE,MAAM,CAACC,QAAQ,EAAEC,KAAK,EAAEvE,MAAM,CAAC;MACjC,CAAC;MACD,IAAI,CAACyE,eAAe,GAAG,YAAW;QAChC,OAAO1D,YAAY;MACrB,CAAC;MACD,IAAI,CAAC4E,OAAO,GAAG,YAAW;QACxB5E,YAAY,CAAC4E,OAAO,CAAC,CAAC;QACtB1F,KAAK,CAACgB,QAAQ,CAAC0E,OAAO,CAAC,CAAC;MAC1B,CAAC;IACH;EACF,CAAC;EACD,IAAIC,UAAU,GAAGlG,UAAU;EAC3BhB,aAAa,CAACkH,UAAU,EAAE,iBAAiB,EAAE;IAC3C1E,QAAQ,EAAE;MACRhB,KAAK,EAAE;QACL5B,KAAK,EAAE;MACT,CAAC;MACDuH,QAAQ,EAAE;QACRvH,KAAK,EAAE;MACT,CAAC;MACDwC,aAAa,EAAE;QACbxC,KAAK,EAAE;MACT;IACF,CAAC;IACD8C,YAAY,GACV;IACA;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,CACC;IACDC,cAAc,GACZ;IACA;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe7B,OAAO,IAAI,GAAG,GAAG,qBAAqB,GAAG,oBAAoB;AAC5E;AACA,IAAI;EAEF,CAAC,CAAC;EACF,OAAOoG,UAAU;AACnB,CAAC,EAAE,CAAC;AACJ,SACEnG,SAAS","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}