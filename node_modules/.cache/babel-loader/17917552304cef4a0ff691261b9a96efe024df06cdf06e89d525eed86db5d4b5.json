{"ast":null,"code":"import { AdditiveBlending, Color, HalfFloatType, MeshBasicMaterial, ShaderMaterial, UniformsUtils, Vector2, Vector3, WebGLRenderTarget } from 'three';\nimport { Pass, FullScreenQuad } from './Pass.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\nimport { LuminosityHighPassShader } from '../shaders/LuminosityHighPassShader.js';\n\n/**\n * This pass is inspired by the bloom pass of Unreal Engine. It creates a\n * mip map chain of bloom textures and blurs them with different radii. Because\n * of the weighted combination of mips, and because larger blurs are done on\n * higher mips, this effect provides good quality and performance.\n *\n * When using this pass, tone mapping must be enabled in the renderer settings.\n *\n * Reference:\n * - [Bloom in Unreal Engine]{@link https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/}\n *\n * ```js\n * const resolution = new THREE.Vector2( window.innerWidth, window.innerHeight );\n * const bloomPass = new UnrealBloomPass( resolution, 1.5, 0.4, 0.85 );\n * composer.addPass( bloomPass );\n * ```\n *\n * @augments Pass\n * @three_import import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';\n */\nclass UnrealBloomPass extends Pass {\n  /**\n   * Constructs a new Unreal Bloom pass.\n   *\n   * @param {Vector2} [resolution] - The effect's resolution.\n   * @param {number} [strength=1] - The Bloom strength.\n   * @param {number} radius - The Bloom radius.\n   * @param {number} threshold - The luminance threshold limits which bright areas contribute to the Bloom effect.\n   */\n  constructor(resolution, strength = 1, radius, threshold) {\n    super();\n\n    /**\n     * The Bloom strength.\n     *\n     * @type {number}\n     * @default 1\n     */\n    this.strength = strength;\n\n    /**\n     * The Bloom radius.\n     *\n     * @type {number}\n     */\n    this.radius = radius;\n\n    /**\n     * The luminance threshold limits which bright areas contribute to the Bloom effect.\n     *\n     * @type {number}\n     */\n    this.threshold = threshold;\n\n    /**\n     * The effect's resolution.\n     *\n     * @type {Vector2}\n     * @default (256,256)\n     */\n    this.resolution = resolution !== undefined ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256);\n\n    /**\n     * The effect's clear color\n     *\n     * @type {Color}\n     * @default (0,0,0)\n     */\n    this.clearColor = new Color(0, 0, 0);\n\n    /**\n     * Overwritten to disable the swap.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    this.needsSwap = false;\n\n    // internals\n\n    // render targets\n    this.renderTargetsHorizontal = [];\n    this.renderTargetsVertical = [];\n    this.nMips = 5;\n    let resx = Math.round(this.resolution.x / 2);\n    let resy = Math.round(this.resolution.y / 2);\n    this.renderTargetBright = new WebGLRenderTarget(resx, resy, {\n      type: HalfFloatType\n    });\n    this.renderTargetBright.texture.name = 'UnrealBloomPass.bright';\n    this.renderTargetBright.texture.generateMipmaps = false;\n    for (let i = 0; i < this.nMips; i++) {\n      const renderTargetHorizontal = new WebGLRenderTarget(resx, resy, {\n        type: HalfFloatType\n      });\n      renderTargetHorizontal.texture.name = 'UnrealBloomPass.h' + i;\n      renderTargetHorizontal.texture.generateMipmaps = false;\n      this.renderTargetsHorizontal.push(renderTargetHorizontal);\n      const renderTargetVertical = new WebGLRenderTarget(resx, resy, {\n        type: HalfFloatType\n      });\n      renderTargetVertical.texture.name = 'UnrealBloomPass.v' + i;\n      renderTargetVertical.texture.generateMipmaps = false;\n      this.renderTargetsVertical.push(renderTargetVertical);\n      resx = Math.round(resx / 2);\n      resy = Math.round(resy / 2);\n    }\n\n    // luminosity high pass material\n\n    const highPassShader = LuminosityHighPassShader;\n    this.highPassUniforms = UniformsUtils.clone(highPassShader.uniforms);\n    this.highPassUniforms['luminosityThreshold'].value = threshold;\n    this.highPassUniforms['smoothWidth'].value = 0.01;\n    this.materialHighPassFilter = new ShaderMaterial({\n      uniforms: this.highPassUniforms,\n      vertexShader: highPassShader.vertexShader,\n      fragmentShader: highPassShader.fragmentShader\n    });\n\n    // gaussian blur materials\n\n    this.separableBlurMaterials = [];\n    const kernelSizeArray = [3, 5, 7, 9, 11];\n    resx = Math.round(this.resolution.x / 2);\n    resy = Math.round(this.resolution.y / 2);\n    for (let i = 0; i < this.nMips; i++) {\n      this.separableBlurMaterials.push(this._getSeparableBlurMaterial(kernelSizeArray[i]));\n      this.separableBlurMaterials[i].uniforms['invSize'].value = new Vector2(1 / resx, 1 / resy);\n      resx = Math.round(resx / 2);\n      resy = Math.round(resy / 2);\n    }\n\n    // composite material\n\n    this.compositeMaterial = this._getCompositeMaterial(this.nMips);\n    this.compositeMaterial.uniforms['blurTexture1'].value = this.renderTargetsVertical[0].texture;\n    this.compositeMaterial.uniforms['blurTexture2'].value = this.renderTargetsVertical[1].texture;\n    this.compositeMaterial.uniforms['blurTexture3'].value = this.renderTargetsVertical[2].texture;\n    this.compositeMaterial.uniforms['blurTexture4'].value = this.renderTargetsVertical[3].texture;\n    this.compositeMaterial.uniforms['blurTexture5'].value = this.renderTargetsVertical[4].texture;\n    this.compositeMaterial.uniforms['bloomStrength'].value = strength;\n    this.compositeMaterial.uniforms['bloomRadius'].value = 0.1;\n    const bloomFactors = [1.0, 0.8, 0.6, 0.4, 0.2];\n    this.compositeMaterial.uniforms['bloomFactors'].value = bloomFactors;\n    this.bloomTintColors = [new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1)];\n    this.compositeMaterial.uniforms['bloomTintColors'].value = this.bloomTintColors;\n\n    // blend material\n\n    this.copyUniforms = UniformsUtils.clone(CopyShader.uniforms);\n    this.blendMaterial = new ShaderMaterial({\n      uniforms: this.copyUniforms,\n      vertexShader: CopyShader.vertexShader,\n      fragmentShader: CopyShader.fragmentShader,\n      blending: AdditiveBlending,\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    this._oldClearColor = new Color();\n    this._oldClearAlpha = 1;\n    this._basic = new MeshBasicMaterial();\n    this._fsQuad = new FullScreenQuad(null);\n  }\n\n  /**\n   * Frees the GPU-related resources allocated by this instance. Call this\n   * method whenever the pass is no longer used in your app.\n   */\n  dispose() {\n    for (let i = 0; i < this.renderTargetsHorizontal.length; i++) {\n      this.renderTargetsHorizontal[i].dispose();\n    }\n    for (let i = 0; i < this.renderTargetsVertical.length; i++) {\n      this.renderTargetsVertical[i].dispose();\n    }\n    this.renderTargetBright.dispose();\n\n    //\n\n    for (let i = 0; i < this.separableBlurMaterials.length; i++) {\n      this.separableBlurMaterials[i].dispose();\n    }\n    this.compositeMaterial.dispose();\n    this.blendMaterial.dispose();\n    this._basic.dispose();\n\n    //\n\n    this._fsQuad.dispose();\n  }\n\n  /**\n   * Sets the size of the pass.\n   *\n   * @param {number} width - The width to set.\n   * @param {number} height - The height to set.\n   */\n  setSize(width, height) {\n    let resx = Math.round(width / 2);\n    let resy = Math.round(height / 2);\n    this.renderTargetBright.setSize(resx, resy);\n    for (let i = 0; i < this.nMips; i++) {\n      this.renderTargetsHorizontal[i].setSize(resx, resy);\n      this.renderTargetsVertical[i].setSize(resx, resy);\n      this.separableBlurMaterials[i].uniforms['invSize'].value = new Vector2(1 / resx, 1 / resy);\n      resx = Math.round(resx / 2);\n      resy = Math.round(resy / 2);\n    }\n  }\n\n  /**\n   * Performs the Bloom pass.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering\n   * destination for the pass.\n   * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the\n   * previous pass from this buffer.\n   * @param {number} deltaTime - The delta time in seconds.\n   * @param {boolean} maskActive - Whether masking is active or not.\n   */\n  render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n    renderer.getClearColor(this._oldClearColor);\n    this._oldClearAlpha = renderer.getClearAlpha();\n    const oldAutoClear = renderer.autoClear;\n    renderer.autoClear = false;\n    renderer.setClearColor(this.clearColor, 0);\n    if (maskActive) renderer.state.buffers.stencil.setTest(false);\n\n    // Render input to screen\n\n    if (this.renderToScreen) {\n      this._fsQuad.material = this._basic;\n      this._basic.map = readBuffer.texture;\n      renderer.setRenderTarget(null);\n      renderer.clear();\n      this._fsQuad.render(renderer);\n    }\n\n    // 1. Extract Bright Areas\n\n    this.highPassUniforms['tDiffuse'].value = readBuffer.texture;\n    this.highPassUniforms['luminosityThreshold'].value = this.threshold;\n    this._fsQuad.material = this.materialHighPassFilter;\n    renderer.setRenderTarget(this.renderTargetBright);\n    renderer.clear();\n    this._fsQuad.render(renderer);\n\n    // 2. Blur All the mips progressively\n\n    let inputRenderTarget = this.renderTargetBright;\n    for (let i = 0; i < this.nMips; i++) {\n      this._fsQuad.material = this.separableBlurMaterials[i];\n      this.separableBlurMaterials[i].uniforms['colorTexture'].value = inputRenderTarget.texture;\n      this.separableBlurMaterials[i].uniforms['direction'].value = UnrealBloomPass.BlurDirectionX;\n      renderer.setRenderTarget(this.renderTargetsHorizontal[i]);\n      renderer.clear();\n      this._fsQuad.render(renderer);\n      this.separableBlurMaterials[i].uniforms['colorTexture'].value = this.renderTargetsHorizontal[i].texture;\n      this.separableBlurMaterials[i].uniforms['direction'].value = UnrealBloomPass.BlurDirectionY;\n      renderer.setRenderTarget(this.renderTargetsVertical[i]);\n      renderer.clear();\n      this._fsQuad.render(renderer);\n      inputRenderTarget = this.renderTargetsVertical[i];\n    }\n\n    // Composite All the mips\n\n    this._fsQuad.material = this.compositeMaterial;\n    this.compositeMaterial.uniforms['bloomStrength'].value = this.strength;\n    this.compositeMaterial.uniforms['bloomRadius'].value = this.radius;\n    this.compositeMaterial.uniforms['bloomTintColors'].value = this.bloomTintColors;\n    renderer.setRenderTarget(this.renderTargetsHorizontal[0]);\n    renderer.clear();\n    this._fsQuad.render(renderer);\n\n    // Blend it additively over the input texture\n\n    this._fsQuad.material = this.blendMaterial;\n    this.copyUniforms['tDiffuse'].value = this.renderTargetsHorizontal[0].texture;\n    if (maskActive) renderer.state.buffers.stencil.setTest(true);\n    if (this.renderToScreen) {\n      renderer.setRenderTarget(null);\n      this._fsQuad.render(renderer);\n    } else {\n      renderer.setRenderTarget(readBuffer);\n      this._fsQuad.render(renderer);\n    }\n\n    // Restore renderer settings\n\n    renderer.setClearColor(this._oldClearColor, this._oldClearAlpha);\n    renderer.autoClear = oldAutoClear;\n  }\n\n  // internals\n\n  _getSeparableBlurMaterial(kernelRadius) {\n    const coefficients = [];\n    for (let i = 0; i < kernelRadius; i++) {\n      coefficients.push(0.39894 * Math.exp(-0.5 * i * i / (kernelRadius * kernelRadius)) / kernelRadius);\n    }\n    return new ShaderMaterial({\n      defines: {\n        'KERNEL_RADIUS': kernelRadius\n      },\n      uniforms: {\n        'colorTexture': {\n          value: null\n        },\n        'invSize': {\n          value: new Vector2(0.5, 0.5)\n        },\n        // inverse texture size\n        'direction': {\n          value: new Vector2(0.5, 0.5)\n        },\n        'gaussianCoefficients': {\n          value: coefficients\n        } // precomputed Gaussian coefficients\n      },\n      vertexShader: `varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n      fragmentShader: `#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 invSize;\n\t\t\t\tuniform vec2 direction;\n\t\t\t\tuniform float gaussianCoefficients[KERNEL_RADIUS];\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tfloat weightSum = gaussianCoefficients[0];\n\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv ).rgb * weightSum;\n\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat x = float(i);\n\t\t\t\t\t\tfloat w = gaussianCoefficients[i];\n\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\n\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset ).rgb;\n\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset ).rgb;\n\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\n\t\t\t\t\t\tweightSum += 2.0 * w;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n\t\t\t\t}`\n    });\n  }\n  _getCompositeMaterial(nMips) {\n    return new ShaderMaterial({\n      defines: {\n        'NUM_MIPS': nMips\n      },\n      uniforms: {\n        'blurTexture1': {\n          value: null\n        },\n        'blurTexture2': {\n          value: null\n        },\n        'blurTexture3': {\n          value: null\n        },\n        'blurTexture4': {\n          value: null\n        },\n        'blurTexture5': {\n          value: null\n        },\n        'bloomStrength': {\n          value: 1.0\n        },\n        'bloomFactors': {\n          value: null\n        },\n        'bloomTintColors': {\n          value: null\n        },\n        'bloomRadius': {\n          value: 0.0\n        }\n      },\n      vertexShader: `varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n      fragmentShader: `varying vec2 vUv;\n\t\t\t\tuniform sampler2D blurTexture1;\n\t\t\t\tuniform sampler2D blurTexture2;\n\t\t\t\tuniform sampler2D blurTexture3;\n\t\t\t\tuniform sampler2D blurTexture4;\n\t\t\t\tuniform sampler2D blurTexture5;\n\t\t\t\tuniform float bloomStrength;\n\t\t\t\tuniform float bloomRadius;\n\t\t\t\tuniform float bloomFactors[NUM_MIPS];\n\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\n\n\t\t\t\tfloat lerpBloomFactor(const in float factor) {\n\t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\n\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\n\t\t\t\t}`\n    });\n  }\n}\nUnrealBloomPass.BlurDirectionX = new Vector2(1.0, 0.0);\nUnrealBloomPass.BlurDirectionY = new Vector2(0.0, 1.0);\nexport { UnrealBloomPass };","map":{"version":3,"names":["AdditiveBlending","Color","HalfFloatType","MeshBasicMaterial","ShaderMaterial","UniformsUtils","Vector2","Vector3","WebGLRenderTarget","Pass","FullScreenQuad","CopyShader","LuminosityHighPassShader","UnrealBloomPass","constructor","resolution","strength","radius","threshold","undefined","x","y","clearColor","needsSwap","renderTargetsHorizontal","renderTargetsVertical","nMips","resx","Math","round","resy","renderTargetBright","type","texture","name","generateMipmaps","i","renderTargetHorizontal","push","renderTargetVertical","highPassShader","highPassUniforms","clone","uniforms","value","materialHighPassFilter","vertexShader","fragmentShader","separableBlurMaterials","kernelSizeArray","_getSeparableBlurMaterial","compositeMaterial","_getCompositeMaterial","bloomFactors","bloomTintColors","copyUniforms","blendMaterial","blending","depthTest","depthWrite","transparent","_oldClearColor","_oldClearAlpha","_basic","_fsQuad","dispose","length","setSize","width","height","render","renderer","writeBuffer","readBuffer","deltaTime","maskActive","getClearColor","getClearAlpha","oldAutoClear","autoClear","setClearColor","state","buffers","stencil","setTest","renderToScreen","material","map","setRenderTarget","clear","inputRenderTarget","BlurDirectionX","BlurDirectionY","kernelRadius","coefficients","exp","defines"],"sources":["C:/Users/srk/Downloads/arq_phantom_clone/node_modules/three/examples/jsm/postprocessing/UnrealBloomPass.js"],"sourcesContent":["import {\n\tAdditiveBlending,\n\tColor,\n\tHalfFloatType,\n\tMeshBasicMaterial,\n\tShaderMaterial,\n\tUniformsUtils,\n\tVector2,\n\tVector3,\n\tWebGLRenderTarget\n} from 'three';\nimport { Pass, FullScreenQuad } from './Pass.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\nimport { LuminosityHighPassShader } from '../shaders/LuminosityHighPassShader.js';\n\n/**\n * This pass is inspired by the bloom pass of Unreal Engine. It creates a\n * mip map chain of bloom textures and blurs them with different radii. Because\n * of the weighted combination of mips, and because larger blurs are done on\n * higher mips, this effect provides good quality and performance.\n *\n * When using this pass, tone mapping must be enabled in the renderer settings.\n *\n * Reference:\n * - [Bloom in Unreal Engine]{@link https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/}\n *\n * ```js\n * const resolution = new THREE.Vector2( window.innerWidth, window.innerHeight );\n * const bloomPass = new UnrealBloomPass( resolution, 1.5, 0.4, 0.85 );\n * composer.addPass( bloomPass );\n * ```\n *\n * @augments Pass\n * @three_import import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';\n */\nclass UnrealBloomPass extends Pass {\n\n\t/**\n\t * Constructs a new Unreal Bloom pass.\n\t *\n\t * @param {Vector2} [resolution] - The effect's resolution.\n\t * @param {number} [strength=1] - The Bloom strength.\n\t * @param {number} radius - The Bloom radius.\n\t * @param {number} threshold - The luminance threshold limits which bright areas contribute to the Bloom effect.\n\t */\n\tconstructor( resolution, strength = 1, radius, threshold ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The Bloom strength.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis.strength = strength;\n\n\t\t/**\n\t\t * The Bloom radius.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.radius = radius;\n\n\t\t/**\n\t\t * The luminance threshold limits which bright areas contribute to the Bloom effect.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.threshold = threshold;\n\n\t\t/**\n\t\t * The effect's resolution.\n\t\t *\n\t\t * @type {Vector2}\n\t\t * @default (256,256)\n\t\t */\n\t\tthis.resolution = ( resolution !== undefined ) ? new Vector2( resolution.x, resolution.y ) : new Vector2( 256, 256 );\n\n\t\t/**\n\t\t * The effect's clear color\n\t\t *\n\t\t * @type {Color}\n\t\t * @default (0,0,0)\n\t\t */\n\t\tthis.clearColor = new Color( 0, 0, 0 );\n\n\t\t/**\n\t\t * Overwritten to disable the swap.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.needsSwap = false;\n\n\t\t// internals\n\n\t\t// render targets\n\t\tthis.renderTargetsHorizontal = [];\n\t\tthis.renderTargetsVertical = [];\n\t\tthis.nMips = 5;\n\t\tlet resx = Math.round( this.resolution.x / 2 );\n\t\tlet resy = Math.round( this.resolution.y / 2 );\n\n\t\tthis.renderTargetBright = new WebGLRenderTarget( resx, resy, { type: HalfFloatType } );\n\t\tthis.renderTargetBright.texture.name = 'UnrealBloomPass.bright';\n\t\tthis.renderTargetBright.texture.generateMipmaps = false;\n\n\t\tfor ( let i = 0; i < this.nMips; i ++ ) {\n\n\t\t\tconst renderTargetHorizontal = new WebGLRenderTarget( resx, resy, { type: HalfFloatType } );\n\n\t\t\trenderTargetHorizontal.texture.name = 'UnrealBloomPass.h' + i;\n\t\t\trenderTargetHorizontal.texture.generateMipmaps = false;\n\n\t\t\tthis.renderTargetsHorizontal.push( renderTargetHorizontal );\n\n\t\t\tconst renderTargetVertical = new WebGLRenderTarget( resx, resy, { type: HalfFloatType } );\n\n\t\t\trenderTargetVertical.texture.name = 'UnrealBloomPass.v' + i;\n\t\t\trenderTargetVertical.texture.generateMipmaps = false;\n\n\t\t\tthis.renderTargetsVertical.push( renderTargetVertical );\n\n\t\t\tresx = Math.round( resx / 2 );\n\n\t\t\tresy = Math.round( resy / 2 );\n\n\t\t}\n\n\t\t// luminosity high pass material\n\n\t\tconst highPassShader = LuminosityHighPassShader;\n\t\tthis.highPassUniforms = UniformsUtils.clone( highPassShader.uniforms );\n\n\t\tthis.highPassUniforms[ 'luminosityThreshold' ].value = threshold;\n\t\tthis.highPassUniforms[ 'smoothWidth' ].value = 0.01;\n\n\t\tthis.materialHighPassFilter = new ShaderMaterial( {\n\t\t\tuniforms: this.highPassUniforms,\n\t\t\tvertexShader: highPassShader.vertexShader,\n\t\t\tfragmentShader: highPassShader.fragmentShader\n\t\t} );\n\n\t\t// gaussian blur materials\n\n\t\tthis.separableBlurMaterials = [];\n\t\tconst kernelSizeArray = [ 3, 5, 7, 9, 11 ];\n\t\tresx = Math.round( this.resolution.x / 2 );\n\t\tresy = Math.round( this.resolution.y / 2 );\n\n\t\tfor ( let i = 0; i < this.nMips; i ++ ) {\n\n\t\t\tthis.separableBlurMaterials.push( this._getSeparableBlurMaterial( kernelSizeArray[ i ] ) );\n\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'invSize' ].value = new Vector2( 1 / resx, 1 / resy );\n\n\t\t\tresx = Math.round( resx / 2 );\n\n\t\t\tresy = Math.round( resy / 2 );\n\n\t\t}\n\n\t\t// composite material\n\n\t\tthis.compositeMaterial = this._getCompositeMaterial( this.nMips );\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture1' ].value = this.renderTargetsVertical[ 0 ].texture;\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture2' ].value = this.renderTargetsVertical[ 1 ].texture;\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture3' ].value = this.renderTargetsVertical[ 2 ].texture;\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture4' ].value = this.renderTargetsVertical[ 3 ].texture;\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture5' ].value = this.renderTargetsVertical[ 4 ].texture;\n\t\tthis.compositeMaterial.uniforms[ 'bloomStrength' ].value = strength;\n\t\tthis.compositeMaterial.uniforms[ 'bloomRadius' ].value = 0.1;\n\n\t\tconst bloomFactors = [ 1.0, 0.8, 0.6, 0.4, 0.2 ];\n\t\tthis.compositeMaterial.uniforms[ 'bloomFactors' ].value = bloomFactors;\n\t\tthis.bloomTintColors = [ new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ) ];\n\t\tthis.compositeMaterial.uniforms[ 'bloomTintColors' ].value = this.bloomTintColors;\n\n\t\t// blend material\n\n\t\tthis.copyUniforms = UniformsUtils.clone( CopyShader.uniforms );\n\n\t\tthis.blendMaterial = new ShaderMaterial( {\n\t\t\tuniforms: this.copyUniforms,\n\t\t\tvertexShader: CopyShader.vertexShader,\n\t\t\tfragmentShader: CopyShader.fragmentShader,\n\t\t\tblending: AdditiveBlending,\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false,\n\t\t\ttransparent: true\n\t\t} );\n\n\t\tthis._oldClearColor = new Color();\n\t\tthis._oldClearAlpha = 1;\n\n\t\tthis._basic = new MeshBasicMaterial();\n\n\t\tthis._fsQuad = new FullScreenQuad( null );\n\n\t}\n\n\t/**\n\t * Frees the GPU-related resources allocated by this instance. Call this\n\t * method whenever the pass is no longer used in your app.\n\t */\n\tdispose() {\n\n\t\tfor ( let i = 0; i < this.renderTargetsHorizontal.length; i ++ ) {\n\n\t\t\tthis.renderTargetsHorizontal[ i ].dispose();\n\n\t\t}\n\n\t\tfor ( let i = 0; i < this.renderTargetsVertical.length; i ++ ) {\n\n\t\t\tthis.renderTargetsVertical[ i ].dispose();\n\n\t\t}\n\n\t\tthis.renderTargetBright.dispose();\n\n\t\t//\n\n\t\tfor ( let i = 0; i < this.separableBlurMaterials.length; i ++ ) {\n\n\t\t\tthis.separableBlurMaterials[ i ].dispose();\n\n\t\t}\n\n\t\tthis.compositeMaterial.dispose();\n\t\tthis.blendMaterial.dispose();\n\t\tthis._basic.dispose();\n\n\t\t//\n\n\t\tthis._fsQuad.dispose();\n\n\t}\n\n\t/**\n\t * Sets the size of the pass.\n\t *\n\t * @param {number} width - The width to set.\n\t * @param {number} height - The height to set.\n\t */\n\tsetSize( width, height ) {\n\n\t\tlet resx = Math.round( width / 2 );\n\t\tlet resy = Math.round( height / 2 );\n\n\t\tthis.renderTargetBright.setSize( resx, resy );\n\n\t\tfor ( let i = 0; i < this.nMips; i ++ ) {\n\n\t\t\tthis.renderTargetsHorizontal[ i ].setSize( resx, resy );\n\t\t\tthis.renderTargetsVertical[ i ].setSize( resx, resy );\n\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'invSize' ].value = new Vector2( 1 / resx, 1 / resy );\n\n\t\t\tresx = Math.round( resx / 2 );\n\t\t\tresy = Math.round( resy / 2 );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Performs the Bloom pass.\n\t *\n\t * @param {WebGLRenderer} renderer - The renderer.\n\t * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering\n\t * destination for the pass.\n\t * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the\n\t * previous pass from this buffer.\n\t * @param {number} deltaTime - The delta time in seconds.\n\t * @param {boolean} maskActive - Whether masking is active or not.\n\t */\n\trender( renderer, writeBuffer, readBuffer, deltaTime, maskActive ) {\n\n\t\trenderer.getClearColor( this._oldClearColor );\n\t\tthis._oldClearAlpha = renderer.getClearAlpha();\n\t\tconst oldAutoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\n\t\trenderer.setClearColor( this.clearColor, 0 );\n\n\t\tif ( maskActive ) renderer.state.buffers.stencil.setTest( false );\n\n\t\t// Render input to screen\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\tthis._fsQuad.material = this._basic;\n\t\t\tthis._basic.map = readBuffer.texture;\n\n\t\t\trenderer.setRenderTarget( null );\n\t\t\trenderer.clear();\n\t\t\tthis._fsQuad.render( renderer );\n\n\t\t}\n\n\t\t// 1. Extract Bright Areas\n\n\t\tthis.highPassUniforms[ 'tDiffuse' ].value = readBuffer.texture;\n\t\tthis.highPassUniforms[ 'luminosityThreshold' ].value = this.threshold;\n\t\tthis._fsQuad.material = this.materialHighPassFilter;\n\n\t\trenderer.setRenderTarget( this.renderTargetBright );\n\t\trenderer.clear();\n\t\tthis._fsQuad.render( renderer );\n\n\t\t// 2. Blur All the mips progressively\n\n\t\tlet inputRenderTarget = this.renderTargetBright;\n\n\t\tfor ( let i = 0; i < this.nMips; i ++ ) {\n\n\t\t\tthis._fsQuad.material = this.separableBlurMaterials[ i ];\n\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'colorTexture' ].value = inputRenderTarget.texture;\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'direction' ].value = UnrealBloomPass.BlurDirectionX;\n\t\t\trenderer.setRenderTarget( this.renderTargetsHorizontal[ i ] );\n\t\t\trenderer.clear();\n\t\t\tthis._fsQuad.render( renderer );\n\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'colorTexture' ].value = this.renderTargetsHorizontal[ i ].texture;\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'direction' ].value = UnrealBloomPass.BlurDirectionY;\n\t\t\trenderer.setRenderTarget( this.renderTargetsVertical[ i ] );\n\t\t\trenderer.clear();\n\t\t\tthis._fsQuad.render( renderer );\n\n\t\t\tinputRenderTarget = this.renderTargetsVertical[ i ];\n\n\t\t}\n\n\t\t// Composite All the mips\n\n\t\tthis._fsQuad.material = this.compositeMaterial;\n\t\tthis.compositeMaterial.uniforms[ 'bloomStrength' ].value = this.strength;\n\t\tthis.compositeMaterial.uniforms[ 'bloomRadius' ].value = this.radius;\n\t\tthis.compositeMaterial.uniforms[ 'bloomTintColors' ].value = this.bloomTintColors;\n\n\t\trenderer.setRenderTarget( this.renderTargetsHorizontal[ 0 ] );\n\t\trenderer.clear();\n\t\tthis._fsQuad.render( renderer );\n\n\t\t// Blend it additively over the input texture\n\n\t\tthis._fsQuad.material = this.blendMaterial;\n\t\tthis.copyUniforms[ 'tDiffuse' ].value = this.renderTargetsHorizontal[ 0 ].texture;\n\n\t\tif ( maskActive ) renderer.state.buffers.stencil.setTest( true );\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\trenderer.setRenderTarget( null );\n\t\t\tthis._fsQuad.render( renderer );\n\n\t\t} else {\n\n\t\t\trenderer.setRenderTarget( readBuffer );\n\t\t\tthis._fsQuad.render( renderer );\n\n\t\t}\n\n\t\t// Restore renderer settings\n\n\t\trenderer.setClearColor( this._oldClearColor, this._oldClearAlpha );\n\t\trenderer.autoClear = oldAutoClear;\n\n\t}\n\n\t// internals\n\n\t_getSeparableBlurMaterial( kernelRadius ) {\n\n\t\tconst coefficients = [];\n\n\t\tfor ( let i = 0; i < kernelRadius; i ++ ) {\n\n\t\t\tcoefficients.push( 0.39894 * Math.exp( - 0.5 * i * i / ( kernelRadius * kernelRadius ) ) / kernelRadius );\n\n\t\t}\n\n\t\treturn new ShaderMaterial( {\n\n\t\t\tdefines: {\n\t\t\t\t'KERNEL_RADIUS': kernelRadius\n\t\t\t},\n\n\t\t\tuniforms: {\n\t\t\t\t'colorTexture': { value: null },\n\t\t\t\t'invSize': { value: new Vector2( 0.5, 0.5 ) }, // inverse texture size\n\t\t\t\t'direction': { value: new Vector2( 0.5, 0.5 ) },\n\t\t\t\t'gaussianCoefficients': { value: coefficients } // precomputed Gaussian coefficients\n\t\t\t},\n\n\t\t\tvertexShader:\n\t\t\t\t`varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n\n\t\t\tfragmentShader:\n\t\t\t\t`#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 invSize;\n\t\t\t\tuniform vec2 direction;\n\t\t\t\tuniform float gaussianCoefficients[KERNEL_RADIUS];\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tfloat weightSum = gaussianCoefficients[0];\n\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv ).rgb * weightSum;\n\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat x = float(i);\n\t\t\t\t\t\tfloat w = gaussianCoefficients[i];\n\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\n\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset ).rgb;\n\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset ).rgb;\n\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\n\t\t\t\t\t\tweightSum += 2.0 * w;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n\t\t\t\t}`\n\t\t} );\n\n\t}\n\n\t_getCompositeMaterial( nMips ) {\n\n\t\treturn new ShaderMaterial( {\n\n\t\t\tdefines: {\n\t\t\t\t'NUM_MIPS': nMips\n\t\t\t},\n\n\t\t\tuniforms: {\n\t\t\t\t'blurTexture1': { value: null },\n\t\t\t\t'blurTexture2': { value: null },\n\t\t\t\t'blurTexture3': { value: null },\n\t\t\t\t'blurTexture4': { value: null },\n\t\t\t\t'blurTexture5': { value: null },\n\t\t\t\t'bloomStrength': { value: 1.0 },\n\t\t\t\t'bloomFactors': { value: null },\n\t\t\t\t'bloomTintColors': { value: null },\n\t\t\t\t'bloomRadius': { value: 0.0 }\n\t\t\t},\n\n\t\t\tvertexShader:\n\t\t\t\t`varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n\n\t\t\tfragmentShader:\n\t\t\t\t`varying vec2 vUv;\n\t\t\t\tuniform sampler2D blurTexture1;\n\t\t\t\tuniform sampler2D blurTexture2;\n\t\t\t\tuniform sampler2D blurTexture3;\n\t\t\t\tuniform sampler2D blurTexture4;\n\t\t\t\tuniform sampler2D blurTexture5;\n\t\t\t\tuniform float bloomStrength;\n\t\t\t\tuniform float bloomRadius;\n\t\t\t\tuniform float bloomFactors[NUM_MIPS];\n\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\n\n\t\t\t\tfloat lerpBloomFactor(const in float factor) {\n\t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\n\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\n\t\t\t\t}`\n\t\t} );\n\n\t}\n\n}\n\nUnrealBloomPass.BlurDirectionX = new Vector2( 1.0, 0.0 );\nUnrealBloomPass.BlurDirectionY = new Vector2( 0.0, 1.0 );\n\nexport { UnrealBloomPass };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}