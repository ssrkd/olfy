{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Mesh, Vector4, Color, Vector2, Matrix4, Clock, ShaderMaterial, UniformsUtils, UniformsLib, RepeatWrapping } from \"three\";\nimport { Reflector } from \"./Reflector.js\";\nimport { Refractor } from \"./Refractor.js\";\nimport { version } from \"../_polyfill/constants.js\";\nconst Water2 = /* @__PURE__ */(() => {\n  const _Water2 = class extends Mesh {\n    constructor(geometry, options = {}) {\n      super(geometry);\n      this.isWater = true;\n      this.type = \"Water\";\n      const scope = this;\n      const color = options.color !== void 0 ? new Color(options.color) : new Color(16777215);\n      const textureWidth = options.textureWidth || 512;\n      const textureHeight = options.textureHeight || 512;\n      const clipBias = options.clipBias || 0;\n      const flowDirection = options.flowDirection || new Vector2(1, 0);\n      const flowSpeed = options.flowSpeed || 0.03;\n      const reflectivity = options.reflectivity || 0.02;\n      const scale = options.scale || 1;\n      const shader = options.shader || _Water2.WaterShader;\n      const encoding = options.encoding !== void 0 ? options.encoding : 3e3;\n      const flowMap = options.flowMap || void 0;\n      const normalMap0 = options.normalMap0;\n      const normalMap1 = options.normalMap1;\n      const cycle = 0.15;\n      const halfCycle = cycle * 0.5;\n      const textureMatrix = new Matrix4();\n      const clock = new Clock();\n      if (Reflector === void 0) {\n        console.error(\"THREE.Water: Required component Reflector not found.\");\n        return;\n      }\n      if (Refractor === void 0) {\n        console.error(\"THREE.Water: Required component Refractor not found.\");\n        return;\n      }\n      const reflector = new Reflector(geometry, {\n        textureWidth,\n        textureHeight,\n        clipBias,\n        encoding\n      });\n      const refractor = new Refractor(geometry, {\n        textureWidth,\n        textureHeight,\n        clipBias,\n        encoding\n      });\n      reflector.matrixAutoUpdate = false;\n      refractor.matrixAutoUpdate = false;\n      this.material = new ShaderMaterial({\n        uniforms: UniformsUtils.merge([UniformsLib[\"fog\"], shader.uniforms]),\n        vertexShader: shader.vertexShader,\n        fragmentShader: shader.fragmentShader,\n        transparent: true,\n        fog: true\n      });\n      if (flowMap !== void 0) {\n        this.material.defines.USE_FLOWMAP = \"\";\n        this.material.uniforms[\"tFlowMap\"] = {\n          type: \"t\",\n          value: flowMap\n        };\n      } else {\n        this.material.uniforms[\"flowDirection\"] = {\n          type: \"v2\",\n          value: flowDirection\n        };\n      }\n      normalMap0.wrapS = normalMap0.wrapT = RepeatWrapping;\n      normalMap1.wrapS = normalMap1.wrapT = RepeatWrapping;\n      this.material.uniforms[\"tReflectionMap\"].value = reflector.getRenderTarget().texture;\n      this.material.uniforms[\"tRefractionMap\"].value = refractor.getRenderTarget().texture;\n      this.material.uniforms[\"tNormalMap0\"].value = normalMap0;\n      this.material.uniforms[\"tNormalMap1\"].value = normalMap1;\n      this.material.uniforms[\"color\"].value = color;\n      this.material.uniforms[\"reflectivity\"].value = reflectivity;\n      this.material.uniforms[\"textureMatrix\"].value = textureMatrix;\n      this.material.uniforms[\"config\"].value.x = 0;\n      this.material.uniforms[\"config\"].value.y = halfCycle;\n      this.material.uniforms[\"config\"].value.z = halfCycle;\n      this.material.uniforms[\"config\"].value.w = scale;\n      function updateTextureMatrix(camera) {\n        textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);\n        textureMatrix.multiply(camera.projectionMatrix);\n        textureMatrix.multiply(camera.matrixWorldInverse);\n        textureMatrix.multiply(scope.matrixWorld);\n      }\n      function updateFlow() {\n        const delta = clock.getDelta();\n        const config = scope.material.uniforms[\"config\"];\n        config.value.x += flowSpeed * delta;\n        config.value.y = config.value.x + halfCycle;\n        if (config.value.x >= cycle) {\n          config.value.x = 0;\n          config.value.y = halfCycle;\n        } else if (config.value.y >= cycle) {\n          config.value.y = config.value.y - cycle;\n        }\n      }\n      this.onBeforeRender = function (renderer, scene, camera) {\n        updateTextureMatrix(camera);\n        updateFlow();\n        scope.visible = false;\n        reflector.matrixWorld.copy(scope.matrixWorld);\n        refractor.matrixWorld.copy(scope.matrixWorld);\n        reflector.onBeforeRender(renderer, scene, camera);\n        refractor.onBeforeRender(renderer, scene, camera);\n        scope.visible = true;\n      };\n    }\n  };\n  let Water22 = _Water2;\n  __publicField(Water22, \"WaterShader\", {\n    uniforms: {\n      color: {\n        value: null\n      },\n      reflectivity: {\n        value: 0\n      },\n      tReflectionMap: {\n        value: null\n      },\n      tRefractionMap: {\n        value: null\n      },\n      tNormalMap0: {\n        value: null\n      },\n      tNormalMap1: {\n        value: null\n      },\n      textureMatrix: {\n        value: null\n      },\n      config: {\n        value: /* @__PURE__ */new Vector4()\n      }\n    },\n    vertexShader: (/* glsl */\n    `\n\n\t\t#include <common>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tuniform mat4 textureMatrix;\n\n\t\tvarying vec4 vCoord;\n\t\tvarying vec2 vUv;\n\t\tvarying vec3 vToEye;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tvCoord = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\t\t\tvToEye = cameraPosition - worldPosition.xyz;\n\n\t\t\tvec4 mvPosition =  viewMatrix * worldPosition; // used in fog_vertex\n\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}`),\n    fragmentShader: (/* glsl */\n    `\n\n\t\t#include <common>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tuniform sampler2D tReflectionMap;\n\t\tuniform sampler2D tRefractionMap;\n\t\tuniform sampler2D tNormalMap0;\n\t\tuniform sampler2D tNormalMap1;\n\n\t\t#ifdef USE_FLOWMAP\n\t\t\tuniform sampler2D tFlowMap;\n\t\t#else\n\t\t\tuniform vec2 flowDirection;\n\t\t#endif\n\n\t\tuniform vec3 color;\n\t\tuniform float reflectivity;\n\t\tuniform vec4 config;\n\n\t\tvarying vec4 vCoord;\n\t\tvarying vec2 vUv;\n\t\tvarying vec3 vToEye;\n\n\t\tvoid main() {\n\n\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\tfloat flowMapOffset0 = config.x;\n\t\t\tfloat flowMapOffset1 = config.y;\n\t\t\tfloat halfCycle = config.z;\n\t\t\tfloat scale = config.w;\n\n\t\t\tvec3 toEye = normalize( vToEye );\n\n\t\t\t// determine flow direction\n\t\t\tvec2 flow;\n\t\t\t#ifdef USE_FLOWMAP\n\t\t\t\tflow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;\n\t\t\t#else\n\t\t\t\tflow = flowDirection;\n\t\t\t#endif\n\t\t\tflow.x *= - 1.0;\n\n\t\t\t// sample normal maps (distort uvs with flowdata)\n\t\t\tvec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );\n\t\t\tvec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );\n\n\t\t\t// linear interpolate to get the final normal color\n\t\t\tfloat flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;\n\t\t\tvec4 normalColor = mix( normalColor0, normalColor1, flowLerp );\n\n\t\t\t// calculate normal vector\n\t\t\tvec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );\n\n\t\t\t// calculate the fresnel term to blend reflection and refraction maps\n\t\t\tfloat theta = max( dot( toEye, normal ), 0.0 );\n\t\t\tfloat reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );\n\n\t\t\t// calculate final uv coords\n\t\t\tvec3 coord = vCoord.xyz / vCoord.w;\n\t\t\tvec2 uv = coord.xy + coord.z * normal.xz * 0.05;\n\n\t\t\tvec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );\n\t\t\tvec4 refractColor = texture2D( tRefractionMap, uv );\n\n\t\t\t// multiply water color with the mix of both textures\n\t\t\tgl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <${version >= 154 ? \"colorspace_fragment\" : \"encodings_fragment\"}>\n\t\t\t#include <fog_fragment>\n\n\t\t}`)\n  });\n  return Water22;\n})();\nexport { Water2 };","map":{"version":3,"names":["__defProp","Object","defineProperty","__defNormalProp","obj","key","value","enumerable","configurable","writable","__publicField","Mesh","Vector4","Color","Vector2","Matrix4","Clock","ShaderMaterial","UniformsUtils","UniformsLib","RepeatWrapping","Reflector","Refractor","version","Water2","_Water2","constructor","geometry","options","isWater","type","scope","color","textureWidth","textureHeight","clipBias","flowDirection","flowSpeed","reflectivity","scale","shader","WaterShader","encoding","flowMap","normalMap0","normalMap1","cycle","halfCycle","textureMatrix","clock","console","error","reflector","refractor","matrixAutoUpdate","material","uniforms","merge","vertexShader","fragmentShader","transparent","fog","defines","USE_FLOWMAP","wrapS","wrapT","getRenderTarget","texture","x","y","z","w","updateTextureMatrix","camera","set","multiply","projectionMatrix","matrixWorldInverse","matrixWorld","updateFlow","delta","getDelta","config","onBeforeRender","renderer","scene","visible","copy","Water22","tReflectionMap","tRefractionMap","tNormalMap0","tNormalMap1"],"sources":["C:/Users/srk/Downloads/arq_phantom_clone/node_modules/three-stdlib/objects/Water2.js"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Mesh, Vector4, Color, Vector2, Matrix4, Clock, ShaderMaterial, UniformsUtils, UniformsLib, RepeatWrapping } from \"three\";\nimport { Reflector } from \"./Reflector.js\";\nimport { Refractor } from \"./Refractor.js\";\nimport { version } from \"../_polyfill/constants.js\";\nconst Water2 = /* @__PURE__ */ (() => {\n  const _Water2 = class extends Mesh {\n    constructor(geometry, options = {}) {\n      super(geometry);\n      this.isWater = true;\n      this.type = \"Water\";\n      const scope = this;\n      const color = options.color !== void 0 ? new Color(options.color) : new Color(16777215);\n      const textureWidth = options.textureWidth || 512;\n      const textureHeight = options.textureHeight || 512;\n      const clipBias = options.clipBias || 0;\n      const flowDirection = options.flowDirection || new Vector2(1, 0);\n      const flowSpeed = options.flowSpeed || 0.03;\n      const reflectivity = options.reflectivity || 0.02;\n      const scale = options.scale || 1;\n      const shader = options.shader || _Water2.WaterShader;\n      const encoding = options.encoding !== void 0 ? options.encoding : 3e3;\n      const flowMap = options.flowMap || void 0;\n      const normalMap0 = options.normalMap0;\n      const normalMap1 = options.normalMap1;\n      const cycle = 0.15;\n      const halfCycle = cycle * 0.5;\n      const textureMatrix = new Matrix4();\n      const clock = new Clock();\n      if (Reflector === void 0) {\n        console.error(\"THREE.Water: Required component Reflector not found.\");\n        return;\n      }\n      if (Refractor === void 0) {\n        console.error(\"THREE.Water: Required component Refractor not found.\");\n        return;\n      }\n      const reflector = new Reflector(geometry, {\n        textureWidth,\n        textureHeight,\n        clipBias,\n        encoding\n      });\n      const refractor = new Refractor(geometry, {\n        textureWidth,\n        textureHeight,\n        clipBias,\n        encoding\n      });\n      reflector.matrixAutoUpdate = false;\n      refractor.matrixAutoUpdate = false;\n      this.material = new ShaderMaterial({\n        uniforms: UniformsUtils.merge([UniformsLib[\"fog\"], shader.uniforms]),\n        vertexShader: shader.vertexShader,\n        fragmentShader: shader.fragmentShader,\n        transparent: true,\n        fog: true\n      });\n      if (flowMap !== void 0) {\n        this.material.defines.USE_FLOWMAP = \"\";\n        this.material.uniforms[\"tFlowMap\"] = {\n          type: \"t\",\n          value: flowMap\n        };\n      } else {\n        this.material.uniforms[\"flowDirection\"] = {\n          type: \"v2\",\n          value: flowDirection\n        };\n      }\n      normalMap0.wrapS = normalMap0.wrapT = RepeatWrapping;\n      normalMap1.wrapS = normalMap1.wrapT = RepeatWrapping;\n      this.material.uniforms[\"tReflectionMap\"].value = reflector.getRenderTarget().texture;\n      this.material.uniforms[\"tRefractionMap\"].value = refractor.getRenderTarget().texture;\n      this.material.uniforms[\"tNormalMap0\"].value = normalMap0;\n      this.material.uniforms[\"tNormalMap1\"].value = normalMap1;\n      this.material.uniforms[\"color\"].value = color;\n      this.material.uniforms[\"reflectivity\"].value = reflectivity;\n      this.material.uniforms[\"textureMatrix\"].value = textureMatrix;\n      this.material.uniforms[\"config\"].value.x = 0;\n      this.material.uniforms[\"config\"].value.y = halfCycle;\n      this.material.uniforms[\"config\"].value.z = halfCycle;\n      this.material.uniforms[\"config\"].value.w = scale;\n      function updateTextureMatrix(camera) {\n        textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);\n        textureMatrix.multiply(camera.projectionMatrix);\n        textureMatrix.multiply(camera.matrixWorldInverse);\n        textureMatrix.multiply(scope.matrixWorld);\n      }\n      function updateFlow() {\n        const delta = clock.getDelta();\n        const config = scope.material.uniforms[\"config\"];\n        config.value.x += flowSpeed * delta;\n        config.value.y = config.value.x + halfCycle;\n        if (config.value.x >= cycle) {\n          config.value.x = 0;\n          config.value.y = halfCycle;\n        } else if (config.value.y >= cycle) {\n          config.value.y = config.value.y - cycle;\n        }\n      }\n      this.onBeforeRender = function(renderer, scene, camera) {\n        updateTextureMatrix(camera);\n        updateFlow();\n        scope.visible = false;\n        reflector.matrixWorld.copy(scope.matrixWorld);\n        refractor.matrixWorld.copy(scope.matrixWorld);\n        reflector.onBeforeRender(renderer, scene, camera);\n        refractor.onBeforeRender(renderer, scene, camera);\n        scope.visible = true;\n      };\n    }\n  };\n  let Water22 = _Water2;\n  __publicField(Water22, \"WaterShader\", {\n    uniforms: {\n      color: {\n        value: null\n      },\n      reflectivity: {\n        value: 0\n      },\n      tReflectionMap: {\n        value: null\n      },\n      tRefractionMap: {\n        value: null\n      },\n      tNormalMap0: {\n        value: null\n      },\n      tNormalMap1: {\n        value: null\n      },\n      textureMatrix: {\n        value: null\n      },\n      config: {\n        value: /* @__PURE__ */ new Vector4()\n      }\n    },\n    vertexShader: (\n      /* glsl */\n      `\n\n\t\t#include <common>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tuniform mat4 textureMatrix;\n\n\t\tvarying vec4 vCoord;\n\t\tvarying vec2 vUv;\n\t\tvarying vec3 vToEye;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tvCoord = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\t\t\tvToEye = cameraPosition - worldPosition.xyz;\n\n\t\t\tvec4 mvPosition =  viewMatrix * worldPosition; // used in fog_vertex\n\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}`\n    ),\n    fragmentShader: (\n      /* glsl */\n      `\n\n\t\t#include <common>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tuniform sampler2D tReflectionMap;\n\t\tuniform sampler2D tRefractionMap;\n\t\tuniform sampler2D tNormalMap0;\n\t\tuniform sampler2D tNormalMap1;\n\n\t\t#ifdef USE_FLOWMAP\n\t\t\tuniform sampler2D tFlowMap;\n\t\t#else\n\t\t\tuniform vec2 flowDirection;\n\t\t#endif\n\n\t\tuniform vec3 color;\n\t\tuniform float reflectivity;\n\t\tuniform vec4 config;\n\n\t\tvarying vec4 vCoord;\n\t\tvarying vec2 vUv;\n\t\tvarying vec3 vToEye;\n\n\t\tvoid main() {\n\n\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\tfloat flowMapOffset0 = config.x;\n\t\t\tfloat flowMapOffset1 = config.y;\n\t\t\tfloat halfCycle = config.z;\n\t\t\tfloat scale = config.w;\n\n\t\t\tvec3 toEye = normalize( vToEye );\n\n\t\t\t// determine flow direction\n\t\t\tvec2 flow;\n\t\t\t#ifdef USE_FLOWMAP\n\t\t\t\tflow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;\n\t\t\t#else\n\t\t\t\tflow = flowDirection;\n\t\t\t#endif\n\t\t\tflow.x *= - 1.0;\n\n\t\t\t// sample normal maps (distort uvs with flowdata)\n\t\t\tvec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );\n\t\t\tvec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );\n\n\t\t\t// linear interpolate to get the final normal color\n\t\t\tfloat flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;\n\t\t\tvec4 normalColor = mix( normalColor0, normalColor1, flowLerp );\n\n\t\t\t// calculate normal vector\n\t\t\tvec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );\n\n\t\t\t// calculate the fresnel term to blend reflection and refraction maps\n\t\t\tfloat theta = max( dot( toEye, normal ), 0.0 );\n\t\t\tfloat reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );\n\n\t\t\t// calculate final uv coords\n\t\t\tvec3 coord = vCoord.xyz / vCoord.w;\n\t\t\tvec2 uv = coord.xy + coord.z * normal.xz * 0.05;\n\n\t\t\tvec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );\n\t\t\tvec4 refractColor = texture2D( tRefractionMap, uv );\n\n\t\t\t// multiply water color with the mix of both textures\n\t\t\tgl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <${version >= 154 ? \"colorspace_fragment\" : \"encodings_fragment\"}>\n\t\t\t#include <fog_fragment>\n\n\t\t}`\n    )\n  });\n  return Water22;\n})();\nexport {\n  Water2\n};\n//# sourceMappingURL=Water2.js.map\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}